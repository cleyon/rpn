#!/usr/bin/env python3

rpn_version = 15.4

import calendar
import cmath
import datetime
from   fractions import Fraction
import getopt
import inspect
import itertools
import math
import numpy    as np
import os
import ply.lex  as lex
import ply.yacc as yacc
import queue
import random
import re
import signal
import subprocess
import sys
import time
import traceback


# Global variables
angle_mode        = "d"  # r=radians, d=degrees, g=gradians
date_re           = r'^(\d{1,2})\.(\d{2})(\d{4})$'
date_pat          = re.compile(date_re)
default_protected = True
flag_max          = 64
force_interactive = False
go_interactive    = True
julian_offset     = 1721424 # date.toordinal() returns 1 for 0001-01-01, so compensate
matrix_max        = 1000
rational_re       = r'(\d+)~(\d+)'
rational_pat      = re.compile(rational_re)
show_x            = False
time_re           = r'^[-+]?(\d+)\.(\d{,2})(\d*)$'
time_pat          = re.compile(time_re)

# DEG_PER_RAD  = 360 / TAU
# E            = Base of natural logarithms = exp(1.0)
# GAMMA        = Euler-Mascheroni constant, approx: 1 - tanh(ln(1.57)) - 0.57/(9!)
# GRAD_PER_RAD = 400 / TAU
# LN_2         = ln(2)
# LN_10        = ln(10)
# PHI          = "Golden ratio" = (1 + sqrt(5)) / 2
# PI           = TAU / 2
# RAD_PER_DEG  = TAU / 360
# RAD_PER_GRAD = TAU / 400
# TAU          = Number of radians in a circle (2*PI)

RAD_PER_GRAD =  0.0157079632679489661923132169163975144209858469968755291048747229615390820314310449931401741267105853
RAD_PER_DEG  =  0.0174532925199432957692369076848861271344287188854172545609719144017100911460344944368224156963450948
GAMMA        =  0.5772156649015328606065120900824024310421593359399235988057672348848677267776646709369470632917467495
LN_2         =  0.6931471805599453094172321214581765680755001343602552541206900094933936219696947156058633269964186875
PHI          =  1.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911375
LN_10        =  2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983
E            =  2.7182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664274
PI           =  3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170680
TAU          =  6.2831853071795864769252867665590057683943387987502116419498891846156328125724179972560696506842341360
DEG_PER_RAD  = 57.2957795130823208767981548141051703324054724665643215491602438612028471483245526324409689958511109442
GRAD_PER_RAD = 63.6619772367581343075535053490057448137838582961825794990669376235587190536906140360455211065012343824




#############################################################################
#
#       E X C E P T I O N S
#
#############################################################################
class Rpn_Exception(Exception):
    def __init__(self, msg=""):
        self._message = msg
    def __str__(self):
        return str(self._message)

class Rpn_E_Abort(Rpn_Exception):
    """Rpn_E_Abort is raised by the ABORT and ABORT" words.
It clears the parameter, return, and string stacks.  Caught in p_execute."""
    pass

class Rpn_E_End_Program (Rpn_Exception):
    """Rpn_E_End_Program is raised when there is no more input to parse, or
the interrupt key is signaled.  It is caught in __main__, where processing
is halted, the exit routine prints the stack, and the program exits."""
    pass

class Rpn_E_Exit(Rpn_Exception):
    """Rpn_E_Exit is raised by the word EXIT and terminates execution
of the current word."""
    pass

class Rpn_E_Fatal(Rpn_Exception):
    """Rpn_E_Fatal is raised whenever an internal error is detected that
forces the program to abend.  It is caught in __main__ and causes an
immediate program termination."""
    pass

class Rpn_E_Leave(Rpn_Exception):
    """Rpn_E_Leave is raised by the LEAVE word.  This is caught by
BEGIN or DO loops, and causes an immediate exit from the enclosing loop.
If a loop is not currently executing, it is caught in p_execute() and
an error message is printed."""
    pass

class Rpn_E_Parse_Error(Rpn_Exception):
    """Rpn_E_Parse_Error is raised by p_error and is caught in eval_string()."""
    pass

class Rpn_E_Stack_Overflow(Rpn_Exception):
    pass

class Rpn_E_Top_Level(Rpn_Exception):
    """Rpn_E_Top_Level causes an immediate return to the top level prompt.
It is caught in main_loop."""
    pass




#############################################################################
#
#       D E B U G G I N G
#
#############################################################################
#debug_enabled     = True
debug_enabled     = False

debug_levels = {
    "eval_string"           : 0,
    "p_define_word"         : 0,
    "p_executable"          : 1,
    "p_execute"             : 1,
    "parse"                 : 1,
    "Rpn_Sequence#__init__" : 1,
    "Rpn_Word#__init__"     : 1,
    "scope"                 : 0,
    "show"                  : 0,
    "token"                 : 1,
}


def typename(s):
    t = type(s).__name__
    if t[:4] == "Rpn_":
        return t[4:]
    else:
        return t

def whoami():
    whoami = ""
    previous_frame = inspect.currentframe().f_back
    if "self" in previous_frame.f_locals:
        whoami += previous_frame.f_locals["self"].__class__.__name__ + "#"
    whoami += previous_frame.f_code.co_name
    return whoami

def enable_debug():
    global debug_enabled
    debug_enabled = True

def disable_debug():
    global debug_enabled
    debug_enabled = False

def set_debug(resource, level = 1):
    global debug_enabled, debug_levels

    if resource not in debug_levels:
        print("set_debug: Resource '{}' not valid".format(resource))
        traceback.print_stack(file=sys.stderr)
        sys.exit(1)             # Harsh!

    if level < 0 or level > 9:
        raise Rpn_E_Fatal("set_debug: Level {} out of range (0..9 expected)".format(level))
    debug_levels[resource] = level

def dbg(resource, level = 1, text = None):
    '''Note that a level of -1 will always be True and possibly print the text.
This can be useful to quickly turn a debugging statement on unilaterally;
just change "dbg(res,1,xxx)" to "dbg(res,-1,xxx)".'''
    global debug_enabled, debug_levels

    if resource not in debug_levels:
        print("dbg: Resource '{}' not valid".format(resource))
        traceback.print_stack(file=sys.stderr)
        sys.exit(1)             # Harsh!

    if not debug_enabled or level == 0:
        return False
    flag = debug_levels[resource] >= level
    if flag and text is not None:
        print("{}".format(text))
    return flag





#############################################################################
#
#       S U P P O R T   C L A S S E S
#
#############################################################################
class Rpn_Abort_Quote:
    def __init__(self, val):
        if len(val) < 7 or val[0:6] != 'abort"' or val[-1] != '"':
            raise Rpn_E_Fatal("{}: Malformed string: '{}'".format(whoami(), val))
        self._str = val[6:-1]

    def stringval(self):
        return self._str

    def __call__(self):
        if param_stack.empty():
            raise RuntimeError("abort\": Insufficient parameters (1 required)")
        flag = param_stack.pop()
        if type(flag) is not Rpn_Integer:
            param_stack.push(flag)
            raise TypeError("abort\": Flag must be an integer")
        if flag.value() != 0:
            lnwriteln("{}".format(self.stringval()))
            raise Rpn_E_Abort()

    def __str__(self):
        return "abort\"{}\"".format(self.stringval())

    def __repr__(self):
        return "AbortQuote[{}]".format(repr(self.stringval()))



class Rpn_Begin_Again:
    def __init__(self, seq):
        self._seq = seq

    def __call__(self):
        try:
            while True:
                self._seq.__call__()
        except Rpn_E_Leave:
            pass

    def __str__(self):
        return "begin {} again".format(self._seq)

    def __repr__(self):
        return "BeginAgain[{}]".format(repr(self._seq))


class Rpn_Begin_Until:
    def __init__(self, seq):
        self._seq = seq

    def __call__(self):
        try:
            while True:
                self._seq.__call__()
                if param_stack.empty():
                    raise RuntimeError("until: Insufficient parameters (1 required)")
                flag = param_stack.pop()
                if type(flag) is not Rpn_Integer:
                    param_stack.push(flag)
                    raise TypeError("until: Flag must be an integer")
                if flag.value() != 0:
                    break
        except Rpn_E_Leave:
            pass

    def __str__(self):
        return "begin {} until".format(self._seq)

    def __repr__(self):
        return "BeginUntil[{}]".format(repr(self._seq))


class Rpn_Begin_While:
    def __init__(self, seq1, seq2):
        self._seq1 = seq1
        self._seq2 = seq2

    def __call__(self):
        try:
            while True:
                self._seq1.__call__()
                if param_stack.empty():
                    raise RuntimeError("while: Insufficient parameters (1 required)")
                flag = param_stack.pop()
                if type(flag) is not Rpn_Integer:
                    param_stack.push(flag)
                    raise TypeError("while: Flag must be an integer")
                if flag.value() == 0:
                    break
                self._seq2.__call__()
        except Rpn_E_Leave:
            pass

    def __str__(self):
        return "begin {} while {} repeat".format(self._seq1, self._seq2)

    def __repr__(self):
        return "BeginWhile[{}, {}]".format(repr(self._seq1), repr(self._seq2))


class Rpn_Case:
    def __init__(self, case_clauses, otherwise_seq):
        self._case_clauses  = case_clauses
        self._otherwise_seq = otherwise_seq

    def __call__(self):
        if param_stack.empty():
            raise RuntimeError("case: Insufficient parameters (1 required)")
        n = param_stack.pop()
        if type(n) is not Rpn_Integer:
            param_stack.push(n)
            raise TypeError("case: Case control parameter must be an integer")
        nval = n.value()
        ran = False
        for clause in self._case_clauses.items():
            ran = clause.attempt_call(nval)
            if ran:
                break
        if not ran:
            self._otherwise_seq.__call__()

    def __str__(self):
        s = "case "
        for cc in self._case_clauses.items():
            s += str(cc)
        if self._otherwise_seq is not None:
            s += "otherwise {} ".format(self._otherwise_seq)
        s += "endcase"
        return s

    def __repr__(self):
        s = "Case["
        s += ", ".join([ repr(cc) for cc in self._case_clauses.items() ])
        if self._otherwise_seq is not None:
            s += ", Otherwise[{}]".format(repr(self._otherwise_seq))
        return s + "]"

class Rpn_Case_Clause:
    def __init__(self, x, seq):
        self._x = x             # x is a plain integer, not an Rpn_Integer
        self._seq = seq

    def attempt_call(self, n):
        if n == self._x:
            self._seq.__call__()
            return True
        else:
            return False

    def __str__(self):
        return "{} of {} endof ".format(self._x, self._seq)

    def __repr__(self):
        return "Of[{}={}]".format(self._x, repr(self._seq))

class Rpn_Complex:
    def __init__(self, real=0.0, imag=0.0):
        self.set_real_imag(real, imag)

    @classmethod
    def from_complex(cls, cplx):
        return cls(cplx.real, cplx.imag)

    def value(self):
        return self._value

    def real(self):
        return self.value().real

    def imag(self):
        return self.value().imag

    def set_real_imag(self, real, imag):
        self._value = complex(float(real), float(imag))

    def zerop(self):
        return self.real() == 0.0 and self.imag() == 0.0

    def __call__(self):
        param_stack.push(self)

    def __str__(self):
        return "({}, {})".format(self.real(), self.imag()) # sprintf?

    def __repr__(self):
        return "Complex[{}]".format(repr(self.value()))


class Rpn_Constant:
    def __init__(self, var):
        self._variable = var

    def __call__(self):
        #print("Rpn_Constant#__call__")
        if param_stack.empty():
            raise RuntimeError("constant: Insufficient parameters (1 required)")
        self._variable.set_obj(param_stack.pop())

    def __str__(self):
        return "constant {}".format(self._variable.name())

    def __repr__(self):
        return "Constant[{}]".format(repr(self._variable))


class Rpn_Do_Loop:
    def __init__(self, seq):
        self._seq = seq
        seq.scope().set_variable('_I', Rpn_Variable('_I', None, hidden=True))

    def __call__(self):
        if param_stack.size() < 2:
            raise RuntimeError("do: Insufficient parameters (2 required)")
        x = param_stack.pop()
        y = param_stack.pop()
        if type(y) is not Rpn_Integer or type(x) is not Rpn_Integer:
            param_stack.push(y)
            param_stack.push(x)
            raise TypeError("do: Loop control parameters must be integers")
        _I = self._seq.scope().variable('_I')
        limit = y.value()
        i = x.value()
        _I.set_obj(x)
        if i == limit:
            #lnwriteln("do: Not executing because initial == limit")
            return

        try:
            while True:
                self._seq.__call__()
                i += 1
                _I.set_obj(Rpn_Integer(i))
                if i >= limit:
                    break
        except Rpn_E_Leave:
            pass

    def __str__(self):
        return "do {} loop".format(self._seq)

    def __repr__(self):
        return "DoLoop[{}]".format(repr(self._seq))


class Rpn_Do_PlusLoop:
    def __init__(self, seq):
        self._seq = seq
        seq.scope().set_variable('_I', Rpn_Variable('_I', None, hidden=True))

    def __call__(self):
        if param_stack.size() < 2:
            raise RuntimeError("do: Insufficient parameters (2 required)")
        x = param_stack.pop()
        y = param_stack.pop()
        if type(y) is not Rpn_Integer or type(x) is not Rpn_Integer:
            param_stack.push(y)
            param_stack.push(x)
            raise TypeError("do: Loop control parameters must be integers")
        _I = self._seq.scope().variable('_I')
        limit = y.value()
        i = x.value()
        _I.set_obj(x)
        if i == limit:
            #lnwriteln("do: Not executing because initial == limit")
            return

        try:
            while True:
                self._seq.__call__()
                if param_stack.empty():
                    raise RuntimeError("+loop: Insufficient parameters (1 required)")
                incr = param_stack.pop()
                if type(incr) is not Rpn_Integer:
                    param_stack.push(incr)
                    raise TypeError("+loop: Increment must be integer")
                i += incr.value()
                _I.set_obj(Rpn_Integer(i))
                if    incr.value() > 0 and i >= limit \
                   or incr.value() < 0 and i < limit:
                    break
        except Rpn_E_Leave:
            pass

    def __str__(self):
        return "do {} +loop".format(self._seq)

    def __repr__(self):
        return "DoPlusLoop[{}]".format(repr(self._seq))


class Rpn_Dot_Quote:
    def __init__(self, val):
        if len(val) < 3 or val[0:2] != '."' or val[-1] != '"':
            raise Rpn_E_Fatal("{}: Malformed string: '{}'".format(whoami(), val))
        self._str = val[2:-1]

    def stringval(self):
        return self._str

    def __call__(self):
        write("{}".format(self.stringval()))

    def __str__(self):
        return ".\"{}\"".format(self.stringval())

    def __repr__(self):
        return "DotQuote[{}]".format(repr(self.stringval()))


class Rpn_Fetch_Var:
    def __init__(self, id, var):
        if type(var) is not Rpn_Variable:
            raise Rpn_E_Fatal("{}: Variable {} is not an Rpn_Variable".format(whoami(), id))
        self._identifier = id
        self._variable = var

    def variable(self):
        return self._variable

    def identifier(self):
        return self._identifier

    def __call__(self):
        var = self.variable()

        # Can't happen, but be paranoid
        if type(var) is not Rpn_Variable:
            raise Rpn_E_Fatal("{}: Variable '{}' is not an Rpn_Variable".format(whoami(), self.identifier()))
        elif var.obj() is None:
            raise RuntimeError("{}: Variable is not defined".format(self.identifier()))
        else:
            param_stack.push(var.obj())

    def __str__(self):
        # XXX modifiers
        return "@{}".format(self.identifier())

    def __repr__(self):
        return "Fetch[{}]".format(self.identifier())


class Rpn_Float:
    def __init__(self, val=0.0):
        self._value = float(val)

    def __call__(self):
        param_stack.push(self)

    def value(self):
        return self._value

    def set_value(self, val):
        self._value = float(val)

    def zerop(self):
        return self.value() == 0.0

    def date_info(self):
        """A float in the form MM.DDYYYY might represent a date.
Extract some information about a date formatted this way.
Success:  (True, dateobj, julian)
          dateobj is datetime.date, julian is an int
Failure:  (False, None, None)"""

        match = date_pat.match("%.6f" % self.value())
        if match is None:
            return (False, None, None)

        mm   = match.group(1)
        dd   = match.group(2)
        yyyy = match.group(3)
        try:
            dateobj = datetime.date(int(yyyy), int(mm), int(dd))
        except ValueError:
            return (False, None, None)

        # date.toordinal() returns 1 for 0001-01-01, so compensate
        julian = dateobj.toordinal() + julian_offset
        return (True, dateobj, julian)

    def time_info(self):
        """A float in the format HH.MMSSssss might represent a time.
Extract some information about a time formatted this way.
Note: This routine can unpack an arbitrary number of hours, potentially
greater than 24, so there may not be a valid timeobj even if it parses okay.
Success:  (True, HH, MM, SS, timeobj)
Failure:  (False, None, None, None, None)"""

        match = time_pat.match("%f" % self.value())
        if match is None:
            return (False, None, None, None, None)

        hh = int(  match.group(1))
        mm = int(  match.group(2))
        ss = float(match.group(3)) / 100.0
        try:
            timeobj = datetime.time(hh, mm, round(ss))
        except ValueError:
            timeobj = None
        return (True, hh, mm, ss, timeobj)

    def __str__(self):
        return "{}".format(self.value()) # sprintf

    def __repr__(self):
        return "Float[{}]".format(repr(self.value()))


class Rpn_Forget:
    def __init__(self, word, scope):
        if type(word) is not Rpn_Word:
            raise Rpn_E_Fatal("{}: Word {} is not an Rpn_Word".format(whoami(), repr(word)))
        if type(scope) is not Rpn_Scope:
            raise Rpn_E_Fatal("{}: Scope {} is not an Rpn_Scope".format(whoami(), repr(scope)))
        self._word = word
        self._scope = scope

    def __call__(self):
        if self._word.protected():
            raise RuntimeError("forget: '{}' is protected".format(self._word.name()))
        self._scope.delete_word(self._word.name())

    def __str__(self):
        return "forget {}".format(self._word.name())

    def __repr__(self):
        return "Forget[{}]".format(repr(self._word.name()))


class Rpn_Help:
    def __init__(self, id, doc):
        self._identifier = id
        self._doc = doc

    def __call__(self):
        lnwriteln(self.doc())

    def identifier(self):
        return self._identifier

    def doc(self):
        return self._doc

    def __str__(self):
        return "help {}".format(self.identifier())

    def __repr__(self):
        return "Help[{}]".format(repr(self.identifier()))


class Rpn_If:
    def __init__(self, seq):
        self._seq = seq

    def __call__(self):
        if param_stack.empty():
            raise RuntimeError("if: Insufficient parameters (1 required)")
        flag = param_stack.pop()
        if type(flag) is not Rpn_Integer:
            param_stack.push(flag)
            raise TypeError("if: Flag must be an integer")
        if flag.value() != 0:
            self._seq.__call__()

    def __str__(self):
        return "if {} then".format(self._seq)

    def __repr__(self):
        return "If[{}]".format(repr(self._seq))


class Rpn_If_Else:
    def __init__(self, seq1, seq2):
        self._seq1 = seq1
        self._seq2 = seq2

    def __call__(self):
        if param_stack.empty():
            raise RuntimeError("if: Insufficient parameters (1 required)")
        flag = param_stack.pop()
        if type(flag) is not Rpn_Integer:
            param_stack.push(flag)
            raise TypeError("if: Flag must be an integer")
        if flag.value() != 0:
            self._seq1.__call__()
        else:
            self._seq2.__call__()

    def __str__(self):
        return "if {} else {} then".format(self._seq1, self._seq2)

    def __repr__(self):
        return "IfElse[{}, {}]".format(repr(self._seq1), repr(self._seq2))


class Rpn_Integer:
    def __init__(self, val=0):
        self._value = int(val)

    def value(self):
        return self._value

    def set_value(self, val):
        self._value = int(val)

    def zerop(self):
        return self.value() == 0

    def __call__(self):
        param_stack.push(self)

    def __str__(self):
        return "{}".format(self.value()) # sprintf

    def __repr__(self):
        return "Integer[{}]".format(repr(self.value()))


class Rpn_List:
    def __init__(self, item=None, oldlist=None):
        if item is None and oldlist is None:
            self._list = []
        elif item is not None and oldlist is None:
            self._list = [ item ]
        else:
            val = []
            for x in oldlist.listval():
                val.append(x)
            val.insert(0, item)
            self._list = val

    def listval(self):
        return self._list

    def __call__(self):
        caught_exit = False
        for item in self.listval():
            # lnwriteln("{}: {}.__call__()".format(whoami(), item))
            try:
                item.__call__()
            except Rpn_E_Exit:
                caught_exit = True
                break
        if caught_exit is True:
            raise Rpn_E_Exit

    def items(self):
        for item in self.listval():
            yield item

    def __len__(self):
        return len(self.listval())

    def __str__(self):
        return " ".join([ str(item) for item in self.listval() ])

    def __repr__(self):
        return "List[" + ", ".join([ repr(item) for item in self.listval() ]) + "]"


class Rpn_Matrix:
    def __init__(self, vals):
        #lnwriteln("{}: vals={}".format(whoami(), repr(vals)))
        self._nrows = len(vals)
        cols = -1
        vecs = []
        for x in vals.items():
            #lnwriteln("x={}".format(repr(x)))
            vecs.append(x.value())
            if cols == -1:
                cols = x.size()
            else:
                if x.size() != cols:
                    raise RuntimeError("Matrix: Number of columns is not consistent")
        self._ncols = cols
        #lnwriteln("{} rows x {} columns".format(self.nrows(), self.ncols()))
        #print("vecs", vecs)
        self._np_value = np.array(vecs)
        #print("val",repr(self.value()))

    @classmethod
    def from_numpy(cls, x):
        obj = cls(Rpn_List())
        obj._nrows, obj._ncols = x.shape
        obj.set_np(x)
        return obj

    def value(self):
        return self._np_value

    def set_np(self, np_obj):
        self._np_value = np_obj

    def nrows(self):
        return self._nrows

    def ncols(self):
        return self._ncols

    def __call__(self):
        param_stack.push(self)

    def __str__(self):
        return str(self.value())

    def __repr__(self):
        return "Matrix[{}]".format(repr(self.value()))


class Rpn_Rational:
    def __init__(self, num=0, denom=1):
        self._value = Fraction(int(num), int(denom))

    @classmethod
    def from_Fraction(cls, frac):
        return cls(frac.numerator, frac.denominator)

    @classmethod
    def from_string(cls, s):
        match = rational_pat.match(s)
        if match is None:
            raise Rpn_E_Fatal("Rational pattern failed to match")
        return cls(match.group(1), match.group(2))

    def value(self):
        return self._value

    def numerator(self):
        return self.value().numerator

    def denominator(self):
        return self.value().denominator

    def set_num_denom(self, num, denom):
        self._value = Fraction(int(num), int(denom))

    def zerop(self):
        return self.numerator() == 0

    def __call__(self):
        param_stack.push(self)

    def __str__(self):
        return "{}~{}".format(self.numerator(), self.denominator())

    def __repr__(self):
        return "Rational[{}]".format(repr(self.value()))


class Rpn_Scope:
    def __init__(self, name):
        self._name = name
        self._words = {}
        self._variables = {}

    def name(self):
        return self._name

    def words(self):
        return self._words

    def variables(self):
        return self._variables

    def set_word(self, identifier, word):
        if type(word) is not Rpn_Word:
            raise Rpn_E_Fatal("{}: Word {} is not an Rpn_Word".format(whoami(), identifier))
        self._words[identifier] = word

    def delete_word(self, identifier):
        del self._words[identifier]

    def word(self, identifier):
        return self._words.get(identifier)

    def set_variable(self, identifier, var):
        if type(var) is not Rpn_Variable:
            raise Rpn_E_Fatal("{}: Variable {} is not an Rpn_Variable".format(whoami(), identifier))
        self._variables[identifier] = var

    def delete_variable(self, identifier):
        del self._variables[identifier]

    def variable(self, identifier):
        return self._variables.get(identifier)

    def words(self):
        return self._words

    def visible_variables(self):
        return list( filter( lambda x: not x[1].hidden(), self.variables().items() ) )

    def __str__(self):
        s = ""
        if len(self.visible_variables()) > 0:
            s += "|" + " ".join([ x[0] for x in self.visible_variables() ]) + "|"
            if len(self.words()) > 0:
                s += " "
        if len(self.words()) > 0:
            s += " ".join([ w.definition_as_string(dbg("show")) for w in self.words().values() ])
        return s

    def __repr__(self):
        return "Scope[{}={}]".format(self.name(), hex(id(self)))


class Rpn_Sequence:
    def __init__(self, scope, exe_seq):
        self._scope    = scope
        self._exe_seq  = exe_seq
        #dbg(whoami(), 1, "{}: scope={}, exe_seq={}".format(whoami(), repr(scope), repr(exe_seq)))
        #print(repr(scope.variables()))

    def __call__(self):
        # TODO check param_stack.size() vs len(in_vars)

        push_scope(self.scope(), "Calling {}".format(repr(self)))
        try:
            # lnwriteln("{}: seq={}".format(whoami(), repr(self.seq())))
            self.seq().__call__()
        except Rpn_E_Exit:
            raise
        finally:
            s = pop_scope("{} complete".format(repr(self)))

        # TODO push out variables onto param_stack

    def scope(self):
        return self._scope

    def seq(self):
        return self._exe_seq

    def __str__(self):
        scope_str = str(self.scope())
        s = "{}{}{}".format(scope_str,
                            " " if len(scope_str) > 0 else "",
                            str(self.seq()))
        return s

    def __repr__(self):
        return "Sequence[{}, {}]".format(repr(self.scope()), repr(self.seq()))


class Rpn_Show:
    def __init__(self, word, scope):
        if type(word) is not Rpn_Word:
            raise Rpn_E_Fatal("{}: Word {} is not an Rpn_Word".format(whoami(), repr(word)))
        if type(scope) is not Rpn_Scope:
            raise Rpn_E_Fatal("{}: Scope {} is not an Rpn_Scope".format(whoami(), repr(scope)))
        self._word = word
        self._scope = scope

    def __call__(self):
        writeln(self._word.definition_as_string(dbg("show")))

    def __str__(self):
        return "show {}".format(self._word.name())

    def __repr__(self):
        return "Show[{}]".format(repr(self._word.name()))


class Rpn_Stack:
    def __init__(self, capacity=-1):
        self.clear()
        self._cap = capacity

    def clear(self):
        self._stack = []
        self._nitems = 0

    def size(self):
        return self._nitems

    def empty(self):
        return self.size() == 0

    def push(self, item):
        if self.size() == self._cap:
            raise Rpn_E_Stack_Overflow("Exceeded capacity {} on {}".format(self._cap, item))
        self._nitems += 1
        self._stack.append(item)

    def pop(self):
        if self.empty():
            raise Rpn_E_Fatal("{}: Empty stack".format(whoami()))
        self._nitems -= 1
        return self._stack.pop()

    def pick(self, n):
        if n < 0 or n >= self.size():
            raise Rpn_E_Fatal("{}: Bad index".format(whoami()))
        return self._stack[self.size() - 1 - n]

    def roll(self, n):
        if n < 0 or n >= self.size():
            raise Rpn_E_Fatal("{}: Bad index".format(whoami()))
        item = self._stack.pop(self.size() - 1 - n)
        self._nitems -= 1
        self.push(item)

    def top(self):
        if self.empty():
            raise Rpn_E_Fatal("{}: Empty stack".format(whoami()))
        return self._stack[self.size() - 1]

    def items_bottom_to_top(self):
        """Return stack items from bottom to top."""
        i = self._nitems + 1
        for item in self._stack:
            i -= 1
            yield (i-1, item)

    def items_top_to_bottom(self):
        """Return stack items from top to bottom."""
        return reversed(list(self.items_bottom_to_top()))

    def __str__(self):
        sa = []
        for (i, item) in self.items_bottom_to_top():
            sa.append("{}: {}".format(i, item))
        #print(sa)
        return "\n".join(sa)

    def __repr__(self):
        sa = []
        for (i, item) in self.items_bottom_to_top():
            sa.append("{}: {}".format(i, repr(item)))
        #print(sa)
        return "Stack[{}]".format(", ".join(sa))


class Rpn_Store_Var:
    def __init__(self, id, var):
        if type(var) is not Rpn_Variable:
            raise Rpn_E_Fatal("!{}: Variable is not an Rpn_Variable".format(id))
        self._identifier = id
        self._variable = var

    def identifier(self):
        return self._identifier

    def __call__(self):
        if param_stack.empty():
            raise RuntimeError("!{}: Insufficient parameters (1 required)".format(self.identifier()))
        if self._variable.readonly():
            raise RuntimeError("!{}: Variable cannot be modified".format(self.identifier()))
        self._variable.set_obj(param_stack.pop())

    def __str__(self):
        # XXX modifiers
        return "!{}".format(self.identifier())

    def __repr__(self):
        return "Store[{}]".format(self.identifier())


class Rpn_String:
    def __init__(self, val):
        if len(val) < 2 or val[0] != '"' or val[-1] != '"':
            raise Rpn_E_Fatal("{}: Malformed string: '{}'".format(whoami(), val))
        self._value = val[1:-1]

    def value(self):
        return self._value

    def set_value(self, val):
        self._value == val

    def __call__(self):
        string_stack.push(self)

    def __str__(self):
        return "\"{}\"".format(str(self.value()))

    def __repr__(self):
        return "String[{}]".format(repr(self.value()))


class Rpn_Variable:
    def __init__(self, rawname, obj=None, **kwargs):
        if not Rpn_Variable.name_valid_p(rawname):
            raise Rpn_E_Fatal("Invalid variable name '{}'".format(rawname))

        self._constant  = False
        self._hidden    = False
        self._rawname   = rawname
        self._noshadow  = False
        self._protected = False
        self._readonly  = False
        self._rpnobj    = obj

        if kwargs.get("constant"):
            self._constant = kwargs["constant"]
            del kwargs["constant"]

        if kwargs.get("hidden"):
            self._hidden = kwargs["hidden"]
            del kwargs["hidden"]

        if kwargs.get("noshadow"):
            self._noshadow = kwargs["noshadow"]
            del kwargs["noshadow"]

        if kwargs.get("protected"):
            self._protected = kwargs["protected"]
            del kwargs["protected"]

        if kwargs.get("readonly"):
            self._readonly = kwargs["readonly"]
            del kwargs["readonly"]

        if len(kwargs) > 0:
            for (key, val) in kwargs.items():
                lnwriteln("Unrecognized keyword '{}'={}".format(key, val))
                raise Rpn_E_Fatal("Could not construct variable '{}'".format(rawname))

    @classmethod
    def name_valid_p(cls, name):
        return not (name is None or len(name) == 0 or \
                    name[0] in ['+','-','*','/','?'] )

    def obj(self):
        return self._rpnobj

    def set_obj(self, newobj):
        self._rpnobj = newobj

    def name(self):
        return self._rawname

    def defined(self):
        return self.obj() is not None

    def constant(self):
        return self._constant

    def hidden(self):
        return self._hidden

    def noshadow(self):
        return self._noshadow

    def protected(self):
        return self._protected

    def readonly(self):
        return self._readonly

    def __str__(self):
        return str(self._rawname)

    def __repr__(self):
        return "Variable[{}]".format(self._rawname)


class Rpn_Vector:
    def __init__(self, vals):
        if type(vals) is not Rpn_List:
            raise Rpn_E_Fatal("{}: vals is not an Rpn_List ({})".format(whoami(), repr(vals)))
        self._np_value = np.array([ elem.value() for elem in vals.listval() ])

    @classmethod
    def from_numpy(cls, x):
        obj = cls(Rpn_List())
        # print(type(obj))
        # print("from_numpy: {}".format(repr(obj)))
        obj.set_np(x)
        # print("from_numpy: {}".format(repr(obj)))
        return obj

    def value(self):
        return self._np_value

    def set_np(self, np_obj):
        self._np_value = np_obj

    def size(self):
        return self.value().size

    def __call__(self):
        param_stack.push(self)

    def __str__(self):
        return "{}".format(self._np_value)

    def __repr__(self):
        return "Vector[{}]".format(repr(self._np_value))


class Rpn_Word:
    def __init__(self, name, defn, **kwargs):
        global default_protected

        self._args      = 0
        self._defn      = defn
        self._doc       = None
        self._hidden    = False
        self._name      = name
        self._protected = default_protected
        self._str_args  = 0

        if name is None or len(name) == 0:
            raise Rpn_E_Fatal("Invalid word name '{}'".format(name))
        if defn is None:
            raise Rpn_E_Fatal("{}: defn is None".format(name))
        dbg(whoami(), 1, "defn is {}".format(type(defn)))
        if kwargs.get("args"):
            self._args = kwargs['args']
            del kwargs["args"]
        if kwargs.get("doc"):
            self._doc = kwargs["doc"]
            del kwargs["doc"]
        if kwargs.get("hidden"):
            self._hidden = kwargs["hidden"]
            del kwargs["hidden"]
        if kwargs.get("protected"):
            self._protected = kwargs["protected"]
            del kwargs["protected"]
        if kwargs.get("str_args"):
            self._str_args = kwargs["str_args"]
            del kwargs["str_args"]
        if len(kwargs) > 0:
            for (key, val) in kwargs.items():
                lnwriteln("Unrecognized keyword '{}'={}".format(key, val))
                raise Rpn_E_Fatal("Could not construct word '{}'".format(name))

    def __call__(self):
        if param_stack.size() < self.args():
            raise RuntimeError("{}: Insufficient parameters ({} required)".format(self.name(), self.args()))
        if string_stack.size() < self.str_args():
            raise RuntimeError("{}: Insufficient string parameters ({} required)".format(self.name(), self.str_args()))

        try:
            self._defn.__call__()
        except Rpn_E_Exit:
            if self.name() == "exit":
                raise

    def name(self):
        return self._name

    def args(self):
        return self._args

    def str_args(self):
        return self._str_args

    def doc(self):
        return self._doc

    def hidden(self):
        return self._hidden

    def protected(self):
        return self._protected

    def definition_as_string(self, debugging):
        if debugging or typename(self._defn) == 'function':
            return repr(self)
        elif type(self._defn) is Rpn_Sequence:
            return ": {} {} ;".format(self.name(),
                                       self._defn)
        else:
            raise Rpn_E_Fatal("{}: Unhandled type {}".format(whoami(), type(self._defn)))

    def __str__(self):
        return self.name()

    def __repr__(self):
        if typename(self._defn) == 'function':
            return "Word[{}]".format(self.name())
        else:
            return "Word[{}, {}]".format(self.name(),repr(self._defn))




#############################################################################
#
#       L E X E R
#
#############################################################################
reserved_words = {
    '+loop'     : 'PLUS_LOOP',
    'again'     : 'AGAIN',
    'begin'     : 'BEGIN',
    'case'      : 'CASE',
    'constant'  : 'CONSTANT',
    'do'        : 'DO',
    'else'      : 'ELSE',
    'endcase'   : 'ENDCASE',
    'endof'     : 'ENDOF',
    'forget'    : 'FORGET',
    'help'      : 'HELP',
    'if'        : 'IF',
    'loop'      : 'LOOP',
    'of'        : 'OF',
    'otherwise' : 'OTHERWISE',
    'repeat'    : 'REPEAT',
    'show'      : 'SHOW',
    'then'      : 'THEN',
    'undef'     : 'UNDEF',
    'until'     : 'UNTIL',
    'variable'  : 'VARIABLE',
    'while'     : 'WHILE',
}

tokens = [
    'ABORT_QUOTE',
    'AT_SIGN',
    'BACKSLASH',
    'CLOSE_BRACKET',
    'CLOSE_PAREN',
    'COLON',
    'COMMA',
    'DOC_STR',
    'DOT_QUOTE',
    'EXCLAM',
    'FLOAT',
    'IDENTIFIER',
    'INTEGER',
    'OPEN_BRACKET',
    'OPEN_PAREN',
    'RATIONAL',
    'SEMICOLON',
    'STRING',
    'VBAR',
    'WS',
] + list(reserved_words.values())

def t_newline(t):
    r'\n+'
    t.lexer.lineno += len(t.value)

def t_STRING(t):
    r'"([^"]|\n)*"'
    t.type = 'STRING'
    return t

def t_RATIONAL(t):
    r'[0-9]+~[0-9+]'
    t.type = 'RATIONAL'
    return t

def t_FLOAT(t):
    r'[-+]?(\d+(\.\d*[eE][-+]?\d+|[eE][-+]?\d+|\.\d*))|(\d*(\.\d+[eE][-+]?\d+|[eE][-+]?\d+|\.\d+))'
    t.value = str(float(t.value))
    t.type = 'FLOAT'
    return t

# Beware bad input - e.g., "0b177" is parsed as two token, "0b1" and "77".
# Note a little Python magic: int(xxx, 0) will guess base and parse "0x", etc.
# On the whole, the benefits outweigh the drawbacks.
def t_INTEGER(t):
    r'[-+]?((((0x)|(0X))[0-9a-fA-F]+)|(((0o)|(0O))[0-7]+)|(((0b)|(0B))[0-1]+)|(\d+))'
    t.value = str(int(t.value, 0))
    t.type = 'INTEGER'
    return t

def t_ABORT_QUOTE(t):
    r'abort"([^"]|\n)*"'
    return t

def t_AT_SIGN(t):
    r'@'
    t.type = 'AT_SIGN'
    return t

def t_BACKSLASH(t):
    r'\\.*'
    type = 'BACKSLASH'
    return t

def t_CLOSE_PAREN(t):
    r'\)'
    t.type = 'CLOSE_PAREN'
    return t

def t_CLOSE_BRACKET(t):
    r'\]'
    t.type = 'CLOSE_BRACKET'
    return t

def t_COMMA(t):
    r','
    t.type = 'COMMA'
    return t

def t_DOC_STR(t):
    r'doc:"([^"]|\n)*"'
    return t

def t_DOT_QUOTE(t):
    r'\."([^"]|\n)*"'
    return t

def t_EXCLAM(t):
    r'!'
    t.type = 'EXCLAM'
    return t

def t_OPEN_BRACKET(t):
    r'\['
    t.type = 'OPEN_BRACKET'
    return t

def t_OPEN_PAREN(t):
    r'\('
    t.type = 'OPEN_PAREN'
    return t

def t_VBAR(t):
    r'\|'
    t.type = 'VBAR'
    return t

def t_WS(t):
    r'[ \t\n]+'

def t_IDENTIFIER(t):
    r'[-#$%&\*+,./:;<=>?A-Z^_a-z][-!"#$%&\'*+,./0-9:;<=>?@A-Z^_a-z~]*'

    single_chars = {
        ':': 'COLON',
        ';': 'SEMICOLON',
    }
    if len(t.value) == 1:
        if t.value in single_chars:
            t.type = single_chars[t.value]
    else:
        #print("ID:'{}'".format(t.value))
        t.type = reserved_words.get(t.value, 'IDENTIFIER')
    return t

def t_error(t):
    #print("Illegal character '%s'" % t.value[0])
    t.value = t.value[0]
    t.type = 'ERROR'
    t.lexer.skip(1)
    return t




#############################################################################
#
#       P A R S E R
#
#############################################################################
def p_empty(p):
    '''empty :'''

    pass

def p_error(p):
    raise Rpn_E_Parse_Error(p if p is not None else 'EOF')


def p_evaluate(p):
    '''evaluate :  cmd
                |  cmd  evaluate'''

def p_cmd(p):
    '''cmd :  executable  execute'''


def p_executable(p):
    '''executable :  abort_quote
                  |  begin_again
                  |  begin_until
                  |  begin_while
                  |  case
                  |  colon_def
                  |  comment
                  |  constant
                  |  do_loop
                  |  do_plusloop
                  |  dot_quote
                  |  fetch_var
                  |  forget
                  |  help
                  |  if_then
                  |  if_else_then
                  |  matrix
                  |  number
                  |  show
                  |  store_var
                  |  string
                  |  undef
                  |  variable
                  |  vector
                  |  word'''

    p[0] = p[1]
    dbg("p_executable", 1, "p_executable: {}".format(p[0]))

def p_execute(p):
    '''execute :  empty'''
    executable = p[-1]
    if executable is None:
        return

    dbg("p_execute", 1, "p_execute: {}".format(repr(executable)))
    try:
        executable.__call__()
    except KeyboardInterrupt:
        writeln()
        writeln("[Interrupt]")
    except RuntimeError as e:
        lnwriteln(str(e))
    except TypeError as e:
        lnwriteln(str(e))
    except ValueError as e:
        lnwriteln(str(e))


def p_abort_quote(p):
    '''abort_quote :  ABORT_QUOTE'''

    p[0] = Rpn_Abort_Quote(p[1])


def p_begin_again(p):
    '''begin_again :  BEGIN  sequence  AGAIN'''

    p[0] = Rpn_Begin_Again(p[2])


def p_begin_until(p):
    '''begin_until :  BEGIN  sequence  UNTIL'''

    p[0] = Rpn_Begin_Until(p[2])


def p_begin_while(p):
    '''begin_while :  BEGIN  sequence  WHILE  sequence  REPEAT'''

    p[0] = Rpn_Begin_While(p[2], p[4])


def p_case(p):
    '''case :  CASE  case_clauses  otherwise_opt  ENDCASE'''
    p[0] = Rpn_Case(p[2], p[3])

def p_case_clauses(p):
    '''case_clauses :  case_clause
                    |  case_clause  case_clauses'''
    if len(p) == 2:
        p[0] = Rpn_List(p[1])
    else:
        p[0] = Rpn_List(p[1], p[2])

def p_case_clause(p):
    '''case_clause : INTEGER  OF  sequence  ENDOF'''
    p[0] = Rpn_Case_Clause(p[1], p[3])

def p_otherwise_opt(p):
    '''otherwise_opt : empty
                     | OTHERWISE  sequence'''
    if len(p) == 2:
        p[0] = Rpn_List()
    else:
        p[0] = Rpn_List(p[2])


def p_colon_def(p):
    '''colon_def :  COLON  IDENTIFIER  docstr_opt  sequence  SEMICOLON  define_word'''

    # This returns None because `define_word' does all the work
    p[0] = None

def p_colon_def_error(p):
    '''colon_def :  COLON  IDENTIFIER  docstr_opt  error  SEMICOLON '''

    lnwriteln("{}: Syntax error in definition".format(p[2]))
    raise SyntaxError

def p_define_word(p):
    '''define_word : empty'''

    sequence   = p[-2]
    doc_str    = p[-3]
    identifier = p[-4]
    # lnwriteln("{}: identifier={}  doc_str={}  sequence={}".format(whoami(), identifier, repr(doc_str), repr(sequence)))

    kwargs = dict()
    if doc_str is not None:
        if len(doc_str) < 6 or doc_str[0:5] != 'doc:"' or doc_str[-1] != '"':
            raise Rpn_E_Fatal("{}: Malformed doc_str: '{}'".format(whoami(), doc_str))
        doc_str = doc_str[5:-1]
        kwargs['doc'] = doc_str

    # p_sequence() has already popped the scope for this word, so
    # creating it now in scope_stack.top() will be correct.
    new_word = Rpn_Word(identifier, sequence, **kwargs)
    dbg("p_define_word", 1, "{}: Defining word {}={} in scope {}".format(whoami(), identifier, repr(new_word), repr(scope_stack.top())))
    scope_stack.top().set_word(identifier, new_word)

    p[0] = new_word
    dbg("p_define_word", 2, "{}: Returning {}".format(whoami(), repr(p[0])))

def p_docstr_opt(p):
    '''docstr_opt :  empty
                  |  DOC_STR'''

    p[0] = p[1]


def p_comment(p):
    '''comment :  BACKSLASH'''


def p_do_loop(p):
    '''do_loop :  DO  sequence  LOOP'''

    p[0] = Rpn_Do_Loop(p[2])


def p_do_plusloop(p):
    '''do_plusloop :  DO  sequence  PLUS_LOOP'''

    p[0] = Rpn_Do_PlusLoop(p[2])


def p_dot_quote(p):
    '''dot_quote :  DOT_QUOTE'''

    p[0] = Rpn_Dot_Quote(p[1])


def p_forget(p):
    '''forget :  FORGET  IDENTIFIER'''

    name = p[2]
    (word, scope) = lookup_word(name)
    if word is None:
        lnwriteln("forget: '{}' not found".format(name))
        raise SyntaxError
    else:
        p[0] = Rpn_Forget(word, scope)


def p_help(p):
    '''help :  HELP  AGAIN
            |  HELP  BEGIN
            |  HELP  CASE
            |  HELP  COLON
            |  HELP  CONSTANT
            |  HELP  DO
            |  HELP  DOT_QUOTE
            |  HELP  ELSE
            |  HELP  ENDCASE
            |  HELP  ENDOF
            |  HELP  FORGET
            |  HELP  HELP
            |  HELP  IDENTIFIER
            |  HELP  IF
            |  HELP  LOOP
            |  HELP  OF
            |  HELP  OTHERWISE
            |  HELP  PLUS_LOOP
            |  HELP  REPEAT
            |  HELP  SEMICOLON
            |  HELP  SHOW
            |  HELP  THEN
            |  HELP  UNDEF
            |  HELP  UNTIL
            |  HELP  VARIABLE
            |  HELP  WHILE'''

    name = p[2]
    (word, _) = lookup_word(name)
    if word is None:
        lnwriteln("help: '{}' not found".format(name))
        raise SyntaxError
    else:
        p[0] = Rpn_Help(name, word.doc() if word.doc() is not None \
                                        and len(word.doc()) > 0 \
                        else "No help available for '{}'".format(name))


def p_if_then(p):
    '''if_then :  IF  sequence  THEN'''

    p[0] = Rpn_If(p[2])


def p_if_else_then(p):
    '''if_else_then :  IF  sequence  ELSE  sequence  THEN'''

    p[0] = Rpn_If_Else(p[2], p[4])


def p_show(p):
    '''show :  SHOW  IDENTIFIER'''

    name = p[2]
    (word, scope) = lookup_word(name)
    if word is None:
        lnwriteln("show: '{}' not found".format(name))
        raise SyntaxError
    else:
        p[0] = Rpn_Show(word, scope)


def p_store_var(p):
    '''store_var :  EXCLAM  IDENTIFIER'''

    id = p[2]
    #lnwriteln("{}: Looking up {}".format(whoami(), id))
    (var, _) = lookup_variable(id)
    if var is None:
        lnwriteln("!{}: Variable not found".format(id))
        raise SyntaxError
    if var.constant():
        lnwriteln("!{}: Constant cannot be modified".format(id))
        raise SyntaxError
    p[0] = Rpn_Store_Var(id, var)


# A "word" is not just an identifier, a word is something that is
# findable somewhere in the scope_stack.  It is a syntax error if
# the identifier is not found.
def p_word(p):
    '''word :  IDENTIFIER'''

    name = p[1]
    (word, _) = lookup_word(name)
    if word is None:
        lnwriteln("Word '{}' not found".format(name))
        raise SyntaxError
    else:
        #print("p_word: word is of type '{}'".format(type(word)))
        p[0] = word


def p_sequence(p):
    '''sequence : locals_opt executables_opt'''

    # `locals_opt' is an Rpn_Scope; `executables_opt' is an Rpn_List
    scope = pop_scope("p_sequence() is finishing")
    p[0] = Rpn_Sequence(p[1], p[2])


def p_locals_opt(p):
    '''locals_opt :  empty
                  |  VBAR  ids_opt  VBAR'''
    name = None
    idx = -1
    while name is None:
        if p[idx] in ['begin', 'do', 'else', 'if', 'otherwise']:
            name = p[idx]
        elif p[idx] == 'of':
            name = "of_" + p[idx - 1]
        elif p[idx] == ':':
            name = ":" + p[idx + 1]
        else:
            # lnwriteln("p_locals_opt: Not sure about {}".format(p[idx]))
            # name = "locals"
            idx -= 1

    scope = Rpn_Scope(name)
    #print("{}: Creating new scope {}".format(whoami(), scope))
    variables = Rpn_List()

    if len(p) == 4:
        variables = p[2]
        for varname in variables.items():
            if not Rpn_Variable.name_valid_p(varname):
                lnwriteln("Variable name '{}' is not valid".format(varname))
                raise SyntaxError
            var = Rpn_Variable(varname)
            #lnwriteln("{}: Defining variable {} in scope {}".format(whoami(), varname, scope))
            scope.set_variable(varname, var)

    push_scope(scope, "New sequence (locals={})".format(variables))
    p[0] = scope


def p_ids_opt(p):
    '''ids_opt :  empty
               |  IDENTIFIER  ids_opt'''

    if len(p) == 2:
        p[0] = Rpn_List()
    elif len(p) == 3:
        p[0] = Rpn_List(p[1], p[2])


def p_executables_opt(p):
    '''executables_opt :  empty
                       |  executable  executables_opt'''

    if len(p) == 2:
        p[0] = Rpn_List()
    elif len(p) == 3:
        if p[1] is None:
            p[0] = p[2]
        else:
            p[0] = Rpn_List(p[1], p[2])
    # lnwriteln("{}: Returning {}".format(whoami(), p[0])))


def p_number(p):
    '''number :  real
              |  rational
              |  complex'''

    p[0] = p[1]


def p_real(p):
    '''real :  integer
            |  float'''

    p[0] = p[1]


def p_integer(p):
    '''integer :  INTEGER'''

    p[0] = Rpn_Integer(p[1])


def p_float(p):
    '''float :  FLOAT'''

    p[0] = Rpn_Float(p[1])


def p_rational(p):
   #'''rational :  integer  TILDE  integer'''
    '''rational :  RATIONAL'''
    p[0] = Rpn_Rational.from_string(p[1])


def p_complex(p):
    '''complex :  OPEN_PAREN  real  COMMA  real  CLOSE_PAREN '''
    p[0] = Rpn_Complex(p[2].value(), p[4].value())


def p_string(p):
    '''string :  STRING'''

    p[0] = Rpn_String(p[1])


def p_vector(p):
    '''vector :  OPEN_BRACKET  numbers_opt  CLOSE_BRACKET'''

    p[0] = Rpn_Vector(p[2])


def p_numbers_opt(p):
    '''numbers_opt :  empty
                   |  number  numbers_opt'''

    if len(p) == 2:
        p[0] = Rpn_List()
    elif len(p) == 3:
        p[0] = Rpn_List(p[1], p[2])


def p_matrix(p):
    '''matrix :  OPEN_BRACKET  vectors  CLOSE_BRACKET'''

    p[0] = Rpn_Matrix(p[2])


def p_constant(p):
    '''constant :  CONSTANT  IDENTIFIER'''

    id = p[2]
    #print("p_constant {}".format(id))
    if not Rpn_Variable.name_valid_p(id):
        lnwriteln("CONSTANT: '{}' is not valid".format(id))
        raise SyntaxError

    (var, scope) = lookup_variable(id)
    if var is not None and var.noshadow():
        lnwriteln("CONSTANT: '{}' cannot be shadowed".format(id))
        raise SyntaxError

    if scope is not None and scope == scope_stack.top():
        lnwriteln("CONSTANT: '{}' redefined".format(id))
        raise SyntaxError

    var = Rpn_Variable(id, constant=True)
    scope_stack.top().set_variable(id, var)
    p[0] = Rpn_Constant(var)


def p_undef(p):
    '''undef :  UNDEF  IDENTIFIER'''

    id = p[2]
    if not Rpn_Variable.name_valid_p(id):
        lnwriteln("UNDEF: '{}' is not valid".format(id))
        raise SyntaxError

    (var, scope) = lookup_variable(id)

    if var is None:
        lnwriteln("UNDEF: Variable '{}' not found".format(id))
        raise SyntaxError

    if var.protected():
        lnwriteln("UNDEF: '{}' is protected".format(id))
        raise SyntaxError

    if scope != scope_stack.top():
        lnwriteln("UNDEF: '{}' out of scope".format(id))
        raise SyntaxError

    scope_stack.top().delete_variable(id)


def p_variable(p):
    '''variable :  VARIABLE  IDENTIFIER'''

    id = p[2]
    if not Rpn_Variable.name_valid_p(id):
        lnwriteln("VARIABLE: '{}' is not valid".format(id))
        raise SyntaxError

    (var, scope) = lookup_variable(id)

    if var is not None and var.noshadow():
        lnwriteln("VARIABLE: '{}' cannot be shadowed".format(id))
        raise SyntaxError

    if scope is not None and scope == scope_stack.top():
        lnwriteln("VARIABLE: '{}' redefined".format(id))
        raise SyntaxError

    var = Rpn_Variable(id)
    scope_stack.top().set_variable(id, var)


def p_vectors(p):
    '''vectors :  vector
               |  vector  vectors'''

    #lnwriteln("{}: len={}".format(whoami(), len(p)))
    if len(p) == 2:
        p[0] = Rpn_List(p[1])
    elif len(p) == 3:
        p[0] = Rpn_List(p[1], p[2])


def p_fetch_var(p):
    '''fetch_var :  AT_SIGN  IDENTIFIER'''

    id = p[2]
    # lnwriteln("{}: Looking up {}".format(whoami(), id))
    (var, _) = lookup_variable(id)
    if var is None:
        lnwriteln("@{}: Variable not found".format(id))
        raise SyntaxError
    p[0] = Rpn_Fetch_Var(id, var)





#############################################################################
#
#       W O R D   D E F I N I T I O N S
#
#############################################################################
global_scope = Rpn_Scope("GLOBAL")

class defword(object):
    """Register the following word definition in the global scope"""

    def __init__(self, **kwargs):
        self._kwargs = kwargs

    def __call__(self, f):
        def wrapped_f(**kwargs):
            #print("Decorator args: {}".format(self._kwargs))
            f()
        if "name" in self._kwargs and len(self._kwargs["name"]) > 0:
            name = self._kwargs["name"]
            del self._kwargs["name"]
        else:
            raise RuntimeError("Missing or invalid \"name\" attribute")
        word = Rpn_Word(name, wrapped_f, **self._kwargs)
        global global_scope
        global_scope.set_word(name, word)
        return wrapped_f


@defword(name='$.', str_args=1, doc="""\
Print top item from string stack  [ str -- ]
No extraneous white space or newline is printed.""")
def w_dollar_dot():
    write(string_stack.pop().value())
    global show_x
    show_x = False


@defword(name='$.!', hidden=True, str_args=1)
def w_dollar_dot_bang():
    lnwriteln(repr(string_stack.top()))
    global show_x
    show_x = False


@defword(name='$.s', doc="""\
Display string stack.""")
def w_dollar_dot_s():
    if not string_stack.empty():
        lnwriteln(string_stack)
    global show_x
    show_x = False


@defword(name='$.s!', hidden=True)
def w_dollar_dot_s_bang():
    if not string_stack.empty():
        lnwriteln(repr(string_stack))
    global show_x
    show_x = False


@defword(name='%', args=2, doc="""\
Percentage  ( base rate -- base percent )

Base is maintained in Y.

DEFINTION:
                 rate
percent = base * ----
                  100""")
def w_percent():
    x = param_stack.pop()
    y = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       and type(y) in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        base = float(y.value())
        rate = float(x.value())
        r = base * rate / 100.0
        if type(x) is Rpn_Integer and type(y) is Rpn_Integer and r.is_integer():
            result = Rpn_Integer(r)
        else:
            result = Rpn_Float(r)
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("%: Type error ({}, {})".format(typename(y), typename(x)))
    param_stack.push(y)
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='%ch', args=2, doc="""\
Percentage change  ( old new -- %change )

DEFINITION:

          new - old
%change = --------- * 100
             old

old cannot be zero.""")
def w_percent_ch():
    x = param_stack.pop()
    y = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       and type(y) in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        if y.zerop():
            param_stack.push(y)
            param_stack.push(x)
            raise ValueError("%ch: Y cannot be zero")
        else:
            old = float(y.value())
            new = float(x.value())
            r = (new - old) * 100.0 / old
            if type(x) is Rpn_Integer and type(y) is Rpn_Integer and r.is_integer():
                result = Rpn_Integer(r)
            else:
                result = Rpn_Float(r)
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("%ch: Type error ({}, {})".format(typename(y), typename(x)))
    # The HP-32SII preserves the Y value (like %) but we do not
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='%t', args=2, doc="""\
Percent of total  ( total amount -- %tot )

DEFINITION:

         amount
%Total = ------ * 100
         total

total cannot be zero.""")
def w_percent_t():
    x = param_stack.pop()
    y = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       and type(y) in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        if y.zerop():
            param_stack.push(y)
            param_stack.push(x)
            raise ValueError("%t: Y cannot be zero")
        else:
            total  = float(y.value())
            amount = float(x.value())
            r = amount * 100.0 / total
            if type(x) is Rpn_Integer and type(y) is Rpn_Integer and r.is_integer():
                result = Rpn_Integer(r)
            else:
                result = Rpn_Float(r)
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("%t: Type error ({}, {})".format(typename(y), typename(x)))
    # The HP-32SII preserves the Y value (like %) but we do not
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='*', args=2, doc="""\
Multiplication  ( y x -- y*x )""")
def w_star():
    """\
|----------+----------+---------+----------+---------+--------+--------|
| Integer  | Integer  | Float   | Rational | Complex |        |        |
| Float    | Float    | Float   | Float    | Complex |        |        |
| Rational | Rational | Float   | Rational | Complex |        |        |
| Complex  | Complex  | Complex | Complex  | Complex |        |        |
| Vector   |          |         |          |         |        |        |
| Matrix   |          |         |          |         |        |        |
|----------+----------+---------+----------+---------+--------+--------|
| ^Y    X> | Integer  | Float   | Rational | Complex | Vector | Matrix |"""
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is Rpn_Integer and type(y) is Rpn_Integer:
        result = Rpn_Integer(y.value() * x.value())
    elif    type(x) is Rpn_Float and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational] \
         or type(y) is Rpn_Float and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(float(y.value()) * float(x.value()))
    elif    type(x) is Rpn_Rational and type(y) in [Rpn_Integer, Rpn_Rational] \
         or type(y) is Rpn_Rational and type(x) in [Rpn_Integer, Rpn_Rational]:
        result = Rpn_Rational.from_Fraction(y.value() * x.value())
    elif    type(x) is Rpn_Complex and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
         or type(y) is Rpn_Complex and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        result = Rpn_Complex.from_complex(complex(y.value()) * complex(x.value()))
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("+: Type error ({}, {})".format(typename(y), typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='+', args=2, doc="""\
Addition  ( y x -- y+x )""")
def w_plus():
    """\
|----------+----------+---------+----------+---------+--------+--------|
| Integer  | Integer  | Float   | Rational | Complex | Vector | Matrix |
| Float    | Float    | Float   | Float    | Complex | Vector | Matrix |
| Rational | Rational | Float   | Rational | Complex | Vector | Matrix |
| Complex  | Complex  | Complex | Complex  | Complex | Vector | Matrix |
| Vector   | Vector   | Vector  | Vector   | Vector  | Vector |        |
| Matrix   | Matrix   | Matrix  | Matrix   | Matrix  |        | Matrix |
|----------+----------+---------+----------+---------+--------+--------|
| ^Y    X> | Integer  | Float   | Rational | Complex | Vector | Matrix |"""
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is Rpn_Integer and type(y) is Rpn_Integer:
        result = Rpn_Integer(y.value() + x.value())
    elif    type(x) is Rpn_Float and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational] \
         or type(y) is Rpn_Float and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(float(y.value()) + float(x.value()))
    elif    type(x) is Rpn_Rational and type(y) in [Rpn_Integer, Rpn_Rational] \
         or type(y) is Rpn_Rational and type(x) in [Rpn_Integer, Rpn_Rational]:
        result = Rpn_Rational.from_Fraction(y.value() + x.value())
    elif    type(x) is Rpn_Complex and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
         or type(y) is Rpn_Complex and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        result = Rpn_Complex.from_complex(complex(y.value()) + complex(x.value()))
    elif    type(x) is Rpn_Vector and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
         or type(y) is Rpn_Vector and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        r = np.add(y.value(), x.value())
        result = Rpn_Vector.from_numpy(r)
    elif type(x) is Rpn_Vector and type(y) is Rpn_Vector:
        if x.size() != y.size():
            param_stack.push(y)
            param_stack.push(x)
            raise ValueError("+: Conformability error: Vectors ({} and {}) are not same size".format(y, x))
        r = np.add(y.value(), x.value())
        # print(type(r))
        # print(r)
        result = Rpn_Vector.from_numpy(r)
    elif    type(x) is Rpn_Matrix and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
         or type(y) is Rpn_Matrix and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        r = np.add(y.value(), x.value())
        result = Rpn_Matrix.from_numpy(r)
    elif type(x) is Rpn_Matrix and type(y) is Rpn_Matrix:
        if x.nrows() != y.nrows() or x.ncols() != y.ncols():
            param_stack.push(y)
            param_stack.push(x)
            raise ValueError("+: Conformability error: Matrices ({} and {}) are not same size".format(y, x))
        r = np.add(y.value(), x.value())
        # print(type(r))
        # print(r)
        result = Rpn_Matrix.from_numpy(r)
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("+: Type error ({}, {})".format(typename(y), typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='+loop', doc="""\
Execute a definite loop.
<limit> <initial> DO xxx <incr> +LOOP

The iteration counter is available via I.  LEAVE will exit the loop early.

Example: 10 0 do I . 2 +loop
prints 0 2 4 6 8

qv DO, I, LEAVE, LOOP""")
def w_plusloop():
    pass                        # Grammar rules handle this word


@defword(name='-', args=2, doc="""\
Subtraction  ( y x -- y-x )""")
def w_minus():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is Rpn_Integer and type(y) is Rpn_Integer:
        result = Rpn_Integer(y.value() - x.value())
    elif    type(x) is Rpn_Float and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational] \
         or type(y) is Rpn_Float and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(float(y.value()) - float(x.value()))
    elif    type(x) is Rpn_Rational and type(y) in [Rpn_Integer, Rpn_Rational] \
         or type(y) is Rpn_Rational and type(x) in [Rpn_Integer, Rpn_Rational]:
        result = Rpn_Rational.from_Fraction(y.value() - x.value())
    elif    type(x) is Rpn_Complex and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
         or type(y) is Rpn_Complex and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        result = Rpn_Complex.from_complex(complex(y.value()) - complex(x.value()))
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("-: Type error ({}, {})".format(typename(y), typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='-rot', args=3, doc="""\
Rotate top stack element back to third spot,
pulling others down  ( z y x -- x z y )
Equivalent to ROT ROT""")
def w_minus_rot():
    x = param_stack.pop()
    y = param_stack.pop()
    z = param_stack.pop()
    param_stack.push(x)
    param_stack.push(z)
    param_stack.push(y)


@defword(name='.', args=1, doc="""\
Print top stack value  ( x -- )
A space is also printed after the number, but no newline.
If you need a newline, call CR.""")
def w_dot():
    write("{} ".format(str(param_stack.pop())))
    global show_x
    show_x = False


@defword(name='.!', hidden=True, args=1)
def w_dot_bang():
    lnwriteln(repr(param_stack.top()))
    global show_x
    show_x = False


@defword(name='."', doc="""\
Display string enclosed by quotation marks.
No newline is printed afterwards.

NOTE: The string begins immediately after the first ", so
  ."Hello, world!"
is correct.  This is different from Forth, where the must be a space after ." """)
def w_dot_quote():
    pass                        # Grammar rules handle this word


@defword(name='.b', args=1, doc="""\
Print X in binary  ( i -- )
X must be an integer.""")
def w_dot_bin():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise TypeError(".b: Type error ({})".format(typename(x)))

    write("{} ".format(bin(x.value())))
    global show_x
    show_x = False


@defword(name='.o', args=1, doc="""\
Print X in octal  ( i -- )
X must be an integer.""")
def w_dot_oct():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise TypeError(".o: Type error ({})".format(typename(x)))

    write("{} ".format(oct(x.value())))
    global show_x
    show_x = False


@defword(name='.s', doc="""\
Print stack non-destructively""")
def w_dot_s():
    if not param_stack.empty():
        lnwriteln(param_stack)
    global show_x
    show_x = False


@defword(name='.s!', hidden=True, doc="""\
Print stack non-destructively""")
def w_dot_s_bang():
    if not param_stack.empty():
        lnwriteln(repr(param_stack))
    global show_x
    show_x = False


@defword(name='.x', args=1, doc="""\
Print X in hexadecimal  ( i -- )
X must be an integer.""")
def w_dot_hex():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise TypeError(".x: Type error ({})".format(typename(x)))

    write("{} ".format(hex(x.value())))
    global show_x
    show_x = False


@defword(name='/', args=2, doc="""\
Division  ( y x -- y/x )
X cannot be zero.""")
def w_slash():
    """\
|----------+----------+---------+----------+---------+--------+--------|
| Integer  | Float    | Float   | Rational | Complex |        |        |
| Float    | Float    | Float   | Float    | Complex |        |        |
| Rational | Rational | Float   | Rational | Complex |        |        |
| Complex  | Complex  | Complex | Complex  | Complex |        |        |
| Vector   |          |         |          |         |        |        |
| Matrix   |          |         |          |         |        |        |
|----------+----------+---------+----------+---------+--------+--------|
| ^Y    X> | Integer  | Float   | Rational | Complex | Vector | Matrix |"""
    x = param_stack.pop()
    y = param_stack.pop()

    if     type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
       and x.zerop():
        param_stack.push(y)
        param_stack.push(x)
        raise ValueError("/: X cannot be zero")

    if    type(x) is Rpn_Rational and type(y) in [Rpn_Integer, Rpn_Rational] \
       or type(y) is Rpn_Rational and type(x) in [Rpn_Integer, Rpn_Rational]:
        result = Rpn_Rational.from_Fraction(y.value() / x.value())
    elif    type(x) in [Rpn_Integer, Rpn_Float] and type(y) in [Rpn_Integer, Rpn_Float] \
         or type(x) is Rpn_Rational and type(y) is Rpn_Float \
         or type(y) is Rpn_Rational and type(x) is Rpn_Float:
        r = float(y.value()) / float(x.value())
        if type(x) is Rpn_Integer and type(y) is Rpn_Integer and r.is_integer():
            result = Rpn_Integer(r)
        else:
            result = Rpn_Float(r)
    elif    type(x) is Rpn_Complex and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
         or type(y) is Rpn_Complex and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        result = Rpn_Complex.from_complex(complex(y.value()) / complex(x.value()))
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("/: Type error ({}, {})".format(typename(y), typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='0<', args=1, doc="""\
Test if X is less than zero  ( x -- flag )""")
def w_zero_less_than():
    x = param_stack.pop()
    if type(x) not in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        param_stack.push(x)
        raise TypeError("0<: Type error ({})".format(typename(x)))

    param_stack.push(Rpn_Integer(1 if x.value() < 0 else 0))
    global show_x
    show_x = True


@defword(name='0<>', args=1, doc="""\
Test if X is not equal to zero  ( x -- flag )""")
def w_zero_not_equal():
    x = param_stack.pop()
    if type(x) not in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        param_stack.push(x)
        raise TypeError("0<>: Type error ({})".format(typename(x)))

    param_stack.push(Rpn_Integer(0 if x.zerop() else 1))
    global show_x
    show_x = True


@defword(name='0=', args=1, doc="""\
Test if X is equal to zero  ( x -- flag )""")
def w_zero_equal():
    x = param_stack.pop()
    if type(x) not in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        param_stack.push(x)
        raise TypeError("0=: Type error ({})".format(typename(x)))

    param_stack.push(Rpn_Integer(1 if x.zerop() else 0))
    global show_x
    show_x = True


@defword(name='0>', args=1, doc="""\
Test if X is greater than zero  ( x -- flag )""")
def w_zero_greater_than():
    x = param_stack.pop()
    if type(x) not in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        param_stack.push(x)
        raise TypeError("0>: Type error ({})".format(typename(x)))

    param_stack.push(Rpn_Integer(1 if x.value() > 0 else 0))
    global show_x
    show_x = True


@defword(name=':', doc="""\
Define a new word  ( -- )
: WORD  [def ...] ;

Define WORD with the specified definition.
Terminate the definition with a semi-colon.""")
def w_colon():
    pass                        # Grammar rules handle this word


@defword(name=';', doc="""\
Terminate WORD definition  ( -- )
: WORD  [def ...] ;""")
def w_semicolon():
    pass                        # Grammar rules handle this word


@defword(name='<', args=2, doc="""\
Test if Y is less than X  ( y x -- flag )""")
def w_less_than():
    x = param_stack.pop()
    y = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       and type(y) in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        yval = float(y.value())
        xval = float(x.value())
        param_stack.push(Rpn_Integer(1 if yval < xval else 0))
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("<: Type error ({}, {})".format(typename(y), typename(x)))
    global show_x
    show_x = True


@defword(name='<<', args=2, doc="""\
<<  ( i2 i1 -- i2 << i1 )  Bitwise left shift""")
def w_leftshift():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("<<: Type error ({}, {})".format(typename(y), typename(x)))

    if x.value() < 0:
        param_stack.push(y)
        param_stack.push(x)
        raise ValueError("<<: Shift amount may not be negative")

    param_stack.push(Rpn_Integer(y.value() << x.value()))
    global show_x
    show_x = True


@defword(name='<=', args=2, doc="""\
Test if Y is less than or equal to X  ( y x -- flag )""")
def w_less_than_or_equal():
    x = param_stack.pop()
    y = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       and type(y) in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        yval = float(y.value())
        xval = float(x.value())
        param_stack.push(Rpn_Integer(1 if yval <= xval else 0))
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("<=: Type error ({}, {})".format(typename(y), typename(x)))
    global show_x
    show_x = True


@defword(name='<>', args=2, doc="""\
Test if Y is not equal to X  ( y x -- flag )""")
def w_not_equal():
    """\
|----------+----------+---------+----------+---------+--------+--------|
| Integer  |   xxxx   |  xxx    |  xxxx    | xxxx    |        |        |
| Float    |   xxxxx  |  xxx    |   xxxx   | xxx     |        |        |
| Rational |   xxxx   |  xxx    |  xxxxx   | xxxx    |        |        |
| Complex  |    xxxx  |  xxx    |   xxx    | xxx     |        |        |
| Vector   |          |         |          |         |        |        |
| Matrix   |          |         |          |         |        |        |
|----------+----------+---------+----------+---------+--------+--------|
| ^Y    X> | Integer  | Float   | Rational | Complex | Vector | Matrix |"""
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is Rpn_Integer and type(y) is Rpn_Integer:
        flag = y.value() == x.value()
    elif    type(x) is Rpn_Float and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational] \
         or type(y) is Rpn_Float and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        flag = float(y.value()) == float(x.value()) # Beware floating point equality lossage
    elif    type(x) is Rpn_Rational and type(y) in [Rpn_Integer, Rpn_Rational] \
         or type(y) is Rpn_Rational and type(x) in [Rpn_Integer, Rpn_Rational]:
        flag = Fraction(y.value()) == Fraction(x.value())
    elif    type(x) is Rpn_Complex and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
         or type(y) is Rpn_Complex and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        flag = complex(y.value()) == complex(x.value())
    # XXX - it should be possible to compare vectors and matrices for equality:
    # Check if dimensions and components match
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("<>: Type error ({}, {})".format(typename(y), typename(x)))
    param_stack.push(Rpn_Integer(0 if flag else 1))
    global show_x
    show_x = True


@defword(name='=', args=2, doc="""\
Test if Y is equal to X  ( y x -- flag )""")
def w_equal():
    """\
|----------+----------+---------+----------+---------+--------+--------|
| Integer  |   xxxx   |  xxx    |  xxxx    | xxxx    |        |        |
| Float    |   xxxxx  |  xxx    |   xxxx   | xxx     |        |        |
| Rational |   xxxx   |  xxx    |  xxxxx   | xxxx    |        |        |
| Complex  |    xxxx  |  xxx    |   xxx    | xxx     |        |        |
| Vector   |          |         |          |         |        |        |
| Matrix   |          |         |          |         |        |        |
|----------+----------+---------+----------+---------+--------+--------|
| ^Y    X> | Integer  | Float   | Rational | Complex | Vector | Matrix |"""
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is Rpn_Integer and type(y) is Rpn_Integer:
        flag = y.value() == x.value()
    elif    type(x) is Rpn_Float and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational] \
         or type(y) is Rpn_Float and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        flag = float(y.value()) == float(x.value()) # Beware floating point equality lossage
    elif    type(x) is Rpn_Rational and type(y) in [Rpn_Integer, Rpn_Rational] \
         or type(y) is Rpn_Rational and type(x) in [Rpn_Integer, Rpn_Rational]:
        flag = Fraction(y.value()) == Fraction(x.value())
    elif    type(x) is Rpn_Complex and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
         or type(y) is Rpn_Complex and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        flag = complex(y.value()) == complex(x.value())
    # XXX - it should be possible to compare vectors and matrices for equality:
    # Check if dimensions and components match
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("=: Type error ({}, {})".format(typename(y), typename(x)))
    param_stack.push(Rpn_Integer(1 if flag else 0))
    global show_x
    show_x = True


@defword(name='>', args=2, doc="""\
Test if Y is greater than X  ( y x -- flag )""")
def w_greater_than():
    x = param_stack.pop()
    y = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       and type(y) in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        yval = float(y.value())
        xval = float(x.value())
        param_stack.push(Rpn_Integer(1 if yval > xval else 0))
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError(">: Type error ({}, {})".format(typename(y), typename(x)))
    global show_x
    show_x = True


@defword(name='>>', args=2, doc="""\
>>  ( i2 i1 -- i2 >> i1 )  Bitwise right shift""")
def w_rightshift():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError(">>: Type error ({}, {})".format(typename(y), typename(x)))

    if x.value() < 0:
        param_stack.push(y)
        param_stack.push(x)
        raise ValueError("<<: Shift amount may not be negative")

    param_stack.push(Rpn_Integer(y.value() >> x.value()))
    global show_x
    show_x = True


@defword(name='>=', args=2, doc="""\
Test if Y is greater than or equal to X  ( y x -- flag )""")
def w_less_than_or_equal():
    x = param_stack.pop()
    y = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       and type(y) in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        yval = float(y.value())
        xval = float(x.value())
        param_stack.push(Rpn_Integer(1 if yval >= xval else 0))
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError(">=: Type error ({}, {})".format(typename(y), typename(x)))
    global show_x
    show_x = True


@defword(name='>r', args=1, doc="""\
Push X onto return stack  ( x -- )""")
def w_to_r():
    return_stack.push(param_stack.pop())


@defword(name='?dup', args=1, doc="""\
Duplicate top stack element if non-zero  ( x -- x x | 0 )""")
def w_query_dup():
    x = param_stack.top()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        if not x.zerop():
            w_dup()
    else:
        param_stack.push(x)
        raise TypeError("?dup: Type error ({})".format(typename(x)))


@defword(name='^', args=2, doc="""\
Exponentiation  ( y x -- y^x )""")
def w_caret():
    x = param_stack.pop()
    y = param_stack.pop()
    if    type(x) not in [Rpn_Integer, Rpn_Rational, Rpn_Float, Rpn_Complex] \
       or type(y) not in [Rpn_Integer, Rpn_Rational, Rpn_Float, Rpn_Complex]:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("^: Type error ({}, {})".format(typename(y), typename(x)))

    r = pow(y.value(), x.value())
    if type(r) is int:
        result = Rpn_Integer(r)
    elif type(r) is float:
        result = Rpn_Float(r)
    elif type(r) is complex:
        result = Rpn_Complex.from_complex(r)
    else:
        raise Rpn_E_Fatal("pow() returned a strange type '{}'".format(type(r)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='abort', doc="""\
Abort execution and return to top level

qv ABORT", EXIT, LEAVE""")
def w_abort():
    raise Rpn_E_Abort()


@defword(name='abort"', doc="""\
Conditionally abort execution  ( flag -- )
If flag is non-zero, abort execution and print a message
(up to the closing quotation mark) and return to top level

qv ABORT, EXIT, LEAVE""")
def w_abort_quote():
    pass                        # Grammar rules handle this word


@defword(name='abs', doc="""\
Absolute value  ( x -- |x| )

NOTE: For complex numbers, ABS return the modulus (as a float).""")
def w_abs():
    x = param_stack.pop()
    if type(x) is Rpn_Integer:
        result = Rpn_Integer(abs(x.value()))
    elif type(x) in [Rpn_Float, Rpn_Complex]:
        result = Rpn_Float(abs(x.value()))
    elif type(x) is Rpn_Rational:
        result = Rpn_Rational.from_Fraction(abs(x.value()))
    else:
        param_stack.push(x)
        raise TypeError("abs: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='acos', args=1, doc="""\
Arc cosine  ( cosine -- angle )""")
def w_acos():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        try:
            r = math.acos(float(x.value()))
        except ValueError:
            param_stack.push(x)
            raise ValueError("acos: Argument {} out of range".format(x.value()))
        result = Rpn_Float(convert_radians_to_mode(r))
    elif type(x) is Rpn_Complex:
        result = Rpn_Complex.from_complex(cmath.acos(x.value()))
    else:
        param_stack.push(x)
        raise TypeError("acos: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='again', doc="""\
Execute an indefinite loop forever.
BEGIN xxx AGAIN

LEAVE will exit the loop early.

qv BEGIN, LEAVE, REPEAT, UNTIL, WHILE""")
def w_again():
    pass                        # Grammar rules handle this word


@defword(name='and', args=2, doc="""\
Logical AND  ( flag flag -- flag )
(This is not a bitwise AND - use BITAND for that.)""")
def w_and():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("and: Type error ({})".format(typename(y), typename(y)))

    if x.value() not in [0, 1]:
        param_stack.push(y)
        param_stack.push(x)
        raise ValueError("and: X must be TRUE (1) or FALSE (0), not {}".format(x.value()))
    if y.value() not in [0, 1]:
        param_stack.push(y)
        param_stack.push(x)
        raise ValueError("and: Y must be TRUE (1) or FALSE (0), not {}".format(y.value()))

    param_stack.push(Rpn_Integer(x.value() and y.value()))
    global show_x
    show_x = True


@defword(name='asin', args=1, doc="""\
Arc sine  ( sine -- angle )""")
def w_asin():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        try:
            r = math.asin(float(x.value()))
        except ValueError:
            param_stack.push(x)
            raise ValueError("asin: Argument {} out of range".format(x.value()))
        result = Rpn_Float(convert_radians_to_mode(r))
    elif type(x) is Rpn_Complex:
        result = Rpn_Complex.from_complex(cmath.asin(x.value()))
    else:
        param_stack.push(x)
        raise TypeError("asin: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='atan', doc="""\
Arc tangent  ( tangent -- angle )""")
def w_atan():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(convert_radians_to_mode(math.atan(float(x.value()))))
    elif type(x) is Rpn_Complex:
        result = Rpn_Complex.from_complex(cmath.atan(x.value()))
    else:
        param_stack.push(x)
        raise TypeError("atan: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='beg', doc="""\
Set "Begin" financial mode.

Do not confuse this with the BEGIN command, which starts a loop.""")
def w_beg():
    global_scope.variable('BEG').set_obj(Rpn_Integer(1))


@defword(name='begin', doc="""\
Execute an indefinite loop.
BEGIN xxx AGAIN
BEGIN xxx <flag> UNTIL
BEGIN xxx <flag> WHILE yyy REPEAT

LEAVE will exit the loop early.  Note that the effect of the test in
BEGIN...WHILE is opposite that in BEGIN...UNTIL.  The loop repeats
while something is true, rather than until it becomes true.

Do not confuse this with the BEG command, which sets "begin mode" for
Time Value of Money calculations.

qv AGAIN, LEAVE, REPEAT, UNTIL, WHILE""")
def w_begin():
    pass                        # Grammar rules handle this word


@defword(name='bitand', args=2, doc="""\
bitand  ( i2 i1 -- i2 AND i1 )  Bitwise AND

Perform a bitwise boolean AND on two integers""")
def w_bitand():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("bitand: Type error ({}, {})".format(typename(y), typename(x)))

    param_stack.push(Rpn_Integer(y.value() & x.value()))
    global show_x
    show_x = True


@defword(name='bitnot', args=1, doc="""\
bitnot  ( i1 -- NOT i1 )  Bitwise NOT

Perform a bitwise boolean NOT on an integer""")
def w_bitor():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise TypeError("bitnot: Type error ({})".format(typename(x)))

    param_stack.push(Rpn_Integer(~ x.value()))
    global show_x
    show_x = True


@defword(name='bitor', args=2, doc="""\
bitor  ( i2 i1 -- i2 OR i1 )  Bitwise OR

Perform a bitwise boolean OR on two integers""")
def w_bitor():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("bitor: Type error ({}, {})".format(typename(y), typename(x)))

    param_stack.push(Rpn_Integer(y.value() | x.value()))
    global show_x
    show_x = True


@defword(name='bitxor', args=2, doc="""\
bitxor  ( i2 i1 -- i2 XOR i1 )  Bitwise XOR

Perform a bitwise boolean Exclusive OR on two integers""")
def w_bitor():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("bitxor: Type error ({}, {})".format(typename(y), typename(x)))

    param_stack.push(Rpn_Integer(y.value() ^ x.value()))
    global show_x
    show_x = True


@defword(name='bye', doc="""\
Exit program""")
def w_bye():
    raise Rpn_E_End_Program()


@defword(name='case', doc="""\
Execute a sequence of words based on stack value.  Once a match is
executed, no other clauses are considered.  OTHERWISE is optional.
<n> and OF labels must be integers.

<n> CASE
  <x> OF xxx ENDOF
  <y> OF yyy ENDOF
  <z> OF zzz ENDOF
  [ OTHERWISE aaa ]
ENDCASE

qv ENDCASE, ENDOF, OF, OTHERWISE
""")
def w_case():
    pass                        # Grammar rules handle this word


@defword(name='ceil', doc="""\
Ceiling  ( x -- ceil )   Smallest integer greater than or equal to X""")
def w_ceil():
    x = param_stack.pop()
    if type(x) is Rpn_Integer:
        result = x
    elif type(x) in [Rpn_Float, Rpn_Rational]:
        result = Rpn_Integer(math.ceil(x.value()))
    else:
        param_stack.push(x)
        raise TypeError("ceil: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='cf', args=1)
def w_cf():
    x = param_stack.pop()
    if type(x) is Rpn_Integer:
        if x.value() < 0 or x.value() > flag_max - 1:
            param_stack.push(x)
            raise ValueError("cf: Flag out of range (0..{} expected)".format(flag_max - 1))
        flag_clear(x.value())
    else:
        param_stack.push(x)
        raise TypeError("cf: Type error ({})".format(typename(x)))


# Some HP calcs call this NEGATE, but why type 6 characters when 3 will do?
@defword(name='chs', args=1, doc="""\
Negation (change sign)  ( x -- -x )""")
def w_chs():
    x = param_stack.pop()
    if type(x) is Rpn_Integer:
        result = Rpn_Integer(-1 * x.value())
    elif type(x) is Rpn_Float:
        result = Rpn_Float(-1.0 * x.value())
    elif type(x) is Rpn_Rational:
        result = Rpn_Rational.from_Fraction(Fraction(-1,1) * x.value())
    elif type(x) is Rpn_Complex:
        result = Rpn_Complex(-1.0*x.real(), -1.0*x.imag())
    else:
        param_stack.push(x)
        raise TypeError("chs: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='clflag', doc="""\
Clear all flags  ( -- )""")
def w_clflag():
    global flags_vec
    flags_vec = 0


@defword(name='clrst', doc="""\
Clear the return stack.
Do not do this inside a DO loop!""")
def w_clrst():
    return_stack.clear()


@defword(name='clst', doc="""\
Clear the stack

DEFINITION:
: clst  depth 0 do drop loop ;""")
def w_clst():
    param_stack.clear()


@defword(name='comb', args=2, doc="""\
Combinations  ( n r -- nCr )
Choose from N objects R at a time, without regard to ordering.

DEFINITION:
          n!
nCr = -----------
      r! * (n-r)!""")
def w_comb():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("comb: Type error ({}, {})".format(typename(y), typename(x)))

    # Python 3.8 has math.comb()
    n = y.value()
    r = x.value()
    result = Rpn_Integer(comb_helper(n, r))

    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='Constant', doc="""\
Declare a constant variable  ( n -- )
CONSTANT <ccc>""")
def w_constant():
    pass                        # Grammar rules handle this word


@defword(name='cos', args=1, doc="""\
Cosine  ( angle -- cosine )""")
def w_cos():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(math.cos(convert_mode_to_radians(float(x.value()))))
    elif type(x) is Rpn_Complex:
        result = Rpn_Complex.from_complex(cmath.cos(x.value()))
    else:
        param_stack.push(x)
        raise TypeError("cos: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='cr', doc="""\
Print a newline""")
def w_cr():
    writeln()


@defword(name='d->jd', args=1, doc="""\
Convert date to Julian day number ( MM.DDYYYY -- julian )""")
def w_d_to_jd():
    x = param_stack.pop()
    if type(x) is not Rpn_Float:
        param_stack.push(x)
        raise TypeError("d->jd: Type error ({})".format(typename(x)))

    (valid, dateobj, julian) = x.date_info()
    if not valid:
        param_stack.push(x)
        raise ValueError("d->jd: {} is not a valid date".format(x.value()))

    param_stack.push(Rpn_Integer(julian))
    global show_x
    show_x = True


@defword(name='d->r', args=1, doc="""\
Convert degrees to radians ( deg -- rad )""")
def w_d_to_r():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(convert_mode_to_radians(float(x.value()), "d"))
    else:
        param_stack.push(x)
        raise TypeError("d->r: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='date', doc="""\
Current date  ( -- MM.DDYYYY )""")
def w_date():
    d = datetime.date.today().strftime("%m.%d%Y")
    param_stack.push(Rpn_Float(d))
    global show_x
    show_x = True


@defword(name='dateinfo', args=1, hidden=True, doc="""\
Show date_info() for Float  ( x -- )""")
def w_dateinfo():
    x = param_stack.pop()
    if type(x) is Rpn_Float:
        print(x.date_info())
    else:
        param_stack.push(x)
        raise TypeError("dateinfo: Type error ({})".format(typename(x)))


@defword(name='date+', args=2, doc="""\
Add N days to date  ( date1 N -- date2 )""")
def w_date_plus():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Float:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("date+: Type error ({})".format(typename(y), typename(y)))

    (valid, dateobj, julian) = y.date_info()
    if not valid:
        param_stack.push(y)
        param_stack.push(x)
        raise ValueError("date+: {} is not a valid date".format(y.value()))

    new_julian = julian + x.value()
    dateobj = datetime.date.fromordinal(new_julian - julian_offset)
    result = Rpn_Float("%d.%02d%04d" % (dateobj.month, dateobj.day, dateobj.year))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='date-', args=2, doc="""\
Subtract N days from date  ( date1 N -- date2 )""")
def w_date_minus():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Float:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("date-: Type error ({})".format(typename(y), typename(y)))

    (valid, dateobj, julian) = y.date_info()
    if not valid:
        param_stack.push(y)
        param_stack.push(x)
        raise ValueError("date-: {} is not a valid date".format(y.value()))

    new_julian = julian - x.value()
    dateobj = datetime.date.fromordinal(new_julian - julian_offset)
    result = Rpn_Float("%d.%02d%04d" % (dateobj.month, dateobj.day, dateobj.year))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='ddays', args=2, doc="""\
Number of days between two dates  ( date1 date2 -- ddays )
Usually the earlier date is in Y, and later date in X.""")
def w_ddays():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Float or type(y) is not Rpn_Float:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("ddays: Type error ({})".format(typename(y), typename(y)))

    (valid, dateobj, xjulian) = x.date_info()
    if not valid:
        param_stack.push(y)
        param_stack.push(x)
        raise ValueError("ddays: {} is not a valid date".format(x.value()))

    (valid, dateobj, yjulian) = y.date_info()
    if not valid:
        param_stack.push(y)
        param_stack.push(x)
        raise ValueError("ddays: {} is not a valid date".format(y.value()))

    # Y is expected to be earlier, so we subtract in this order to get a
    # positive value for "later"
    param_stack.push(Rpn_Integer(xjulian - yjulian))
    global show_x
    show_x = True


@defword(name='debug', doc="""\
Toggle debugging state""")
def w_debug():
    global debug_enabled
    debug_enabled = not debug_enabled
    lnwriteln("debug: Debugging is now {}".format(debug_enabled))


@defword(name='deg', doc="""\
Set angular mode to degrees""")
def w_deg():
    global angle_mode
    angle_mode = "d"


@defword(name='deg?', doc="""\
Test if angular mode is degrees  ( -- flag )""")
def w_deg_query():
    global angle_mode
    param_stack.push(Rpn_Integer(1 if angle_mode == "d" else 0))
    global show_x
    show_x = True


@defword(name='depth', doc="""\
Current number of elements on stack  ( -- n )""")
def w_depth():
    param_stack.push(Rpn_Integer(param_stack.size()))
    global show_x
    show_x = True


@defword(name='dim', args=1, doc="""\
Dimension(s) of X.

For integers, floats, and rationals (scalars), return 0.
For complex numbers, return 2.
For vectors of length N, return a vector [N].
For an M-row by N-col matrix, return a vector [M N].""")
def w_dim():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Integer(0)
    elif type(x) is Rpn_Complex:
        result = Rpn_Integer(2)
    elif type(x) is Rpn_Vector:
        result = Rpn_Vector(Rpn_List(Rpn_Integer(x.size())))
    elif type(x) is Rpn_Matrix:
        # Pretty ugly.  Need a better method to append items.  Ugh,
        # things get added at the beginning of the list, so we have to
        # add the cols, THEN the rows in order to end up with
        # [ rows cols ].
        l = Rpn_List(Rpn_Integer(x.ncols()))
        l2 = Rpn_List(Rpn_Integer(x.nrows()), l)
        result = Rpn_Vector(l2) # [ rows cols ]
    else:
        param_stack.push(x)
        raise TypeError("dim: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='do', doc="""\
Execute a definite loop.
<limit> <initial> DO xxx        LOOP
<limit> <initial> DO xxx <incr> +LOOP

The iteration counter is available via I.  LEAVE will exit the loop early.

Example: 10 0 do I . loop
prints 0 1 2 3 4 5 6 7 8 9

qv I, LEAVE, LOOP, +LOOP""")
def w_do():
    pass                        # Grammar rules handle this word


@defword(name='dot', args=2, doc="""\
Vector dot product  ( vec_y vec_x -- real )""")
def w_dot_prod():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is Rpn_Vector and type(y) is Rpn_Vector:
        try:
            r = y.value().dot(x.value())
        except ValueError as e:
            param_stack.push(y)
            param_stack.push(x)
            raise ValueError("dot: Conformability error: Vectors ({} and {}) are not same size".format(y, x))

        if type(r) is np.int64:
            result = Rpn_Integer(r)
        else:
            result = Rpn_Float(r)
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("dot: Type error ({}, {})".format(typename(y), typename(x)))

    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='dow', args=1, doc="""\
Day of week  ( MM.DDYYYY -- dow )
1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat, 7=Sun""")
def w_dow():
    x = param_stack.pop()
    if type(x) is not Rpn_Float:
        param_stack.push(x)
        raise TypeError("dow: Type error ({})".format(typename(x)))

    (valid, dateobj, julian) = x.date_info()
    if not valid:
        param_stack.push(x)
        raise ValueError("dow: {} is not a valid date".format(x.value()))

    param_stack.push(Rpn_Integer(dateobj.isoweekday()))
    global show_x
    show_x = True


@defword(name='drop', args=1, doc="""\
Remove top stack element  ( x -- )""")
def w_drop():
    param_stack.pop()


@defword(name='dup', args=1, doc="""\
Duplicate top stack element  ( x -- x x )
Equivalent to 0 PICK""")
def w_dup():
    x = param_stack.pop()
    param_stack.push(x)
    param_stack.push(x)


@defword(name='E', doc="""\
Constant: Base of natural logarithms ( -- 2.71828... )""")
def w_E():
    param_stack.push(Rpn_Float(E))
    global show_x
    show_x = True


@defword(name='else', args=1, doc="""\
Execute a conditional test.  xxx is executed if <flag> is non-zero,
otherwise yyy is executed.
<flag> IF xxx [ ELSE yyy ] THEN

qv IF, THEN""")
def w_else():
    pass                        # Grammar rules handle this word


@defword(name='emit', args=1, doc="""\
emit  ( x -- )    Print a single ASCII character
No space or newline is appended.""")
def w_emit():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise TypeError("emit: Type error ({})".format(typename(x)))
    write(chr(x.value()))


@defword(name='end', doc="""\
Set "End" financial mode.""")
def w_end():
    global_scope.variable('BEG').set_obj(Rpn_Integer(0))


@defword(name='endcase', doc="""\
Execute a sequence of words based on stack value.  Once a match is
executed, no other clauses are considered.  OTHERWISE is optional.
<n> and OF labels must be integers.

<n> CASE
  <x> OF xxx ENDOF
  <y> OF yyy ENDOF
  <z> OF zzz ENDOF
  [ OTHERWISE aaa ]
ENDCASE

qv CASE, ENDOF, OF, OTHERWISE
""")
def w_endcase():
    pass                        # Grammar rules handle this word


@defword(name='endof', doc="""\
Execute a sequence of words based on stack value.  Once a match is
executed, no other clauses are considered.  OTHERWISE is optional.
<n> and OF labels must be integers.

<n> CASE
  <x> OF xxx ENDOF
  <y> OF yyy ENDOF
  <z> OF zzz ENDOF
  [ OTHERWISE aaa ]
ENDCASE

qv CASE, ENDCASE, OF, OTHERWISE
""")
def w_endof():
    pass                        # Grammar rules handle this word


@defword(name='epoch', doc="""\
Seconds since epoch  ( -- secs )""")
def w_epoch():
    now = calendar.timegm(time.gmtime())
    param_stack.push(Rpn_Integer(now))


@defword(name='eval', str_args=1)
def w_eval():
    s = string_stack.pop().value()
    eval_string(s)


@defword(name='exit', doc="""\
Terminate execution of current word""")
def w_exit():
    raise Rpn_E_Exit()


@defword(name='exp', args=1, doc="""\
Natural exponential ( x -- e^x )""")
def w_exp():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(math.exp(float(x.value())))
    elif type(x) is Rpn_Complex:
        result = Rpn_Complex.from_complex(cmath.exp(complex(x.value())))
    else:
        param_stack.push(x)
        raise TypeError("exp: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='fact', args=1, doc="""\
Factorial ( x -- x! )

DEFINITION:
x! = x * (x-1) * (x-2) ... * 2 * 1
0! = 1
X cannot be negative.""")
def w_fact():
    x = param_stack.pop()
    if type(x) is Rpn_Integer:
        if x.value() < 0:
            param_stack.push(x)
            raise ValueError("fact: X cannot be negative")
        result = Rpn_Integer(fact_helper(x.value()))
    else:
        param_stack.push(x)
        raise TypeError("fact: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='FALSE')
def w_FALSE():
    param_stack.push(Rpn_Integer(0))
    global show_x
    show_x = True


@defword(name='fc?', args=1)
def w_fc_query():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise TypeError("fc?: Type error ({})".format(typename(x)))

    if x.value() < 0 or x.value() > flag_max - 1:
        param_stack.push(x)
        raise ValueError("fc?: Flag out of range (0..{} expected)".format(flag_max - 1))
    result = Rpn_Integer(0 if flag_test(x.value()) else 1)
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='floor', doc="""\
Floor  ( x -- floor )   Largest integer not greater than X""")
def w_floor():
    x = param_stack.pop()
    if type(x) is Rpn_Integer:
        result = x
    elif type(x) in [Rpn_Float, Rpn_Rational]:
        result = Rpn_Integer(math.floor(x.value()))
    else:
        param_stack.push(x)
        raise TypeError("floor: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='forget', doc="""\
Forget the definition of the following word.""")
def w_forget():
    pass                        # Grammar rules handle this word


@defword(name='fs?', args=1)
def w_fs_query():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise TypeError("fs?: Type error ({})".format(typename(x)))

    if x.value() < 0 or x.value() > flag_max - 1:
        param_stack.push(x)
        raise ValueError("fs?: Flag out of range (0..{} expected)".format(flag_max - 1))
    result = Rpn_Integer(1 if flag_test(x.value()) else 0)
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='grad', doc="""\
Set angular mode to gradians""")
def w_grad():
    global angle_mode
    angle_mode = "g"


@defword(name='grad?', doc="""\
Test if angular mode is gradians  ( -- flag )""")
def w_grad_query():
    global angle_mode
    param_stack.push(Rpn_Integer(1 if angle_mode == "g" else 0))
    global show_x
    show_x = True


@defword(name='hms', args=1, doc="""\
Convert decimal hours to hours/minutes/seconds  ( HH.nnn -- HH.MMSS )""")
def w_hms():
    x = param_stack.pop()
    if type(x) is Rpn_Integer:
        result = Rpn_Float(x.value())
    elif type(x) in [Rpn_Float, Rpn_Rational]:
        negative = x.value() < 0
        hr = abs(x.value())
        (minutes, seconds) = divmod(hr * 3600, 60)
        (hours, minutes)   = divmod(minutes, 60)
        if negative:
            hours *= -1.0
        result = Rpn_Float("%d.%02d%02d" % (hours, minutes, seconds))
    else:
        param_stack.push(x)
        raise TypeError("hms: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='hms+', args=2, doc="""\
Add hours/minutes/seconds  ( HH.MMSS HH.MMSS -- HH.MMSS )""")
def w_hms_plus():
    x = param_stack.pop()
    y = param_stack.pop()
    if    type(x) not in [Rpn_Integer, Rpn_Float] \
       or type(y) not in [Rpn_Integer, Rpn_Float]:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("hms+: Type error ({}, {})".format(typename(y), typename(x)))

    ynegative = y.value() < 0
    if type(y) is Rpn_Integer:
        (yvalid, yhh, ymm, yss, _) = Rpn_Float(y.value()).time_info()
    else:
        (yvalid, yhh, ymm, yss, _) = y.time_info()
    if not yvalid:
        param_stack.push(y)
        param_stack.push(x)
        raise ValueError("hms+: Time {} is not valid".format(y.value()))

    xnegative = y.value() < 0
    if type(x) is Rpn_Integer:
        (xvalid, xhh, xmm, xss, _) = Rpn_Float(x.value()).time_info()
    else:
        (xvalid, xhh, xmm, xss, _) = x.time_info()
    if not xvalid:
        param_stack.push(y)
        param_stack.push(x)
        raise ValueError("hms+: Time {} is not valid".format(x.value()))

    (hh, mm, ss) = normalize_hms(yhh + xhh, ymm + xmm, yss + xss)
    #print("hh=",hh,"mm=",mm,"ss=",ss)
    result = Rpn_Float("%d.%02d%02d" % (hh, mm, ss))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='hms-', args=2, doc="""\
Subtract hours/minutes/seconds  ( HH.MMSS HH.MMSS -- HH.MMSS )""")
def w_hms_minus():
    x = param_stack.pop()
    y = param_stack.pop()
    if    type(x) not in [Rpn_Integer, Rpn_Float] \
       or type(y) not in [Rpn_Integer, Rpn_Float]:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("hms-: Type error ({}, {})".format(typename(y), typename(x)))

    if type(y) is Rpn_Integer:
        (yvalid, yhh, ymm, yss, _) = Rpn_Float(y.value()).time_info()
    else:
        (yvalid, yhh, ymm, yss, _) = y.time_info()
    if not yvalid:
        param_stack.push(y)
        param_stack.push(x)
        raise ValueError("hms-: Time {} is not valid".format(y.value()))

    if type(x) is Rpn_Integer:
        (xvalid, xhh, xmm, xss, _) = Rpn_Float(x.value()).time_info()
    else:
        (xvalid, xhh, xmm, xss, _) = x.time_info()
    if not xvalid:
        param_stack.push(y)
        param_stack.push(x)
        raise ValueError("hms-: Time {} is not valid".format(x.value()))

    (hh, mm, ss) = normalize_hms(yhh - xhh, ymm - xmm, yss - xss)
    #print("hh=",hh,"mm=",mm,"ss=",ss)
    result = Rpn_Float("%d.%02d%02d" % (hh, mm, ss))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='hr', args=1, doc="""\
Convert hours/minutes/seconds to decimal hours  ( HH.MMSS -- HH.nnn )""")
def w_hr():
    x = param_stack.pop()
    if type(x) is Rpn_Integer:
        result = Rpn_Float(x.value())
    elif type(x) in [Rpn_Float, Rpn_Rational]:
        negative = -1.0 if x.value() < 0 else 1.0
        hms = Rpn_Float(abs(float(x.value()) if type(x) is Rpn_Rational else x.value()))
        (valid, hh, mm, ss, _) = hms.time_info()
        if not valid:
            param_stack.push(x)
            raise ValueError("hr: Time {} is not valid".format(x.value()))

        hr = float(hh) + float(mm)/60.0 + float(ss)/3600.0
        result = Rpn_Float(negative * hr)
    else:
        param_stack.push(x)
        raise TypeError("hr: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='i', doc="""\
Imaginary unit (0,1)  ( -- i )

DEFINITION:
i = sqrt(-1)

Do not confuse this with the I command, which returns the index for a DO loop.""")
def w_i():
    param_stack.push(Rpn_Complex(0,1))
    global show_x
    show_x = True


@defword(name='I', doc="""\
Index of DO loop  ( -- x )

Return the index of the most recent DO loop.

Do not confuse this with the i command, which returns the complex number (0,1).""")
def w_I():
    (_I, _) = lookup_variable('_I')
    if _I is None:
        raise RuntimeError("'I' not valid here, only in DO loops")
    elif type(_I.obj()) is not Rpn_Integer:
        raise FatalError("I is not an Rpn_Integer")
    else:
        param_stack.push(_I.obj())


@defword(name='idn', args=1, doc="""\
Create an NxN identity matrix  ( n -- mat )""")
def w_idn():
    x = param_stack.pop()
    size = 0
    if type(x) is Rpn_Integer:
        size = x.value()
        if size < 1 or size > matrix_max:
            param_stack.push(x)
            raise ValueError("idn: X out of range (1..{} expected)".format(matrix_max))
    elif type(x) is Rpn_Vector:
        vsize = x.size()
        if vsize != 2:
            param_stack.push(x)
            raise ValueError("idn: Only matrices can be created")
        if int(x.value()[0]) != int(x.value()[1]):
            param_stack.push(x)
            raise ValueError("idn: Only square matrices can be created")
        size = x.value()[0]
    else:
        param_stack.push(x)
        raise TypeError("idn: Type error ({})".format(typename(x)))


    result = Rpn_Matrix.from_numpy(np.identity(size, dtype=np.int64))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='if', args=1, doc="""\
Test condition  ( flag -- )
Execute a conditional test.  xxx is executed if <flag> is non-zero.
<flag> IF xxx [ ELSE yyy ] THEN

qv ELSE, THEN""")
def w_if():
    pass                        # Grammar rules handle this word


@defword(name='jd->d', args=1, doc="""\
Convert julian day number to date  ( julian -- MM.DDYYYY )

EXAMPLE:
2369915 jd->d  ==>  7.041776""")
def w_jd_to_d():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise TypeError("jd->d: Type error ({})".format(typename(x)))

    if x.value() < 1 or x.value() > datetime.date.max.toordinal():
        param_stack.push(x)
        raise ValueError("jd->d: X out of range (1..{} expected)".format(date.max.toordinal()))

    dateobj = datetime.date.fromordinal(x.value() - julian_offset)
    result = Rpn_Float("%d.%02d%04d" % (dateobj.month, dateobj.day, dateobj.year))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='inv', args=1, doc="""\
Inverse  ( x -- 1/x )
X cannot be zero.""")
def w_inv():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
       and x.zerop():
        param_stack.push(x)
        raise ValueError("inv: X cannot be zero")

    if type(x) is Rpn_Integer:
        result = Rpn_Float(1.0 / float(x.value()))
    elif type(x) is Rpn_Rational:
        result = Rpn_Rational(x.denominator(), x.numerator())
    elif type(x) is Rpn_Float:
        result = Rpn_Float(1.0 / x.value())
    elif type(x) is Rpn_Complex:
        r = complex(1,0) / x.value()
        result = Rpn_Complex.from_complex(r)
    # elif type(x) is Rpn_Vector:
    #     # Vectors are not invertible
    # elif type(x) is Rpn_Matrix:
    #     # Numpy can do this; either
    #     # m = np.matrix([[],[]])
    #     # m.I
    #     # -or
    #     # b = np.array([[],[]])
    #     # np.linalg.inv(b)
    #     # And remember that not every matrix is invertible (singular ones)
    else:
        param_stack.push(x)
        raise TypeError("inv: Type error ({})".format(typename(x)))

    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='key', doc="""\
ASCII code of single keystroke  ( -- key )
KEY will block until input is provided.""")
def w_key():
    k = _Getch()()
    val = ord(k) if k != '' else 0
    #lnwriteln("You pressed <{}>, value={}".format(k, val))
    param_stack.push(Rpn_Integer(val))


@defword(name='leave', doc="""\
Exit a DO or BEGIN loop immediately.""")
def w_leave():
    raise Rpn_E_Leave


@defword(name='lg', args=1, doc="""\
Logarithm [base 2]  ( x -- lg )
X cannot be zero.
Use "ln" for the natural logarithm, and "log" for the common logarithm.""")
def w_lg():
    x = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
       and x.zerop():
        param_stack.push(x)
        raise ValueError("lg: X cannot be zero")

    if    type(x) is Rpn_Integer  and x.value() > 0 \
       or type(x) is Rpn_Float    and x.value() > 0.0 \
       or type(x) is Rpn_Rational and x.value() > 0:
        r = Rpn_Float(math.log2(float(x.value())))
        if type(x) is Rpn_Integer and r.is_integer():
            result = Rpn_Integer(r)
        else:
            result = Rpn_Float(r)
    elif    type(x) is Rpn_Complex \
         or type(x) is Rpn_Integer  and x.value() < 0 \
         or type(x) is Rpn_Float    and x.value() < 0.0 \
         or type(x) is Rpn_Rational and x.value() < 0:
        result = Rpn_Complex.from_complex(cmath.log(complex(x.value()), 2))
    else:
        param_stack.push(x)
        raise TypeError("lg: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='ln', args=1, doc="""\
Natural logarithm [base e]  ( x -- ln )
X cannot be zero.
Use "log" for the common (base 10) logarithm.""")
def w_ln():
    x = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
       and x.zerop():
        param_stack.push(x)
        raise ValueError("ln: X cannot be zero")

    if    type(x) is Rpn_Integer  and x.value() > 0 \
       or type(x) is Rpn_Float    and x.value() > 0.0 \
       or type(x) is Rpn_Rational and x.value() > 0:
        result = Rpn_Float(math.log(float(x.value())))
    elif    type(x) is Rpn_Complex \
         or type(x) is Rpn_Integer  and x.value() < 0 \
         or type(x) is Rpn_Float    and x.value() < 0.0 \
         or type(x) is Rpn_Rational and x.value() < 0:
        result = Rpn_Complex.from_complex(cmath.log(complex(x.value())))
    else:
        param_stack.push(x)
        raise TypeError("ln: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='load', str_args=1, doc="""\
Load file specified on string stack  [ file -- ]""")
def w_load():
    filename = string_stack.pop().value()
    if not os.path.isfile(filename):
        lnwriteln("load: Invalid file '{}'".format(filename))
    else:
        load_file(filename)


@defword(name='log', args=1, doc="""\
Common logarithm [base 10]  ( x -- log )
X cannot be zero.
Use "ln" for the natural (base e) logarithm.""")
def w_log():
    x = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
       and x.zerop():
        param_stack.push(x)
        raise ValueError("log: X cannot be zero")

    if    type(x) is Rpn_Integer  and x.value() > 0 \
       or type(x) is Rpn_Float    and x.value() > 0.0 \
       or type(x) is Rpn_Rational and x.value() > 0:
        r = math.log10(float(x.value()))
        if type(x) is Rpn_Integer and r.is_integer():
            result = Rpn_Integer(r)
        else:
            result = Rpn_Float(r)
    elif    type(x) is Rpn_Complex \
         or type(x) is Rpn_Integer  and x.value() < 0 \
         or type(x) is Rpn_Float    and x.value() < 0.0 \
         or type(x) is Rpn_Rational and x.value() < 0:
        result = Rpn_Complex.from_complex(cmath.log10(complex(x.value())))
    else:
        param_stack.push(x)
        raise TypeError("log: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='loop', doc="""\
Execute a definite loop.
<limit> <initial> DO xxx LOOP

The iteration counter is available via I.  LEAVE will exit the loop early.

Example: 10 0 do I . loop
prints 0 1 2 3 4 5 6 7 8 9

qv DO, I, LEAVE, +LOOP""")
def w_loop():
    pass                        # Grammar rules handle this word


@defword(name='max', args=2, doc="""\
Smaller of X or Y  ( y x -- max )""")
def w_max():
    x = param_stack.pop()
    y = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       and type(y) in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        yval = float(y.value())
        xval = float(x.value())
        param_stack.push(x if xval > yval else y)
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("max: Type error ({}, {})".format(typename(y), typename(x)))
    global show_x
    show_x = True


@defword(name='min', args=2, doc="""\
Smaller of X or Y  ( y x -- min )""")
def w_min():
    x = param_stack.pop()
    y = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       and type(y) in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        yval = float(y.value())
        xval = float(x.value())
        param_stack.push(x if xval < yval else y)
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("min: Type error ({}, {})".format(typename(y), typename(x)))
    global show_x
    show_x = True


@defword(name='nip', args=2, doc="""\
Drop second stack element  ( y x -- x )
Equivalent to SWAP DROP.  J.V. Noble calls this PLUCK.""")
def w_nip():
    x = param_stack.pop()
    y = param_stack.pop()
    param_stack.push(x)


@defword(name='not', args=1, doc="""\
Logical not  ( flag -- !flag )

Invert a flag - return TRUE (1) if x is zero, otherwise FALSE (0).
NOT is intended for boolean manipulations and is only defined on truth
integers (0,1).  0= is meant to compare a number to zero, and works for
all number types.

NOTE: This is not a bitwise not - use BITNOT for that.""")
def w_not():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise TypeError("not: Type error ({})".format(typename(x)))
    if x.value() not in [0, 1]:
        param_stack.push(x)
        raise ValueError("not: X must be TRUE (1) or FALSE (0), not {}".format(x.value()))

    param_stack.push(Rpn_Integer(1 if x.zerop() else 0))
    global show_x
    show_x = True


@defword(name='of', doc="""\
Execute a sequence of words based on stack value.  Once a match is
executed, no other clauses are considered.  OTHERWISE is optional.
<n> and OF labels must be integers.

<n> CASE
  <x> OF xxx ENDOF
  <y> OF yyy ENDOF
  <z> OF zzz ENDOF
  [ OTHERWISE aaa ]
ENDCASE

qv CASE, ENDCASE, ENDOF, OTHERWISE
""")
def w_of():
    pass                        # Grammar rules handle this word


@defword(name='or', args=2, doc="""\
Logical OR  ( flag flag -- flag )
NOTE: This is not a bitwise OR - use BITOR for that.""")
def w_or():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("or: Type error ({})".format(typename(y), typename(y)))

    if x.value() not in [0, 1]:
        param_stack.push(y)
        param_stack.push(x)
        raise ValueError("or: X must be TRUE (1) or FALSE (0), not {}".format(x.value()))
    if y.value() not in [0, 1]:
        param_stack.push(y)
        param_stack.push(x)
        raise ValueError("or: Y must be TRUE (1) or FALSE (0), not {}".format(y.value()))

    param_stack.push(Rpn_Integer(x.value() or y.value()))
    global show_x
    show_x = True


@defword(name='otherwise',  doc="""\
Execute a sequence of words based on stack value.  Once a match is
executed, no other clauses are considered.  OTHERWISE is optional.
<n> and OF labels must be integers.

<n> CASE
  <x> OF xxx ENDOF
  <y> OF yyy ENDOF
  <z> OF zzz ENDOF
  [ OTHERWISE aaa ]
ENDCASE

qv CASE, ENDCASE, ENDOF, OF
""")
def w_otherwise():
    pass                        # Grammar rules handle this word


@defword(name='over', args=2, doc="""\
Duplicate second stack element  ( y x -- y x y )
Equivalent to 1 PICK""")
def w_over():
    x = param_stack.pop()
    y = param_stack.pop()
    param_stack.push(y)
    param_stack.push(x)
    param_stack.push(y)


@defword(name='p->r', doc="""\
Convert polar coordinates to rectangular.
The parameters can be either two reals or one complex.

Real:      ( phi r -- y x )
Complex:   ( cp -- cr )
  cp : (r, phi)
  cr : (x, y)

DEFINITION:
x = r * cos(phi)
y = r * sin(phi)""")
def w_p_to_r():
    if param_stack.empty():
        raise RuntimeError("p->r: Insufficient parameters (1 or 2 required)")
    x = param_stack.pop()
    if type(x) is Rpn_Complex:
        r   = x.real()
        phi = convert_mode_to_radians(x.imag())
        result = Rpn_Complex.from_complex(cmath.rect(r, phi))
        param_stack.push(result)
    elif type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        if param_stack.empty():
            param_stack.push(x)
            raise RuntimeError("p->r: Insufficient parameters (2 required)")
        y = param_stack.pop()
        if type(y) not in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
            param_stack.push(y)
            param_stack.push(x)
            raise TypeError("p->r: Type error({}, {})".format(typename(y), typename(x)))
        r   = float(x.value())
        phi = convert_mode_to_radians(float(y.value()))
        xval = r * math.cos(phi)
        yval = r * math.sin(phi)
        param_stack.push(Rpn_Float(yval))
        param_stack.push(Rpn_Float(xval))
    else:
        param_stack.push(x)
        raise TypeError("p->r: Type error({})".format(typename(x)))
    global show_x
    show_x = True


@defword(name='perm', args=2, doc="""\
Permutations  ( n r -- nPr )
Choose from N objects R at a time, with regard to ordering.

DEFINITION:
        n!
nPr = ------
      (n-r)!""")
def w_perm():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(y) is not Rpn_Integer or type(x) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("perm: Type error ({}, {})".format(typename(y), typename(x)))

    # Python 3.8 has math.perm()
    n = y.value()
    r = x.value()
    if r > n or r < 0:
        result = Rpn_Integer(0)
    else:
        t = 1
        while r > 0:
            r -= 1
            t *= n
            n -= 1
        result = Rpn_Integer(t)

    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='PI', doc="""\
Constant: Pi ( -- 3.14159... )

DEFINITION:
PI == TAU/2

Consider using TAU instead of PI to simplify your equations.""")
def w_PI():
    param_stack.push(Rpn_Float(PI))
    global show_x
    show_x = True


@defword(name='pick', args=1, doc="""\
Pick an element from the stack  ( x -- )
0 PICK ==> DUP, 1 PICK ==> OVER""")
def w_pick():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise TypeError("pick: Type error ({})".format(typename(x)))

    if x.value() < 0 or x.value() >= param_stack.size():
        param_stack.push(x)
        raise ValueError("pick: Index out of range (0..{} expected)".format(param_stack.size()-2))

    result = param_stack.pick(x.value())
    param_stack.push(result)


@defword(name='r->d', args=1, doc="""\
Convert radians to degrees ( rad -- deg )""")
def w_r_to_d():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(convert_radians_to_mode(float(x.value()), "d"))
    else:
        param_stack.push(x)
        raise TypeError("r->d: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='r->p', doc="""\
Convert rectangular coordinates to polar.
The parameters can be either two reals, or one complex.

Real:      ( y x -- phi r )
Complex:   ( cr -- cp )
  cr : (x, y)
  cp : (r, phi)

DEFINITION:
r   = hypot(x, y) == sqrt(x^2 + y^2)
phi = atan2(x, y)""")
def w_r_to_p():
    if param_stack.empty():
        raise RuntimeError("r->p: Insufficient parameters (1 or 2 required)")
    x = param_stack.pop()
    if type(x) is Rpn_Complex:
        (r, phi) = cmath.polar(x.value())
        result = Rpn_Complex(r, convert_radians_to_mode(phi))
        param_stack.push(result)
    elif type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        if param_stack.empty():
            param_stack.push(x)
            raise RuntimeError("r->p: Insufficient parameters (2 required)")
        y = param_stack.pop()
        if type(y) not in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
            param_stack.push(y)
            param_stack.push(x)
            raise TypeError("r->p: Type error({}, {})".format(typename(y), typename(x)))

        phi = math.atan2(x.value(), y.value())
        r   = math.hypot(x.value(), y.value())
        param_stack.push(Rpn_Float(convert_radians_to_mode(phi)))
        param_stack.push(Rpn_Float(r))
    else:
        param_stack.push(x)
        raise TypeError("r->p: Type error({})".format(typename(x)))
    global show_x
    show_x = True


@defword(name='r.s', doc="""\
Display return stack""")
def w_r_dot_s():
    for (i, item) in return_stack.items_bottom_to_top():
        # Prefix with "r" to prevent confusion with .s
        lnwriteln("r{}: {}".format(i, item))
    global show_x
    show_x = False


@defword(name='r>', doc="""\
Pop return stack onto parameter stack  ( -- x )""")
def w_r_from():
    if return_stack.empty():
        raise RuntimeError("r>: Empty return stack")
    param_stack.push(return_stack.pop())


@defword(name='r@', doc="""\
Copy top of return stack  ( -- x )""")
def w_r_fetch():
    if return_stack.empty():
        raise RuntimeError("r@: Empty return stack")
    param_stack.push(return_stack.top())


@defword(name='rad', doc="""\
Set angular mode to radians""")
def w_rad():
    global angle_mode
    angle_mode = "r"


@defword(name='rad?', doc="""\
Test if angular mode is radians  ( -- flag )""")
def w_rad_query():
    global angle_mode
    param_stack.push(Rpn_Integer(1 if angle_mode == "r" else 0))
    global show_x
    show_x = True


@defword(name='rand', doc="""\
Random number  ( -- n )
0 <= n < 1""")
def w_rand():
    param_stack.push(Rpn_Float(random.random()))
    global show_x
    show_x = True


@defword(name='rdepth', doc="""\
Current number of elements on return stack  ( -- n )""")
def w_rdepth():
    param_stack.push(Rpn_Integer(return_stack.size()))
    global show_x
    show_x = True


@defword(name='repeat', doc="""\
Execute an indefinite loop while a condition is satisfied.
BEGIN xxx <flag> WHILE yyy REPEAT

LEAVE will exit the loop early.  Note that the effect of the test in
BEGIN...WHILE is opposite that in BEGIN...UNTIL.  The loop repeats
while something is true, rather than until it becomes true.

qv BEGIN, AGAIN, LEAVE, UNTIL, WHILE""")
def w_repeat():
    pass                        # Grammar rules handle this word


@defword(name='roll', args=1, doc="""\
Roll stack elements  ( x -- )
1 ROLL ==> SWAP, 2 ROLL ==> ROT""")
def w_roll():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise TypeError("roll: Type error ({})".format(typename(x)))

    if x.value() < 0 or x.value() >= param_stack.size():
        param_stack.push(x)
        raise ValueError("roll: Index out of range (0..{} expected)".format(param_stack.size()-2))

    param_stack.roll(x.value())


@defword(name='rot', args=3, doc="""\
Rotate third stack element to the top, rolling others up  ( z y x -- y x z )
Equivalent to 2 ROLL""")
def w_rot():
    x = param_stack.pop()
    y = param_stack.pop()
    z = param_stack.pop()
    param_stack.push(y)
    param_stack.push(x)
    param_stack.push(z)


@defword(name='scopes')
def w_scopes():
    for (i, item) in scope_stack.items_bottom_to_top():
        lnwriteln("{}: {}".format(i, item))


@defword(name='setdebug', args=1, str_args=1)
def w_setdebug():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise TypeError("setdebug: Type error ({})".format(typename(x)))
    level = x.value()
    if level < 0 or level > 9:
        param_stack.push(x)
        raise ValueError("setdebug: Level {} out of range (0..9 expected)".format(level))
    resource = string_stack.pop().value()
    set_debug(resource, level)


@defword(name='sf', args=1)
def w_sf():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise TypeError("sf: Type error ({})".format(typename(x)))
    flag = x.value()
    if flag < 0 or flag > flag_max - 1:
        param_stack.push(x)
        raise ValueError("sf: Flag {} out of range (0..{} expected)".format(flag, flag_max - 1))
    flag_set(flag)


@defword(name='shfin', doc="""\
Show financial variables""")
def w_shfin():
    N   = global_scope.variable('N')
    IYR = global_scope.variable('I%YR')
    PV  = global_scope.variable('PV')
    PMT = global_scope.variable('PMT')
    FV  = global_scope.variable('FV')
    BEG = global_scope.variable('BEG')
    PYR = global_scope.variable('P/YR')

    writeln("N:    {}".format(N  .obj().value() if N  .defined() else "Not set"))
    writeln("I%YR: {}".format(IYR.obj().value() if IYR.defined() else "Not set"))
    writeln("PV:   {}".format(PV .obj().value() if PV .defined() else "Not set"))
    writeln("PMT:  {}".format(PMT.obj().value() if PMT.defined() else "Not set"))
    writeln("FV:   {}".format(FV .obj().value() if FV .defined() else "Not set"))
    writeln("P/YR: {}".format(PYR.obj().value() if PYR.defined() else "Not set"))
    writeln("Mode: {}".format("BEGIN" if BEG.obj().value() == 1  else "END"))


@defword(name='shflag', doc="""\
Show status of all flags ( -- )""")
def w_shflag():
    flags = []
    for f in range(flag_max):
        flags.append("%02d:%s" % (f, "YES" if flag_test(f) else "no "))

    columns = global_scope.variable('COLS').obj().value()
    list_in_columns(flags, columns - 1)


@defword(name='show', doc="""\
Show the definition of the following word.""")
def w_show():
    pass                        # Grammar rules handle this word


@defword(name='showdebug')
def w_showdebug():
    columns = global_scope.variable('COLS').obj().value()
    dbgs = dict()

    for (resource, level) in debug_levels.items():
        dbgs[resource] = "{}={}".format(resource, level)
    sorted_dbgs = []
    for key in sorted(dbgs, key=str.casefold):
        sorted_dbgs.append(dbgs[key])
    list_in_columns(sorted_dbgs, columns - 1)

    global show_x
    show_x = False

@defword(name='sign', args=1, doc="""\
Signum  ( n -- sign )
Returns -1, 0, or 1.""")
def w_sign():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        if x.value() < 0:
            r = -1
        elif x.value() > 0:
            r = +1
        else:
            r = 0
        result = Rpn_Integer(r)
    else:
        param_stack.push(x)
        raise TypeError("sign: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='sin', args=1, doc="""\
Sine  ( angle -- sine )""")
def w_sin():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(math.sin(convert_mode_to_radians(float(x.value()))))
    elif type(x) is Rpn_Complex:
        result = Rpn_Complex.from_complex(cmath.sin(x.value()))
    else:
        param_stack.push(x)
        raise TypeError("sin: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='sleep', args=1, doc="""\
Sleep for N seconds  ( n -- )
N may be fractional.""")
def w_sleep():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        sleep_time = float(x.value())
        time.sleep(sleep_time)
    else:
        param_stack.push(x)
        raise TypeError("sleep: Type error ({})".format(typename(x)))


@defword(name='sq', args=1, doc="""\
Square  ( x -- x^2 )""")
def w_sq():
    x = param_stack.pop()
    if type(x) is Rpn_Integer:
        result = Rpn_Integer(x.value() ** 2)
    elif type(x) is Rpn_Rational:
        result = Rpn_Rational(x.numerator() ** 2, x.denominator() ** 2)
    elif type(x) is Rpn_Float:
        result = Rpn_Float(x.value() ** 2)
    elif type(x) is Rpn_Complex:
        r = complex(x.value() ** 2)
        result = Rpn_Complex.from_complex(r)
    else:
        param_stack.push(x)
        raise TypeError("sq: Type error ({})".format(typename(x)))

    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='sqrt', args=1, doc="""\
Square root  ( x -- sqrt(x) )
Negative X returns a complex number""")
def w_sqrt():
    x = param_stack.pop()
    if type(x) is Rpn_Integer and x.zerop():
        result = Rpn_Integer(0)
    elif type(x) in [Rpn_Float, Rpn_Rational] and x.zerop():
        result = Rpn_Float(0.0)
    elif type(x) is Rpn_Complex and x.zerop():
        result = Rpn_Complex()
    elif    type(x) is Rpn_Integer  and x.value() > 0 \
         or type(x) is Rpn_Float    and x.value() > 0.0 \
         or type(x) is Rpn_Rational and x.value() > 0:
        r = math.sqrt(float(x.value()))
        if type(x) is Rpn_Integer and r.is_integer():
            result = Rpn_Integer(r)
        else:
            result = Rpn_Float(r)
    elif    type(x) is Rpn_Complex \
         or type(x) is Rpn_Integer  and x.value() < 0 \
         or type(x) is Rpn_Float    and x.value() < 0.0 \
         or type(x) is Rpn_Rational and x.value() < 0:
        result = Rpn_Complex.from_complex(cmath.sqrt(complex(x.value())))
    else:
        param_stack.push(x)
        raise TypeError("sqrt: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='swap', args=2, doc="""\
Exchange top two stack elements  ( y x -- x y )
Equivalent to 1 ROLL""")
def w_swap():
    x = param_stack.pop()
    y = param_stack.pop()
    param_stack.push(x)
    param_stack.push(y)


@defword(name='tan', doc="""\
Tangent  ( angle -- tangent )""")
def w_tan():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        angle = convert_mode_to_radians(x.value())
        result = Rpn_Float(math.tan(angle))
    elif type(x) is Rpn_Complex:
        result = Rpn_Complex.from_complex(cmath.tan(x.value()))
    else:
        param_stack.push(x)
        raise TypeError("tan: Type error ({})".format(typename(x)))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='TAU', doc="""\
Constant: Tau ( -- 6.28318... )

DEFINITION:
Number of radians in a circle.""")
def w_TAU():
    param_stack.push(Rpn_Float(TAU))
    global show_x
    show_x = True


@defword(name='then', args=1, doc="""\
Execute a conditional test.  xxx is executed if <flag> is non-zero.
<flag> IF xxx [ ELSE yyy ] THEN

qv ELSE, IF""")
def w_then():
    pass                        # Grammar rules handle this word


@defword(name='time', doc="""\
Current time  ( -- HH.MMSS )""")
def w_time():
    t = datetime.datetime.now().strftime("%H.%M%S")
    param_stack.push(Rpn_Float(t))
    global show_x
    show_x = True


@defword(name='time!', doc="""\
High precision clock time  ( -- HH.MMSSssss )""")
def w_time_bang():
    t = datetime.datetime.now().strftime("%H.%M%S%f")
    param_stack.push(Rpn_Float(t))
    global show_x
    show_x = True


@defword(name='timeinfo', args=1, hidden=True, doc="""\
Show time_info() for Float  ( x -- )""")
def w_timeinfo():
    x = param_stack.pop()
    if type(x) is Rpn_Float:
        print(x.time_info())
    else:
        param_stack.push(x)
        raise TypeError("timeinfo: Type error ({})".format(typename(x)))


@defword(name='TRUE')
def w_TRUE():
    param_stack.push(Rpn_Integer(1))
    global show_x
    show_x = True


@defword(name='tuck', args=2, doc="""\
Duplicate top stack element into third position  ( y x -- x y x )
Equivalent to SWAP OVER.  J.V. Noble calls this UNDER.""")
def w_tuck():
    x = param_stack.pop()
    y = param_stack.pop()
    param_stack.push(x)
    param_stack.push(y)
    param_stack.push(x)


@defword(name='undef', doc="""\
Undefine a variable, removing it from the current scope.
UNDEF <var>""")

def w_undef():
    pass                        # Grammar rules handle this word


@defword(name='until', doc="""\
Execute an indefinite loop until a condition is satisfied.
BEGIN xxx <flag> UNTIL

LEAVE will exit the loop early.  Note that the effect of the test in
BEGIN...WHILE is opposite that in BEGIN...UNTIL.  The loop repeats
while something is true, rather than until it becomes true.

qv AGAIN, BEGIN, LEAVE, REPEAT, WHILE""")
def w_until():
    pass                        # Grammar rules handle this word


@defword(name='variable', doc="""\
Declare a variable.  Initial state is undefined.
VARIABLE <var>""")
def w_variable():
    pass                        # Grammar rules handle this word


@defword(name='vars', doc="""\
List variables and their values""")
def w_vars():
    columns = global_scope.variable('COLS').obj().value()
    for (i, scope) in scope_stack.items_top_to_bottom():
        if scope_stack.size() > 1:
            lnwriteln("Scope {}".format(scope.name()))
        vars = dict()
        for varname in scope.variables():
            var = scope.variable(varname)
            if var.hidden():
                continue
            vars[var.name()] = "{} [undef]".format(var.name()) if not var.defined() else \
                               "{}={}".format(var.name(), var.obj().value())
        sorted_vars = []
        for key in sorted(vars, key=str.casefold):
            sorted_vars.append(vars[key])
        list_in_columns(sorted_vars, columns - 1)

    global show_x
    show_x = False


@defword(name='ver', doc="""\
Display the current RPN version.
Also available as @VER""")
def w_ver():
    lnwriteln("RPN version {}".format(global_scope.variable('VER').obj().value()))


@defword(name='vlist', doc="""\
Print the list of defined words.
Only words in the global scope are shown.""")
def w_vlist():
    words = dict()
    for wordname in global_scope.words():
        word = global_scope.word(wordname)
        if word.hidden():
            continue
        words[word.name()] = word.name()
    sorted_words = []
    for key in sorted(words, key=str.casefold):
        sorted_words.append(words[key])
    columns = global_scope.variable('COLS').obj().value()
    list_in_columns(sorted_words, columns - 1)
    global show_x
    show_x = False


@defword(name='while', doc="""\
Execute an indefinite loop while a condition is satisfied.
BEGIN xxx <flag> WHILE yyy REPEAT

LEAVE will exit the loop early.  Note that the effect of the test in
BEGIN...WHILE is opposite that in BEGIN...UNTIL.  The loop repeats
while something is true, rather than until it becomes true.

qv AGAIN, BEGIN, LEAVE, REPEAT, UNTIL""")
def w_while():
    pass                        # Grammer rules handle this word


@defword(name='words')
def w_words():
    scope = scope_stack.top()
    lnwriteln("{} words: {}".format(scope, scope.words().keys()))


@defword(name='words!', hidden=True)
def w_words_bang():
    for (i, scope) in scope_stack.items_bottom_to_top():
        lnwriteln("{} words: {}".format(scope, scope.words().keys()))




#############################################################################
#
#       U T I L I T Y   F U N C T I O N S
#
#############################################################################
def memoize(f):
    memoize = {}
    def helper(x):
        if x not in memoize:
            memoize[x] = f(x)
        return memoize[x]
    return helper


def comb_helper(n, r):
    if r > n or r < 0:
        return 0
    if n - r < r:
        r = n - r

    result = 1
    j = 1
    while j <= r:
        result *= n; n -= 1
        result /= j; j += 1
    return result


def convert_mode_to_radians(x, force_mode=None):
    global angle_mode
    mode = force_mode if force_mode is not None else angle_mode
    if mode == "r":
        return x
    elif mode == "d":
        return x / DEG_PER_RAD
    elif mode == "g":
        return x / GRAD_PER_RAD
    else:
        raise Rp2Fatal("{}: Bad angle_mode '{}'".format(whoami(), mode))


def convert_radians_to_mode(r, force_mode=None):
    global angle_mode
    mode = force_mode if force_mode is not None else angle_mode
    if mode == "r":
        return r
    elif mode == "d":
        return r * DEG_PER_RAD
    elif mode == "g":
        return r * GRAD_PER_RAD
    else:
        raise Rp2Fatal("{}: Bad angle_mode '{}'".format(whoami(), mode))


def defvar(name, value, **kwargs):
    global_scope.set_variable(name, Rpn_Variable(name, value, **kwargs))


def old_defword(name, defn, **kwargs):
    global_scope.set_word(name, Rpn_Word(name, defn, **kwargs))


def eval_string(s):
    dbg("eval_string", 1, "eval_string('{}')".format(s))
    scope_stack_size = scope_stack.size()
    try:
        result = parser.parse(s) # , debug=dbg("eval_string"))
    except Rpn_E_Parse_Error as e:
        if str(e) != 'EOF':
            lnwriteln("Parse error: {}".format(str(e)))
    except Rpn_E_Abort:
        param_stack.clear()
        string_stack.clear()
        return_stack.clear()
    else:
        if result is not None:
            dbg("eval_string", 1, "result={}".format(result))
    finally:
        if scope_stack.size() > scope_stack_size:
            dbg("eval_string", 1, "Gotta pop {} scopes from the stack".format(scope_stack.size() - scope_stack_size))
        while scope_stack.size() > scope_stack_size:
            pop_scope("Parse failure")


@memoize
def fact_helper(x):
    result = 1
    while x > 1:
        result *= x
        x -= 1
    return result


def flag_clear(flag):
    global flags_vec
    if flag < 0 or flag > flag_max - 1:
        raise Rpn_E_Fatal("{}: Flag {} out of range".format(whoami(), flag))
    flags_vec &= ~(1<<flag)

def flag_set(flag):
    global flags_vec
    if flag < 0 or flag > flag_max - 1:
        raise Rpn_E_Fatal("{}: Flag {} out of range".format(whoami(), flag))
    flags_vec |= 1<<flag

def flag_test(flag):
    global flags_vec
    if flag < 0 or flag > flag_max - 1:
        raise Rpn_E_Fatal("{}: Flag {} out of range".format(whoami(), flag))
    return True if flags_vec & 1<<flag != 0 else False


# Helper routines for KEY
class _Getch_Windows:
    def __init__(self):
        import msvcrt

    def __call__(self):
        import msvcrt
        return msvcrt.getch()

class _Getch_Unix:
    def __init__(self):
        # import termios now or else you'll get the Unix version on the Mac
        import tty, sys, termios

    def __call__(self):
        import sys, tty, termios
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch

class _Getch:
    """Gets a single character from standard input.  Does not echo to the screen."""

    def __init__(self):
        try:
            self.impl = _Getch_Windows()
        except ImportError:
            self.impl = _Getch_Unix()


    def __call__(self): return self.impl()


# Jeffrey Magedanz - https://stackoverflow.com/posts/42602689/revisions
def list_in_columns(items, width=79, indent=0, spacing=3):
    """\
Return string listing items along columns.

items : sequence
    List of items to display that must be directly convertible into
    unicode strings.
width : int
    Maximum number of characters per line, including indentation.
indent : int
    Number of spaces in left margin.
spacing : int
    Number of spaces between columns."""

    if not items:
        return u''
    # Ensure all items are strings
### items = [unicode(item) for item in items]
    # Estimate number of columns based on shortest and longest items
    minlen = min(len(item) for item in items)
    maxlen = max(len(item) for item in items)
    # Assume one column with longest width, remaining with shortest.
    # Use negative numbers for ceiling division.
    ncols = 1 - (-(width - indent - maxlen) // (spacing + min(1, minlen)))
    ncols = max(1, min(len(items), ncols))

    # Reduce number of columns until items fit (or only one column)
    while ncols >= 1:
        # Determine number of rows by ceiling division
        nrows = -(-len(items) // ncols)
        # Readjust to avoid empty last column
        ncols = -(-len(items) // nrows)
        # Split items into columns, and test width
        columns = [items[i*nrows:(i+1)*nrows] for i in range(ncols)]
        totalwidth = indent - spacing + sum(
            spacing + max(len(item) for item in column)
            for column in columns
            )
        # Stop if columns fit. Otherwise, reduce number of columns and
        # try again.
        if totalwidth <= width:
            break
        else:
            ncols -= 1

    # Pad all items to column width
    for i, column in enumerate(columns):
        colwidth = max(len(item) for item in column)
        columns[i] = [
            item + ' ' * (colwidth - len(item))
            for item in column
            ]

    # Transpose into rows, and return joined rows
    rows = list(itertools.zip_longest(*columns, fillvalue=''))
    out = '\n'.join(' ' * indent + (u' ' * spacing).join(row).rstrip()
                    for row in rows)
    writeln(out)


def load_file(filename):
    try:
        with open(filename, "r") as file:
            contents = file.read()
    except PermissionError:
        raise RuntimeError("load: Cannot read file '{}'".format(filename))
    else:
        eval_string(contents)


def lookup_variable(name):
    for (_, scope) in scope_stack.items_top_to_bottom():
        #lnwriteln("{}: Looking for variable {} in {}...".format(whoami(), name, scope))
        #lnwriteln("{} has variables: {}".format(scope, scope.variables))
        var = scope.variable(name)
        if var is not None:
            # lnwriteln("{}: Found variable {} in scope {}: {}".format(whoami(), name, scope, var))
            return (var, scope)
    #lnwriteln("{}: Variable {} not found".format(whoami(), name))
    return (None, None)


def lookup_word(name):
    for (_, scope) in scope_stack.items_top_to_bottom():
        #lnwriteln("{}: Looking for word {} in {}...".format(whoami(), name, scope))
        #lnwriteln("{} has words: {}".format(scope, scope.words))
        word = scope.word(name)
        if word is not None:
            #lnwriteln("{}: Found word {} in scope {}: {}".format(whoami(), name, scope, word))
            return (word, scope)
    #lnwriteln("{}: Word {} not found".format(whoami(), name))
    return (None, None)


def normalize_hms(hh, mm, ss):
    while ss < 0:
        mm -=  1
        ss += 60
    while ss >= 60:
        mm +=  1
        ss -= 60
    while mm < 0:
        hh -=  1
        mm += 60
    while mm >= 60:
        hh +=  1
        mm -= 60
    return (hh, mm, ss)


def parse_args():
    try:
        opts, argv = getopt.getopt(sys.argv[1:], "dil:")
    except getopt.GetoptError as e:
        print(str(e))
        usage()
        sys.exit(2)

    for opt, arg in opts:
        if opt == "-d":
            global debug_enabled
            debug_enabled = True
        elif opt == "-i":
            global force_interactive
            force_interactive = True
        elif opt == "-l":
            try:
                load_file(arg)
            except FileNotFoundError:
                lnwriteln("load: File '{}' does not exist".format(arg))
            except RuntimeError as e:
                lnwriteln(str(e))
        else:
            print("Unhandled option {}".format(opt))
            sys.exit(2)

    return argv


def prompt_string():
    global angle_mode
    s = "[{}{}] ".format(angle_mode, param_stack.size())

    if not parse_stack.empty():
        qq = " ".join([ p[1] for p in parse_stack.items_bottom_to_top() ])
        s += qq + " ... "
    return s

def push_scope(scope, why):
    dbg("scope", 1, "Pushing scope {} due to {}".format(repr(scope), why))
    scope_stack.push(scope)

def pop_scope(why):
    scope = scope_stack.pop()
    dbg("scope", 1, "Popped scope {} due to {}".format(repr(scope), why))
    if scope == global_scope:
        raise Rpn_E_Fatal("Attempting to pop Global scope!")


def sigquit_handler(signum, frame):
    lnwriteln("[Quit]")
    raise Rpn_E_End_Program()


# Simple SIGWINCH handler can become overwhelmed and crash if window
# changes come too fast.  Consider using shutil.get_terminal_size()
def sigwinch_handler(signum, frame):
    stty_size = subprocess.check_output(['stty', 'size']).decode().split()
    if len(stty_size) != 2:
        return

    tty_rows, tty_columns = stty_size
    #lnwriteln("{} x {}".format(tty_rows, tty_columns))
    if int(tty_columns) == 0:
        env_cols = os.getenv("COLUMNS")
        tty_columns = int(env_cols) if env_cols is not None else 80
    if int(tty_rows) == 0:
        env_rows = os.getenv("ROWS")
        tty_rows = int(env_rows) if env_rows is not None else 24
    global_scope.variable('ROWS').set_obj(Rpn_Integer(tty_rows))
    global_scope.variable('COLS').set_obj(Rpn_Integer(tty_columns))


def write(s=""):
    if len(s) == 0:
        return
    sharpout = global_scope.variable('#OUT')
    outval = sharpout.obj().value()
    newline = s.find("\n")
    while newline != -1:
        substring = s[:newline]
        print(substring)
        outval = 0
        s = s[newline+1:]
        newline = s.find("\n")
    outval += len(s)
    print(s, end='', flush=True)
    sharpout.set_obj(Rpn_Integer(outval))

def writeln(s=""):
    sharpout = global_scope.variable('#OUT')
    print(s, flush=True)
    sharpout.set_obj(Rpn_Integer(0))

def lnwrite(s=""):
    sharpout = global_scope.variable('#OUT')
    if sharpout.obj().value() != 0:
        writeln()
    write(s)

def lnwriteln(s=""):
    sharpout = global_scope.variable('#OUT')
    if sharpout.obj().value() != 0:
        writeln()
    writeln(s)




#############################################################################
#
#       M A I N   L O O P   &   P R I M A R Y   F U N C T I O N S
#
#############################################################################
def usage():
    print("""
Usage: rpn [-d] [-i] [-l FILE] cmds...

-d      Enable debugging
-i      Force interactive mode
-l FILE Load FILE""")


def initialize():
    global rpn_version, default_protected

    random.seed()
    push_scope(global_scope, "Global scope")
    w_clflag()
    define_variables()
    define_secondary_words()

    # Set up signal handling
    signal.signal(signal.SIGQUIT, sigquit_handler)
    signal.signal(signal.SIGWINCH, sigwinch_handler)
    sigwinch_handler(0, 0)      # Read & define ROWS and COLS via stty(1)

    # Switch to user mode; words are no longer protected
    default_protected = False

    # Attempt to load the user's init file
    init_file = os.path.expanduser("~/.rpnrc")
    if os.path.isfile(init_file):
        load_file(init_file)

    # Parse command line
    argv = parse_args()

    if len(argv) > 0:
        global go_interactive
        if not force_interactive:
            go_interactive = False
        s = " ".join([ arg for arg in argv ])
        eval_string(s)


def define_secondary_words():
    eval_string("""
: BL            doc:"BL  ( -- 32 )   ASCII code for a space character"
  32 ;

: space         doc:"space   Display one space character"
  BL emit ;

: spaces        doc:"spaces  ( n -- )   Display N space characters"
  0 do space loop ;

: X       88 emit ;
: xbox  |foo bar|  5 0 do  4 0 do X loop cr loop ;

: foo |a b c| : bar |x y z|   ."----" cr ; : baz 66 emit space ; 65 emit space baz bar ;

\ variable v1     [1 2 3] !v1
\ variable v2     [4 5 6] !v2
\ variable m
\ [[1 2 3]
\  [4 5 6]]   !m

\ : inout |in:a in:b out:c|  @a @b + 2 * !c ;

""")


def define_variables():
    defvar('#OUT', Rpn_Integer(0), protected=True, readonly=True, noshadow=True)
    defvar('BEG',  Rpn_Integer(0), protected=True, readonly=True) # 1=Begin, 0=End (default)
    defvar('COLS', Rpn_Integer(0), protected=True)
    defvar('FV',   None, protected=True)
    defvar('I%YR', None, protected=True)
    defvar('N',    None, protected=True)
    defvar('P/YR', Rpn_Integer(12), protected=True)
    defvar('PMT',  None, protected=True)
    defvar('PV',   None, protected=True)
    defvar('ROWS', Rpn_Integer(0), protected=True)
    defvar('VER',  Rpn_Float(rpn_version), protected=True, constant=True, noshadow=True)




#############################################################################
#
#       M A I N
#
#############################################################################
class Rpn_Queue:
    def __init__(self):
        self._q = queue.SimpleQueue()
    def empty(self):
        return self._q.empty()
    def get(self):
        return self._q.get_nowait()
    def put(self, item):
        self._q.put(item)


class Token_Mgr:
    qtok = Rpn_Queue()
    e = 0

    @classmethod
    def get_more_tokens(cls):
        tok_count = 0
        data = ""
        sharpout = global_scope.variable('#OUT')
        prompt = prompt_string()
        global show_x

        # Read characters from input stream
        while data == "":
            if show_x and not param_stack.empty():
                writeln("{}".format(str(param_stack.top())))
            show_x = False

            lnwrite(prompt)
            data = input()
            sharpout.set_obj(Rpn_Integer(0))

        # Get all the tokens
        lexer.input(data)
        while True:
            tok = lexer.token()
            if not tok:
                break
            cls.qtok.put(tok)
            dbg("token", 1, "Lexer returned {}, queueing".format(tok))
            tok_count += 1

        return tok_count

    @classmethod
    def next_token(cls):
        if cls.qtok.empty():
            if cls.e == 0:
                new_toks = 0
                while new_toks == 0:
                    try:
                        new_toks = Token_Mgr.get_more_tokens()
                    except EOFError:
                        # ^D (eof) on input signals end of input tokens
                        lnwrite()
                        return
                    except KeyboardInterrupt:
                        # ^C can either void the parse_stack, or the end program
                        if parse_stack.empty():
                            raise Rpn_E_End_Program()
                        else:
                            lnwriteln("[Top level]")
                            raise Rpn_E_Top_Level()

        try:
            yield cls.qtok.get()
        except queue.Empty:
            return



def generate_token_list():
    '''Returns a tuple (flag, list)
flag is True if initial parse error, False if no error'''

    initial_parse_error = False
    parse_stack.clear()
    tok_list = []
    depth = {
        'BRACKET' : 0,
        'PAREN'   : 0
    }

    while True:
        # Get next token
        tok = next(Token_Mgr.next_token())

        # Process token
        dbg("token", 1, "token=({},{})".format(tok.type, repr(tok.value)))

        if tok.type == 'BACKSLASH':
            pass

        # These need a second token or they will be very angry
        elif tok.type in ['AT_SIGN', 'CONSTANT', 'EXCLAM', 'FORGET', 'HELP',
                          'SHOW', 'UNDEF', 'VARIABLE' ]:
            parse_stack.push(tok.type)
            try:
                tok2 = next(Token_Mgr.next_token())
            except StopIteration:
                initial_parse_error = True
                dbg("{}: No more tokens, exiting".format(tok.type))
                break
            finally:
                tok_list.append(tok)
                parse_stack.pop()
            tok_list.append(tok2)

        elif tok.type in ['OPEN_BRACKET', 'CLOSE_BRACKET',
                          'OPEN_PAREN',   'CLOSE_PAREN']:
            tok_list.append(tok)
            (open_close, borp) = tok.type.split("_")
            #print("borp={}".format(borp))
            if borp == 'PAREN':
                c = '('
            elif borp == 'BRACKET':
                c = '['

            if open_close == 'OPEN':
                if borp == 'PAREN' and depth[borp] > 0:
                    lnwriteln("{}: Embedded {} not allowed".format(tok.type, c))
                    initial_parse_error = True
                else:
                    parse_stack.push(c)
                    depth[borp] += 1

            if open_close == 'CLOSE':
                if parse_stack.empty() or \
                        borp == 'BRACKET' and parse_stack.top() != c or \
                        borp == 'PAREN'   and parse_stack.top() != '(,':
                    lnwriteln("{}: {} lost".format(tok.type, c))
                    initial_parse_error = True
                else:
                    parse_stack.pop()
                    depth[borp] -= 1

        elif tok.type == 'COMMA':
            if parse_stack.empty() or parse_stack.top() != '(':
                lnwriteln("{}: no matching (".format(tok.type))
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()
                parse_stack.push('(,')

        elif tok.type in ['BEGIN', 'CASE', 'COLON', 'DO', 'IF']:
            tok_list.append(tok)
            parse_stack.push(tok.type)

        elif tok.type in ['AGAIN', 'UNTIL']:
            if parse_stack.empty() or parse_stack.top() != 'BEGIN':
                lnwriteln("{}: no matching BEGIN".format(tok.type))
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()

        elif tok.type == 'ELSE':
            if parse_stack.empty() or parse_stack.top() != 'IF':
                lnwriteln("ELSE: no matching IF")
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()
                parse_stack.push(tok.type)

        elif tok.type == 'ENDCASE':
            if parse_stack.empty() or parse_stack.top() not in ['CASE', 'OTHERWISE']:
                lnwriteln("ENDCASE: no matching CASE")
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()

        elif tok.type == 'ENDOF':
            if parse_stack.empty() or parse_stack.top() != 'OF':
                lnwriteln("ENDOF: no matching OF")
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()
                parse_stack.push('CASE')

        elif tok.type == 'ERROR':
            lnwriteln("ERROR {}".format(tok))
            initial_parse_error = True

        elif tok.type in ['LOOP', 'PLUS_LOOP']:
            if parse_stack.empty() or parse_stack.top() != 'DO':
                lnwriteln("{}: no matching DO".format(tok.type))
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()

        elif tok.type in ['OF', 'OTHERWISE']:
            if parse_stack.empty() or parse_stack.top() != 'CASE':
                lnwriteln("{}: no matching CASE".format(tok.type))
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()
                parse_stack.push(tok.type)

        elif tok.type == 'REPEAT':
            if parse_stack.empty() or parse_stack.top() != 'WHILE':
                lnwriteln("REPEAT: no matching WHILE")
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()

        elif tok.type == 'SEMICOLON':
            if parse_stack.empty() or parse_stack.top() != 'COLON':
                lnwriteln("SEMICOLON: no matching COLON")
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()

        elif tok.type == 'THEN':
            if parse_stack.empty() or parse_stack.top() not in ['IF', 'ELSE']:
                lnwriteln("THEN: no matching IF")
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()

        elif tok.type == 'WHILE':
            if parse_stack.empty() or parse_stack.top() != 'BEGIN':
                lnwriteln("WHILE: no matching BEGIN")
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()
                parse_stack.push(tok.type)

        else:
        # 'ABORT_QUOTE',
        # 'DOC_STR',
        # 'DOT_QUOTE',
        # 'IDENTIFIER',
        # 'VBAR',
        # 'WS',
            tok_list.append(tok)

        # Here's what breaks the while True loop, sauf StopIteration
        if parse_stack.empty() and depth['PAREN'] == 0 and depth['BRACKET'] == 0:
            break

    return (initial_parse_error, tok_list)


def main_loop():
    global show_x
    show_x = False    # Reset, because some argv may have set it to True

    w_ver()
    if not param_stack.empty():
        w_dot_s()

    while True:
        try:
            (error, tok_list) = generate_token_list()
        except StopIteration:
            return
        except Rpn_E_Top_Level:
            continue
        s = " ".join([ t.value for t in tok_list ])
        dbg("parse", 1, "s='{}'".format(s))
        eval_string(s)


def end_program():
    if global_scope.variable('#OUT').obj().value() != 0:
        writeln()

    if not string_stack.empty():
        if string_stack.size() == 1:
            w_dollar_dot(); w_cr()
        else:
            lnwriteln("Strings:")
            w_dollar_dot_s()

    if not param_stack.empty():
        if param_stack.size() == 1:
            w_dot(); w_cr()
        else:
            lnwriteln("Stack:")
            w_dot_s()




#############################################################################
#
#       M A I N
#
#############################################################################

param_stack  = Rpn_Stack()
parse_stack  = Rpn_Stack()
return_stack = Rpn_Stack()
scope_stack  = Rpn_Stack()
string_stack = Rpn_Stack()

lexer  = lex.lex()
parser = yacc.yacc(start='evaluate') # , errorlog=yacc.NullLogger())

if __name__ == "__main__":
    try:
        initialize()
        if go_interactive:
            main_loop()
    except Rpn_E_End_Program:
        pass
    except Rpn_E_Fatal as e:
        if len(e._message) > 0:
            lnwriteln("Fatal error: {}".format(e))
        sys.exit(1)

    end_program()

sys.exit(0)
