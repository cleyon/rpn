#!/usr/bin/env python3

rpn_version = 15.3

import cmath
import inspect
import itertools
import math
import numpy    as np
import os
import ply.yacc as yacc
import random
import signal
import subprocess
import sys

from fractions  import Fraction
from rpn_lex    import tokens



#############################################################################
#
#       S U P P O R T   C L A S S E S
#
#############################################################################
class Rpn2Exception(Exception):
    def __init__(self, msg=""):
        self._message = msg
    def __str__(self):
        return str(self._message)

class Rpn2Abort(Rpn2Exception):
    """Rpn2Abort is raised by the ABORT and ABORT" words.
It is caught in p_execute().  It clears the parameter and string stacks,"""
    pass

class Rpn2EndProgram (Rpn2Exception):
    """Rpn2EndProgram is raised when there is no more input to parse, or
the interrupt key is signaled.  It is caught in __main__, where processing
is halted, the exit routine prints the stack, and the program exits."""
    pass

# XXX - where should this be caught?
class Rpn2Exit(Rpn2Exception):
    """Rpn2Exit is raised by the word EXIT and terminates execution
of the current word."""
    pass

class Rpn2Fatal(Rpn2Exception):
    """Rpn2Fatal is raised whenever an internal error is detected that
forces the program to abend.  It is caught in __main__ and causes an
immediate program termination."""
    pass

class Rpn2Leave(Rpn2Exception):
    """Rpn2Leave is raised by the LEAVE word.  This is caught by
BEGIN or DO loops, and causes an immediate exit from the enclosing loop.
If a loop is not currently executing, it is caught in p_execute() and
an error message is printed."""
    pass

class Rpn2TopLevel(Rpn2Exception):
    """Rpn2TopLevel causes an immediate return to the top level prompt.
It is caught in main_loop."""
    pass


class Rpn2AbortQuote:
    def __init__(self, val):
        if len(val) < 7 or val[0:6] != 'abort"' or val[-1] != '"':
            raise Rpn2Fatal("{}: Malformed string: '{}'".format(whoami(), val))
        self._str = val[6:-1]

    def stringval(self):
        return self._str

    def __call__(self):
        if param_stack.empty():
            raise RuntimeError("abort\": Insufficient parameters (1 required)")
        flag = param_stack.pop()
        if type(flag) is not Rpn2Integer:
            param_stack.push(flag)
            raise TypeError("abort\": Flag must be an integer")
        if flag.value() != 0:
            lnwriteln("{}".format(self.stringval()))
            raise Rpn2Abort()

    def __str__(self):
        return "abort\"{}\"".format(self.stringval())

    def __repr__(self):
        return "AbortQuote[{}]".format(repr(self.stringval()))



class Rpn2BeginAgain:
    def __init__(self, seq):
        self._seq = seq

    def __call__(self):
        try:
            while True:
                self._seq.__call__()
        except Rpn2Leave:
            pass

    def __str__(self):
        return "begin {} again".format(self._seq)

    def __repr__(self):
        return "BeginAgain[{}]".format(repr(self._seq))


class Rpn2BeginUntil:
    def __init__(self, seq):
        self._seq = seq

    def __call__(self):
        try:
            while True:
                self._seq.__call__()
                if param_stack.empty():
                    raise RuntimeError("until: Insufficient parameters (1 required)")
                flag = param_stack.pop()
                if type(flag) is not Rpn2Integer:
                    param_stack.push(flag)
                    raise TypeError("until: Flag must be an integer")
                if flag.value() != 0:
                    break
        except Rpn2Leave:
            pass

    def __str__(self):
        return "begin {} until".format(self._seq)

    def __repr__(self):
        return "BeginUntil[{}]".format(repr(self._seq))


class Rpn2BeginWhile:
    def __init__(self, seq1, seq2):
        self._seq1 = seq1
        self._seq2 = seq2

    def __call__(self):
        try:
            while True:
                self._seq1.__call__()
                if param_stack.empty():
                    raise RuntimeError("while: Insufficient parameters (1 required)")
                flag = param_stack.pop()
                if type(flag) is not Rpn2Integer:
                    param_stack.push(flag)
                    raise TypeError("while: Flag must be an integer")
                if flag.value() == 0:
                    break
                self._seq2.__call__()
        except Rpn2Leave:
            pass

    def __str__(self):
        return "begin {} while {} repeat".format(self._seq1, self._seq2)

    def __repr__(self):
        return "BeginWhile[{},{}]".format(repr(self._seq1), repr(self._seq2))


class Rpn2Case:
    def __init__(self, case_clauses, otherwise_seq):
        self._case_clauses  = case_clauses
        self._otherwise_seq = otherwise_seq
    def __call__(self):
        if param_stack.empty():
            raise RuntimeError("case: Insufficient parameters (1 required)")
        n = param_stack.pop()
        if type(n) is not Rpn2Integer:
            param_stack.push(n)
            raise TypeError("case: Case control parameter must be an integer")
        nval = n.value()
        ran = False
        for clause in self._case_clauses.items():
            ran = clause.attempt_call(nval)
            if ran:
                break
        if not ran:
            self._otherwise_seq.__call__()


class Rpn2CaseClause:
    def __init__(self, x, seq):
        self._x = x             # x is a plain integer, not an Rpn2Integer
        self._seq = seq
    def attempt_call(self, n):
        if n == self._x:
            self._seq.__call__()
            return True
        else:
            return False


class Rpn2Complex:
    def __init__(self, real=0.0, imag=0.0):
        self.set_real_imag(real, imag)

    @classmethod
    def from_complex(cls, cplx):
        return cls(cplx.real, cplx.imag)

    def value(self):
        return self._value

    def real(self):
        return self.value().real

    def imag(self):
        return self.value().imag

    def set_real_imag(self, real, imag):
        self._value = complex(float(real), float(imag))

    def zerop(self):
        return self.real() == 0.0 and self.imag() == 0.0

    def __str__(self):
        return "({}, {})".format(self.real(), self.imag()) # sprintf?

    def __repr__(self):
        return "Complex[{}]".format(repr(self.value()))


class Rpn2DoLoop:
    def __init__(self, seq):
        self._seq = seq
        seq.scope().set_variable('_I', Rpn2Variable('_I', None, hidden=True))

    def __call__(self):
        if param_stack.size() < 2:
            raise RuntimeError("do: Insufficient parameters (2 required)")
        x = param_stack.pop()
        y = param_stack.pop()
        if type(y) is not Rpn2Integer or type(x) is not Rpn2Integer:
            param_stack.push(y)
            param_stack.push(x)
            raise TypeError("do: Loop control parameters must be integers")
        _I = self._seq.scope().variable('_I')
        limit = y.value()
        i = x.value()
        _I.set_obj(x)
        if i == limit:
            #lnwriteln("do: Not executing because initial == limit")
            return

        try:
            while True:
                self._seq.__call__()
                i += 1
                _I.set_obj(Rpn2Integer(i))
                if i >= limit:
                    break
        except Rpn2Leave:
            pass

    def __str__(self):
        return "do {} loop".format(self._seq)

    def __repr__(self):
        return "DoLoop[{}]".format(repr(self._seq))


class Rpn2DoPlusLoop:
    def __init__(self, seq):
        self._seq = seq
        seq.scope().set_variable('_I', Rpn2Variable('_I', None, hidden=True))

    def __call__(self):
        if param_stack.size() < 2:
            raise RuntimeError("do: Insufficient parameters (2 required)")
        x = param_stack.pop()
        y = param_stack.pop()
        if type(y) is not Rpn2Integer or type(x) is not Rpn2Integer:
            param_stack.push(y)
            param_stack.push(x)
            raise TypeError("do: Loop control parameters must be integers")
        _I = self._seq.scope().variable('_I')
        limit = y.value()
        i = x.value()
        _I.set_obj(x)
        if i == limit:
            #lnwriteln("do: Not executing because initial == limit")
            return

        try:
            while True:
                self._seq.__call__()
                if param_stack.empty():
                    raise RuntimeError("+loop: Insufficient parameters (1 required)")
                incr = param_stack.pop()
                if type(incr) is not Rpn2Integer:
                    param_stack.push(incr)
                    raise TypeError("+loop: Increment must be integer")
                i += incr.value()
                _I.set_obj(Rpn2Integer(i))
                if    incr.value() > 0 and i >= limit \
                   or incr.value() < 0 and i < limit:
                    break
        except Rpn2Leave:
            pass

    def __str__(self):
        return "do {} +loop".format(self._seq)

    def __repr__(self):
        return "DoPlusLoop[{}]".format(repr(self._seq))


class Rpn2DotQuote:
    def __init__(self, val):
        if len(val) < 3 or val[0:2] != '."' or val[-1] != '"':
            raise Rpn2Fatal("{}: Malformed string: '{}'".format(whoami(), val))
        self._str = val[2:-1]

    def stringval(self):
        return self._str

    def __call__(self):
        write("{}".format(self.stringval()))

    def __str__(self):
        return ".\"{}\"".format(self.stringval())

    def __repr__(self):
        return "DotQuote[{}]".format(repr(self.stringval()))


class Rpn2Error:
    def __init__(self, msg):
        self._message = msg

    def __call__(self):
        lnwriteln(self._message)

    def __repr__(self):
        return "Error[{}]".format(self._message)


class Rpn2Exe:
    def __init__(self, exe):
        self._exe = exe

    def __call__(self):
        try:
            self._exe.__call__()
        except Rpn2Exit:
            raise

    def __str__(self):
        return str(self._exe)

    def __repr__(self):
        return "Exe[{}]".format(repr(self._exe))


class Rpn2FetchVar:
    def __init__(self, id, var):
        if type(var) is not Rpn2Variable:
            raise Rpn2Fatal("{}: Variable {} is not an Rpn2Variable".format(whoami(), id))
        self._identifier = id
        self._variable = var

    def variable(self):
        return self._variable

    def identifier(self):
        return self._identifier

    def __str__(self):
        return "@{}".format(self.identifier())

    def __repr__(self):
        return "Fetch[{}]".format(self.identifier())


class Rpn2Float:
    def __init__(self, val=0.0):
        self._value = float(val)

    def value(self):
        return self._value

    def set_value(self, val):
        self._value = float(val)

    def zerop(self):
        return self.value() == 0.0

    def __str__(self):
        return "{}".format(self.value()) # sprintf

    def __repr__(self):
        return "Float[{}]".format(repr(self.value()))


class Rpn2Help:
    def __init__(self, id, doc):
        self._identifier = id
        self._doc = doc

    def __call__(self):
        lnwriteln(self.doc())

    def identifier(self):
        return self._identifier

    def doc(self):
        return self._doc

    def __str__(self):
        return "help {}".format(self.identifier())

    def __repr__(self):
        return "Help[{}]".format(self.repr(self.identifier()))


class Rpn2If:
    def __init__(self, seq):
        self._seq = seq

    def __call__(self):
        if param_stack.empty():
            raise RuntimeError("if: Insufficient parameters (1 required)")
        flag = param_stack.pop()
        if type(flag) is not Rpn2Integer:
            param_stack.push(flag)
            raise TypeError("if: Flag must be an integer")
        if flag.value() != 0:
            self._seq.__call__()

    def __str__(self):
        return "if {} then".format(self._seq)

    def __repr__(self):
        return "If[{}]".format(repr(self._seq))


class Rpn2IfElse:
    def __init__(self, seq1, seq2):
        self._seq1 = seq1
        self._seq2 = seq2

    def __call__(self):
        if param_stack.empty():
            raise RuntimeError("if: Insufficient parameters (1 required)")
        flag = param_stack.pop()
        if type(flag) is not Rpn2Integer:
            param_stack.push(flag)
            raise TypeError("if: Flag must be an integer")
        if flag.value() != 0:
            self._seq1.__call__()
        else:
            self._seq2.__call__()

    def __str__(self):
        return "if {} else {} then".format(self._seq1, self._seq2)

    def __repr__(self):
        return "IfElse[{},{}]".format(repr(self._seq1), repr(self._seq2))


class Rpn2Integer:
    def __init__(self, val=0):
        self._value = int(val)

    def value(self):
        return self._value

    def set_value(self, val):
        self._value = int(val)

    def zerop(self):
        return self.value() == 0

    def __str__(self):
        return "{}".format(self.value()) # sprintf

    def __repr__(self):
        return "Integer[{}]".format(repr(self.value()))


class Rpn2List:
    def __init__(self, item=None, oldlist=None):
        if item is None and oldlist is None:
            self._list = []
        elif item is not None and oldlist is None:
            self._list = [ item ]
        else:
            val = []
            for x in oldlist.listval():
                val.append(x)
            val.insert(0, item)
            self._list = val

    def listval(self):
        return self._list

    def __call__(self):
        caught_exit = False
        for item in self.listval():
            # lnwriteln("{}: {}.__call__()".format(whoami(), item))
            try:
                item.__call__()
            except Rpn2Exit:
                caught_exit = True
                break
        if caught_exit is True:
            raise Rpn2Exit

    def items(self):
        for item in self.listval():
            yield item

    def __len__(self):
        return len(self.listval())

    def __str__(self):
        s = ""
        for item in self.listval():
            s += str(item) + " "
        return s[:-1]

    def __repr__(self):
        if len(self.listval()) == 0:
            return "List[]"
        else:
            s = "List["
            for item in self.listval():
                s += repr(item) + ","
            return s[:-1] + "]"


class Rpn2Matrix:
    def __init__(self, vals):
        lnwriteln("{}: vals={}".format(whoami(), vals))
        self._vals = vals
        self._nrows = len(vals)
        cols = -1
        for x in vals.items():
            lnwriteln("x={}".format(repr(x)))
            if cols == -1:
                cols = x.size()
            else:
                if x.size() != cols:
                    lnwriteln("Number of columns is not consistent")
                    return      # # raise?
        self._ncols = cols
        lnwriteln("{} rows x {} columns".format(self.nrows(), self.ncols()))

    def value(self):
        raise RuntimeError("Need Rpn2Matrix#value()")

    def nrows(self):
        return self._nrows

    def ncols(self):
        return self._ncols

    def __str__(self):
        return "Matrix..."      # "[" + str(self.vals) + "]"

    def __repr__(self):
        return "Matrix[{}]".format(repr(self._vals))


class Rpn2NoOp:
    def __init__(self):
        pass

    def __call__(self):
        pass

    def __str__(self):
        return ""

    def __repr__(self):
        return "NoOp[]"


class Rpn2Rational:
    def __init__(self, num=0, denom=1):
        self._value = Fraction(int(num), int(denom))

    @classmethod
    def from_Fraction(cls, frac):
        return cls(frac.numerator, frac.denominator)

    def value(self):
        return self._value

    def numerator(self):
        return self.value().numerator

    def denominator(self):
        return self.value().denominator

    def set_num_denom(self, num, denom):
        self._value = Fraction(int(num), int(denom))

    def zerop(self):
        return self.numerator() == 0

    def __str__(self):
        return "{}~{}".format(self.numerator(), self.denominator())

    def __repr__(self):
        return "Rational[{}]".format(repr(self.value()))


class Rpn2Scope:
    def __init__(self):
        self._words = {}
        self._variables = {}

    def words(self):
        return self._words

    def set_word(self, identifier, word):
        if type(word) is not Rpn2Word:
            raise Rpn2Fatal("{}: Word {} is not an Rpn2Word".format(whoami(), identifier))
        # if word.doc() is None and not word.hidden():
        #     print("Warning: Word '{}' has no documentation".format(identifier))
        self._words[identifier] = word

    def word(self, identifier):
        return self._words.get(identifier)

    def set_variable(self, identifier, var):
        if type(var) is not Rpn2Variable:
            raise Rpn2Fatal("{}: Variable {} is not an Rpn2Variable".format(whoami(), identifier))
        self._variables[identifier] = var

    def variable(self, identifier):
        return self._variables.get(identifier)

    def variables(self):
        return self._variables

    def __repr__(self):
        return "Scope[{}]".format(hex(id(self)))


class Rpn2Sequence:
    def __init__(self, scope, in_vars, out_vars, exe_seq):
        self._scope    = scope
        self._in_vars  = in_vars
        self._out_vars = out_vars
        self._exe_seq  = exe_seq
        # print("{}: scope={}, exe_seq={}".format(whoami(), repr(scope), repr(exe_seq)))

    def __call__(self):
        # check param_stack.size() vs len(in_vars)

        push_scope(self.scope(), "Calling sequence {}".format(self.exe_seq))
        try:
            # lnwriteln("{}: exe_seq={}".format(whoami(), repr(self._exe_seq)))
            self._exe_seq.__call__()
        except Rpn2Exit:
            raise
        finally:
            s = pop_scope("Sequence {} is done".format(self.exe_seq))

        # push out variables onto param_stack

    def scope(self):
        return self._scope

    def exe_seq(self):
        return self._exe_seq

    def __str__(self):
        s = "Scope+Seq"
        return s

    def __repr__(self):
        return "Sequence[Scope={}, Exe_Seq={}]".format(repr(self.scope()), repr(self.exe_seq()))


class Rpn2Stack:
    def __init__(self):
        self._stack = []
        self._nitems = 0

    def clear(self):
        self._stack = []
        self._nitems = 0

    def size(self):
        return self._nitems

    def empty(self):
        return self.size() == 0

    def push(self, item):
        self._nitems += 1
        self._stack.append(item)

    def pop(self):
        if self.empty():
            raise Rpn2Fatal("{}: Empty stack".format(whoami()))
        self._nitems -= 1
        return self._stack.pop()

    def top(self):
        if self.empty():
            raise Rpn2Fatal("{}: Empty stack".format(whoami()))
        return self._stack[self.size() - 1]

    def items_bottom_to_top(self):
        """Return stack items from bottom to top."""
        i = self._nitems + 1
        for item in self._stack:
            i -= 1
            yield (i, item)

    def items_top_to_bottom(self):
        """Return stack items from top to bottom."""
        return reversed(list(self.items_bottom_to_top()))


class Rpn2Stackable:
    def __init__(self, val):
        self._value = val

    def value(self):
        return self._value

    def __call__(self):
        if type(self.value()) in [Rpn2Complex, Rpn2Float, Rpn2Integer,
                                  Rpn2Matrix, Rpn2Rational, Rpn2Vector]:
            param_stack.push(self.value())
        elif type(self.value()) is Rpn2String:
            string_stack.push(self.value())
        elif type(self.value()) is Rpn2FetchVar:
            var = self.value().variable()
            if type(var) is not Rpn2Variable:
                raise Rpn2Fatal("{}: Rpn2FetchVar.value().variable ({}) is not an Rpn2Variable".format(whoami(), self.value().identifier()))
            elif var.obj() is None:
                raise RuntimeError("{}: Fetch of undefined variable {}".format(whoami(), self.value()))
            else:
                param_stack.push(var.obj())
        else:
            raise TypeError("{}: Unrecognized type: {}".format(whoami(), type(self.value().__name__)))

    def __str__(self):
        return str(self.value())

    def __repr__(self):
        return "Stackable[{}]".format(repr(self.value()))


class Rpn2StoreVar:
    def __init__(self, id, var):
        if type(var) is not Rpn2Variable:
            raise Rpn2Fatal("!{}: Variable is not an Rpn2Variable".format(id))
        self._identifier = id
        self._variable = var

    def identifier(self):
        return self._identifier

    def __call__(self):
        if param_stack.empty():
            raise RuntimeError("!{}: Insufficient parameters (1 required)".format(self.identifier()))
        self._variable.set_obj(param_stack.pop())

    def __str__(self):
        return "!{}".format(self.identifier())

    def __repr__(self):
        return "Store[{}]".format(self.identifier())


class Rpn2String:
    def __init__(self, val):
        if len(val) < 2 or val[0] != '"' or val[-1] != '"':
            raise Rpn2Fatal("{}: Malformed string: '{}'".format(whoami(), val))
        self._value = val[1:-1]

    def value(self):
        return self._value

    def set_value(self, val):
        self._value == val

    def __str__(self):
        return "\"{}\"".format(str(self.value()))

    def __repr__(self):
        return "String[{}]".format(repr(self.value()))


class Rpn2Variable:
    def __init__(self, name, obj=None, **kwargs):
        self._name = name
        self._hidden = False
        self._rpnobj = obj

        if kwargs.get("hidden"):
            self._hidden = kwargs["hidden"]
            del kwargs["hidden"]

        if len(kwargs) > 0:
            for (key, val) in kwargs.items():
                lnwriteln("{}: Unrecognized keyword '{}' ({}) in defvar".format(name, key, val))
                sys.exit(1)

    def obj(self):
        return self._rpnobj

    def set_obj(self, newobj):
        self._rpnobj = newobj

    def name(self):
        return self._name

    def defined(self):
        return self.obj() is not None

    def hidden(self):
        return self._hidden

    def __str__(self):
        return str(self._name)

    def __repr__(self):
        return "Variable[{}]".format(self._name)


class Rpn2Vector:
    def __init__(self, vals):
        if type(vals) is not Rpn2List:
            raise Rpn2Fatal("{}: vals is not an Rpn2List ({})".format(whoami(), repr(vals)))
        self._vals = vals
        np_list = []
        for item in vals.items():
            np_list.append(item.value())
        self._np_value = np.array(np_list)

    def value(self):
        return self._np_value

    def size(self):
        return len(self._vals)

    def __str__(self):
        for x in self._np_value:
            lnwriteln(str(x))
            lnwriteln(repr(x))
        return "[{}]\nNP:{}".format(self._vals, self._np_value)

    def __repr__(self):
        return "Vector[{}]\nNP:{}".format(repr(self._vals),repr(self._np_value))


class Rpn2Word:
    def __init__(self, name, defn, **kwargs):
        self._args     = 0
        self._defn     = defn
        self._doc      = None
        self._hidden   = False
        self._name     = name
        self._str_args = 0

        if defn is None:
            raise Rpn2Fatal("{}: defn is None".format(name))
        if kwargs.get("args"):
            self._args = kwargs['args']
            del kwargs["args"]
        if kwargs.get("doc"):
            self._doc = kwargs["doc"]
            del kwargs["doc"]
        if kwargs.get("hidden"):
            self._hidden = kwargs["hidden"]
            del kwargs["hidden"]
        if kwargs.get("str_args"):
            self._str_args = kwargs["str_args"]
            del kwargs["str_args"]
        if len(kwargs) > 0:
            for (key, val) in kwargs.items():
                lnwriteln("{}: Unrecognized keyword '{}' ({}) in @defword".format(name, key, val))
            sys.exit(1)

    def __call__(self):
        if param_stack.size() < self.args():
            raise RuntimeError("{}: Insufficient parameters ({} required)".format(self.name(), self.args()))
        if string_stack.size() < self.str_args():
            raise RuntimeError("{}: Insufficient string parameters ({} required)".format(self.name(), self.str_args()))

        try:
            self._defn.__call__()
        except Rpn2Exit:
            if self.name() == "exit":
                raise

    def name(self):
        return self._name

    def args(self):
        return self._args

    def str_args(self):
        return self._str_args

    def doc(self):
        return self._doc

    def hidden(self):
        return self._hidden

    def __str__(self):
        return str(self.name())

    def __repr__(self):
        return "Word[{}]".format(self.name())




#############################################################################
#
#       P A R S E   F U N C T I O N S
#
#############################################################################
start = 'interpret'

def p_interpret(p):
    '''interpret : cmd
                 | cmd interpret'''

    p[0] = Rpn2NoOp()


def p_cmd(p):
    '''cmd :  executable  execute'''

    # Don't need to return anything since `execute' does all the work
    p[0] = Rpn2NoOp()


def p_execute(p):
    '''execute : empty'''

    executable = p[-1]
    global show_x
    try:
        executable.__call__()
    except KeyboardInterrupt:
        # CTRL/C while executing returns to top level prompt
        show_x = False
        raise Rpn2TopLevel()
    except Rpn2Abort as e:
        if len(e._message) > 0:
            lnwriteln("{}".format(e))
        param_stack.clear()
        string_stack.clear()
        show_x = False
    except Rpn2Exit:
        pass
    except Rpn2Leave:
        lnwriteln("leave: Cannot be used outside of a BEGIN or DO loop")
    except RuntimeError as e:
        lnwriteln("{}".format(e))
        show_x = False
    except TypeError as e:
        lnwriteln("{}".format(e))
        w_dot_s()
        show_x = False
    except ValueError as e:
        lnwriteln("{}".format(e))
        show_x = False

    p[0] = Rpn2NoOp()


def p_sequence(p):
    '''sequence : locals_opt executables_opt'''

    # `locals_opt' is a Scope; `executables_opt' is a List
    scope = pop_scope("p_sequence() is finishing")
    p[0] = Rpn2Sequence(p[1], [], [], p[2])


def p_locals_opt(p):
    '''locals_opt :  empty
                  |  VBAR  ids_opt  VBAR'''

    scope = Rpn2Scope()
    #print("{}: Creating new scope {}".format(whoami(), scope))
    variables = Rpn2List()

    if len(p) == 4:
        variables = p[2]
        for varname in variables.items():
            var = Rpn2Variable(varname)
            #lnwriteln("{}: Defining variable {} in scope {}".format(whoami(), varname, scope))
            scope.set_variable(varname, var)

    push_scope(scope, "New sequence (locals={})".format(variables))
    p[0] = scope


def p_executables_opt(p):
    '''executables_opt :  empty
                       |  executable  executables_opt'''

    if len(p) == 2:
        p[0] = Rpn2List()
    elif len(p) == 3:
        p[0] = Rpn2List(p[1], p[2])
    # lnwriteln("{}: Returning {}".format(whoami(), p[0])))


def p_colon_def(p):
    '''colon_def :  COLON  IDENTIFIER  docstr_opt  sequence  SEMICOLON  define_word'''

    # This returns a NoOp because `define_word' does all the work
    p[0] = Rpn2NoOp()


def p_colon_def_error(p):
    '''colon_def :  COLON  IDENTIFIER  docstr_opt  error  SEMICOLON '''

    pop_scope("Syntax error in colon_def")
    p[0] = Rpn2Error("{}: Syntax error in definition".format(p[2]))


def p_define_word(p):
    '''define_word : empty'''

    sequence   = p[-2]
    doc_str    = p[-3]
    identifier = p[-4]
    # lnwriteln("{}: identifier={}  doc_str={}  sequence={}".format(whoami(), identifier, repr(doc_str), repr(sequence)))

    global parse_error
    if parse_error:
        lnwriteln("{}: Syntax error in definition".format(identifier))
        pop_scope("Syntax error in definition of {}".format(identifier))
        p[0] = Rpn2NoOp()
        return

    kwargs = dict()
    if doc_str is not None:
        if len(doc_str) < 6 or doc_str[0:5] != 'doc:"' or doc_str[-1] != '"':
            raise Rpn2Fatal("{}: Malformed doc_str: '{}'".format(whoami(), doc_str))
        doc_str = doc_str[5:-1]
        kwargs['doc'] = doc_str

    # p_sequence() has already popped the scope for this word, so
    # creating it now in scope_stack.top() will be correct.
    new_word = Rpn2Word(identifier, sequence, **kwargs)
    #lnwriteln("{}: Defining word {}={} in scope {}".format(whoami(), identifier, repr(new_word), scope_stack.top()))
    scope_stack.top().set_word(identifier, new_word)

    p[0] = new_word
    #lnwriteln("{}: Returning {}".format(whoami(), p[0]))


def p_abort_quote(p):
    '''abort_quote :  ABORT_QUOTE'''

    p[0] = Rpn2AbortQuote(p[1])


def p_begin_again(p):
    '''begin_again :  BEGIN  sequence  AGAIN'''

    p[0] = Rpn2BeginAgain(p[2])


def p_begin_until(p):
    '''begin_until :  BEGIN  sequence  UNTIL'''

    p[0] = Rpn2BeginUntil(p[2])


def p_begin_while(p):
    '''begin_while :  BEGIN  sequence  WHILE  sequence  REPEAT'''

    p[0] = Rpn2BeginWhile(p[2], p[4])


def p_docstr_opt(p):
    '''docstr_opt :  empty
                  |  DOC_STR'''

    p[0] = p[1]


def p_case(p):
    '''case :  CASE  case_clauses  otherwise_opt  ENDCASE'''
    p[0] = Rpn2Case(p[2], p[3])

def p_case_clause(p):
    '''case_clause : INTEGER  OF  sequence  ENDOF'''
    p[0] = Rpn2CaseClause(p[1], p[3])

def p_case_clauses(p):
    '''case_clauses :  case_clause
                    |  case_clause  case_clauses'''
    if len(p) == 2:
        p[0] = Rpn2List(p[1])
    else:
        p[0] = Rpn2List(p[1], p[2])

def p_otherwise_opt(p):
    '''otherwise_opt : empty
                     | OTHERWISE  sequence'''
    if len(p) == 2:
        p[0] = Rpn2List()
    else:
        p[0] = Rpn2List(p[2])

def p_complex(p):
    '''complex :  OPEN_PAREN  real  COMMA  real  CLOSE_PAREN '''
    p[0] = Rpn2Complex(p[2].value(), p[4].value())


def p_do_loop(p):
    '''do_loop :  DO  sequence  LOOP'''

    p[0] = Rpn2DoLoop(p[2])


def p_do_plusloop(p):
    '''do_plusloop :  DO  sequence  PLUS_LOOP'''

    p[0] = Rpn2DoPlusLoop(p[2])


def p_dot_quote(p):
    '''dot_quote :  DOT_QUOTE'''

    p[0] = Rpn2DotQuote(p[1])


def p_empty(p):
    '''empty :'''

    pass


def p_error(p):
    global parse_error
    if p is None:
        #lnwriteln("{}(None): End of file".format(whoami()))
        parser.restart()
    else:
        #lnwriteln("{}({})".format(whoami(), p))
        lnwriteln("'{}' not valid here".format(p.value))
        parse_error = True
        parser.restart()

    # What to do?
    #parser.restart()
    #parser.errok()


def p_executable(p):
    '''executable :  abort_quote
                  |  begin_again
                  |  begin_until
                  |  begin_while
                  |  case
                  |  colon_def
                  |  do_loop
                  |  do_plusloop
                  |  dot_quote
                  |  help
                  |  if_then
                  |  if_else_then
                  |  stackable
                  |  store_var
                  |  word'''

    # A "word" is not just an identifier, a word is something that is
    # findable somewhere in the scope_stack.  It is a syntax error if
    # the identifier is not found.
    p[0] = Rpn2Exe(p[1])


def p_fetch_var(p):
    '''fetch_var :  AT_SIGN  IDENTIFIER'''

    global parse_error
    id = p[2]
    # lnwriteln("{}: Looking up {}".format(whoami(), id))
    var = lookup_variable(id)
    if var is None:
        lnwriteln("@{}: Variable not found".format(id))
        parse_error = True
        raise SyntaxError
    p[0] = Rpn2FetchVar(id, var)


def p_float(p):
    '''float :  FLOAT'''

    p[0] = Rpn2Float(p[1])


def p_help(p):
    '''help :  HELP  AGAIN
            |  HELP  BEGIN
            |  HELP  CASE
            |  HELP  COLON
            |  HELP  DO
            |  HELP  DOT_QUOTE
            |  HELP  ELSE
            |  HELP  ENDCASE
            |  HELP  ENDOF
            |  HELP  HELP
            |  HELP  IDENTIFIER
            |  HELP  IF
            |  HELP  LOOP
            |  HELP  OF
            |  HELP  OTHERWISE
            |  HELP  PLUS_LOOP
            |  HELP  REPEAT
            |  HELP  SEMICOLON
            |  HELP  THEN
            |  HELP  UNTIL
            |  HELP  WHILE'''

    global parse_error
    name = p[2]
    word = lookup_word(name)
    if word is None:
        # throw a parse error
        lnwriteln("help: '{}' not found".format(name))
        parse_error = True
        raise SyntaxError
    else:
        p[0] = Rpn2Help(name, word.doc() if word.doc() is not None \
                                        and len(word.doc()) > 0 \
                        else "No help available for '{}'".format(name))


def p_ids_opt(p):
    '''ids_opt :  empty
              |  IDENTIFIER  ids_opt'''

    if len(p) == 2:
        p[0] = Rpn2List()
    elif len(p) == 3:
        p[0] = Rpn2List(p[1], p[2])


def p_if_then(p):
    '''if_then :  IF  sequence  THEN'''

    p[0] = Rpn2If(p[2])


def p_if_else_then(p):
    '''if_else_then :  IF  sequence  ELSE  sequence  THEN'''

    p[0] = Rpn2IfElse(p[2], p[4])


def p_integer(p):
    '''integer :  INTEGER'''

    p[0] = Rpn2Integer(p[1])


def p_matrix(p):
    '''matrix :  OPEN_BRACKET  vectors  CLOSE_BRACKET'''

    p[0] = Rpn2Matrix(p[2])


def p_number(p):
    '''number :  real
              |  rational
              |  complex'''

    p[0] = p[1]


def p_numbers(p):
    '''numbers :  number
               |  number  numbers'''

    if len(p) == 2:
        p[0] = Rpn2List(p[1])
    elif len(p) == 3:
        p[0] = Rpn2List(p[1], p[2])


def p_rational(p):
    '''rational :  integer  TILDE  integer'''

    p[0] = Rpn2Rational(p[1].value(), p[3].value())


def p_real(p):
    '''real :  integer
            |  float'''

    p[0] = p[1]


def p_stackable(p):
    '''stackable :  number
                 |  string
                 |  vector
                 |  matrix
                 |  fetch_var'''

    p[0] = Rpn2Stackable(p[1])


def p_store_var(p):
    '''store_var :  EXCLAM  IDENTIFIER'''

    global parse_error
    id = p[2]
    #lnwriteln("{}: Looking up {}".format(whoami(), id))
    var = lookup_variable(id)
    if var is None:
        lnwriteln("!{}: Variable not found".format(id))
        parse_error = True
        raise SyntaxError
    p[0] = Rpn2StoreVar(id, var)


def p_string(p):
    '''string :  STRING'''

    p[0] = Rpn2String(p[1])


def p_vector(p):
    '''vector :  OPEN_BRACKET  numbers  CLOSE_BRACKET'''

    p[0] = Rpn2Vector(p[2])


def p_vectors(p):
    '''vectors :  vector
               |  vector  vectors'''

    lnwriteln("{}: len={}".format(whoami(), len(p)))
    if len(p) == 2:
        p[0] = Rpn2List(p[1])
    elif len(p) == 3:
        p[0] = Rpn2List(p[1], p[2])


def p_word(p):
    '''word :  IDENTIFIER'''

    global parse_error
    name = p[1]
    word = lookup_word(name)
    if word is None:
        # throw a parse error
        #lnwriteln("{}: Word '{}' not found".format(whoami(), name))
        lnwriteln("{}: Word not found".format(name))
        parse_error = True
        raise SyntaxError
    else:
        p[0] = word




#############################################################################
#
#       W O R D   D E F I N I T I O N S
#
#############################################################################
global_scope = Rpn2Scope()

class defword(object):
    """Register the following word definition in the global scope"""

    def __init__(self, **kwargs):
        self._kwargs = kwargs

    def __call__(self, f):
        def wrapped_f(**kwargs):
            #print("Decorator args: {}".format(self._kwargs))
            f()
        if "name" in self._kwargs and len(self._kwargs["name"]) > 0:
            name = self._kwargs["name"]
            del self._kwargs["name"]
        else:
            raise RuntimeError("Missing or invalid \"name\" attribute")
        #print("name is {}".format(name))
        word = Rpn2Word(name, wrapped_f, **self._kwargs)
        global global_scope
        global_scope.set_word(name, word)
        return wrapped_f


@defword(name='$.', str_args=1, doc="""\
Print top item from string stack  [ str -- ]
No extraneous white space is printed.""")
def w_dollar_dot():
    write(string_stack.pop().value())


@defword(name='$.!', str_args=1)
def w_dollar_dot_bang():
    lnwriteln(repr(string_stack.top()))


@defword(name='$.s', doc="""\
Display string stack.""")
def w_dollar_dot_s():
    for (i, item) in string_stack.items_bottom_to_top():
        lnwriteln("{}: {}".format(i, item.value()))


@defword(name='$.s!')
def w_dollar_dot_s_bang():
    for (i, item) in string_stack.items_bottom_to_top():
        lnwriteln("{}: {}".format(i, repr(item)))


@defword(name='%', args=2, doc="""\
Percentage  ( base rate -- base percent )

Base is maintained in Y.

DEFINTION:
                 rate
percent = base * ----
                  100""")
def w_percent():
    x = param_stack.pop()
    y = param_stack.pop()
    if     type(x) in [Rpn2Integer, Rpn2Rational, Rpn2Float] \
       and type(y) in [Rpn2Integer, Rpn2Rational, Rpn2Float]:
        rate = float(x.value())
        base = float(y.value())
        r = base * rate / 100.0
        if type(x) is Rpn2Integer and type(y) is Rpn2Integer and r.is_integer():
            result = Rpn2Integer(r)
        else:
            result = Rpn2Float(r)
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("%: Type error ({}, {})".format(type(y).__name__, type(x).__name__))
    param_stack.push(y)
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='%ch', args=2, doc="""\
Percentage change  ( old new -- %change )

DEFINITION:

          new - old
%change = --------- * 100
             old

old cannot be zero.""")
def w_percent_ch():
    x = param_stack.pop()
    y = param_stack.pop()
    if     type(x) in [Rpn2Integer, Rpn2Rational, Rpn2Float] \
       and type(y) in [Rpn2Integer, Rpn2Rational, Rpn2Float]:
        if y.zerop():
            param_stack.push(y)
            param_stack.push(x)
            raise ValueError("%ch: Y cannot be zero")
        else:
            new = float(x.value())
            old = float(y.value())
            r = (new - old) * 100.0 / old
            if type(x) is Rpn2Integer and type(y) is Rpn2Integer and r.is_integer():
                result = Rpn2Integer(r)
            else:
                result = Rpn2Float(r)
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("%ch: Type error ({}, {})".format(type(y).__name__, type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='*', args=2, doc="""\
Multiplication  ( y x -- y*x )""")
def w_star():
    """\
|----------+----------+---------+----------+---------+--------+--------|
| Integer  | Integer  | Float   | Rational | Complex |        |        |
| Float    | Float    | Float   | Float    | Complex |        |        |
| Rational | Rational | Float   | Rational | Complex |        |        |
| Complex  | Complex  | Complex | Complex  | Complex |        |        |
| Vector   |          |         |          |         |        |        |
| Matrix   |          |         |          |         |        |        |
|----------+----------+---------+----------+---------+--------+--------|
| ^Y    X> | Integer  | Float   | Rational | Complex | Vector | Matrix |"""
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is Rpn2Integer and type(y) is Rpn2Integer:
        result = Rpn2Integer(y.value() * x.value())
    elif    type(x) is Rpn2Float and type(y) in [Rpn2Integer, Rpn2Float, Rpn2Rational] \
         or type(y) is Rpn2Float and type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational]:
        result = Rpn2Float(float(y.value()) * float(x.value()))
    elif    type(x) is Rpn2Rational and type(y) in [Rpn2Integer, Rpn2Rational] \
         or type(y) is Rpn2Rational and type(x) in [Rpn2Integer, Rpn2Rational]:
        result = Rpn2Rational.from_Fraction(y.value() * x.value())
    elif    type(x) is Rpn2Complex and type(y) in [Rpn2Integer, Rpn2Float, Rpn2Rational, Rpn2Complex] \
         or type(y) is Rpn2Complex and type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational, Rpn2Complex]:
        result = Rpn2Complex.from_complex(complex(y.value()) * complex(x.value()))
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("+: Type error ({}, {})".format(type(y).__name__, type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='+', args=2, doc="""\
Addition  ( y x -- y+x )""")
def w_plus():
    """\
|----------+----------+---------+----------+---------+--------+--------|
| Integer  | Integer  | Float   | Rational | Complex |        |        |
| Float    | Float    | Float   | Float    | Complex |        |        |
| Rational | Rational | Float   | Rational | Complex |        |        |
| Complex  | Complex  | Complex | Complex  | Complex |        |        |
| Vector   |          |         |          |         |        |        |
| Matrix   |          |         |          |         |        |        |
|----------+----------+---------+----------+---------+--------+--------|
| ^Y    X> | Integer  | Float   | Rational | Complex | Vector | Matrix |"""
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is Rpn2Integer and type(y) is Rpn2Integer:
        result = Rpn2Integer(y.value() + x.value())
    elif    type(x) is Rpn2Float and type(y) in [Rpn2Integer, Rpn2Float, Rpn2Rational] \
         or type(y) is Rpn2Float and type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational]:
        result = Rpn2Float(float(y.value()) + float(x.value()))
    elif    type(x) is Rpn2Rational and type(y) in [Rpn2Integer, Rpn2Rational] \
         or type(y) is Rpn2Rational and type(x) in [Rpn2Integer, Rpn2Rational]:
        result = Rpn2Rational.from_Fraction(y.value() + x.value())
    elif    type(x) is Rpn2Complex and type(y) in [Rpn2Integer, Rpn2Float, Rpn2Rational, Rpn2Complex] \
         or type(y) is Rpn2Complex and type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational, Rpn2Complex]:
        result = Rpn2Complex.from_complex(complex(y.value()) + complex(x.value()))
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("+: Type error ({}, {})".format(type(y).__name__, type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='+loop', doc="""\
Execute a definite loop.
<limit> <initial> DO xxx <incr> +LOOP

The iteration counter is available via I.  LEAVE will exit the loop early.

Example: 10 0 do I . 2 +loop
prints 0 2 4 6 8

qv DO, I, LEAVE, LOOP""")
def w_plusloop():
    pass                        # Grammar rules handle this word


@defword(name='-', args=2, doc="""\
Subtraction  ( y x -- y-x )""")
def w_minus():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is Rpn2Integer and type(y) is Rpn2Integer:
        result = Rpn2Integer(y.value() - x.value())
    elif    type(x) is Rpn2Float and type(y) in [Rpn2Integer, Rpn2Float, Rpn2Rational] \
         or type(y) is Rpn2Float and type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational]:
        result = Rpn2Float(float(y.value()) - float(x.value()))
    elif    type(x) is Rpn2Rational and type(y) in [Rpn2Integer, Rpn2Rational] \
         or type(y) is Rpn2Rational and type(x) in [Rpn2Integer, Rpn2Rational]:
        result = Rpn2Rational.from_Fraction(y.value() - x.value())
    elif    type(x) is Rpn2Complex and type(y) in [Rpn2Integer, Rpn2Float, Rpn2Rational, Rpn2Complex] \
         or type(y) is Rpn2Complex and type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational, Rpn2Complex]:
        result = Rpn2Complex.from_complex(complex(y.value()) - complex(x.value()))
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("-: Type error ({}, {})".format(type(y).__name__, type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='-rot', args=3, doc="""\
Rotate back top stack element to third spot,
pulling others down  ( z y x -- x z y )
Equivalent to ROT ROT""")
def w_minus_rot():
    x = param_stack.pop()
    y = param_stack.pop()
    z = param_stack.pop()
    param_stack.push(x)
    param_stack.push(z)
    param_stack.push(y)


@defword(name='.', args=1)
def w_dot():
    write("{} ".format(str(param_stack.pop())))


@defword(name='.!', args=1)
def w_dot_bang():
    lnwriteln(repr(param_stack.top()))


@defword(name='.s')
def w_dot_s():
    for (i, item) in param_stack.items_bottom_to_top():
        lnwriteln("{}: {}".format(i, item))


@defword(name='.s!')
def w_dot_s_bang():
    for (i, item) in param_stack.items_bottom_to_top():
        lnwriteln("{}: {}".format(i, repr(item)))


@defword(name='/', args=2, doc="""\
Division  ( y x -- y/x )
X cannot be zero.""")
def w_slash():
    """\
|----------+----------+---------+----------+---------+--------+--------|
| Integer  | Float    | Float   | Rational | Complex |        |        |
| Float    | Float    | Float   | Float    | Complex |        |        |
| Rational | Rational | Float   | Rational | Complex |        |        |
| Complex  | Complex  | Complex | Complex  | Complex |        |        |
| Vector   |          |         |          |         |        |        |
| Matrix   |          |         |          |         |        |        |
|----------+----------+---------+----------+---------+--------+--------|
| ^Y    X> | Integer  | Float   | Rational | Complex | Vector | Matrix |"""
    x = param_stack.pop()
    y = param_stack.pop()

    if     type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational, Rpn2Complex] \
       and x.zerop():
        param_stack.push(y)
        param_stack.push(x)
        raise ValueError("/: Argument cannot be zero")

    if    type(x) is Rpn2Rational and type(y) in [Rpn2Integer, Rpn2Rational] \
       or type(y) is Rpn2Rational and type(x) in [Rpn2Integer, Rpn2Rational]:
        result = Rpn2Rational.from_Fraction(y.value() / x.value())
    elif    type(x) in [Rpn2Integer, Rpn2Float] and type(y) in [Rpn2Integer, Rpn2Float] \
         or type(x) is Rpn2Rational and type(y) is Rpn2Float \
         or type(y) is Rpn2Rational and type(x) is Rpn2Float:
        r = float(y.value()) / float(x.value())
        if type(x) is Rpn2Integer and type(y) is Rpn2Integer and r.is_integer():
            result = Rpn2Integer(r)
        else:
            result = Rpn2Float(r)
    elif    type(x) is Rpn2Complex and type(y) in [Rpn2Integer, Rpn2Float, Rpn2Rational, Rpn2Complex] \
         or type(y) is Rpn2Complex and type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational, Rpn2Complex]:
        result = Rpn2Complex.from_complex(complex(y.value()) / complex(x.value()))
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("/: Type error ({}, {})".format(type(y).__name__, type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='0=', args=1)
def w_zero_equal():
    x = param_stack.pop()
    if type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational, Rpn2Complex]:
        param_stack.push(Rpn2Integer(1 if x.zerop() else 0))
        global show_x
        show_x = True
    else:
        param_stack.push(x)
        raise RuntimeError("0=: Type error ({})".format(type(x).__name__))


@defword(name=':', doc="""\
Define a new word  ( -- )
: WORD  [def ...] ;

Define WORD with the specified definition.
Terminate the definition with a semi-colon.""")
def w_colon():
    pass                        # Grammar rules handle this word


@defword(name=';', doc="""\
Terminate WORD definition  ( -- )
: WORD  [def ...] ;""")
def w_semicolon():
    pass                        # Grammar rules handle this word


@defword(name='=', args=2)
def w_equal():
    """\
|----------+----------+---------+----------+---------+--------+--------|
| Integer  |   xxxx   |  xxx    |  xxxx    | xxxx    |        |        |
| Float    |   xxxxx  |  xxx    |   xxxx   | xxx     |        |        |
| Rational |   xxxx   |  xxx    |  xxxxx   | xxxx    |        |        |
| Complex  |    xxxx  |  xxx    |   xxx    | xxx     |        |        |
| Vector   |          |         |          |         |        |        |
| Matrix   |          |         |          |         |        |        |
|----------+----------+---------+----------+---------+--------+--------|
| ^Y    X> | Integer  | Float   | Rational | Complex | Vector | Matrix |"""
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is Rpn2Integer and type(y) is Rpn2Integer:
        flag = y.value() == x.value()
    elif    type(x) is Rpn2Float and type(y) in [Rpn2Integer, Rpn2Float, Rpn2Rational] \
         or type(y) is Rpn2Float and type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational]:
        flag = float(y.value()) == float(x.value()) # Beware floating point equality lossage
    elif    type(x) is Rpn2Rational and type(y) in [Rpn2Integer, Rpn2Rational] \
         or type(y) is Rpn2Rational and type(x) in [Rpn2Integer, Rpn2Rational]:
        flag = Fraction(y.value()) == Fraction(x.value())
    elif    type(x) is Rpn2Complex and type(y) in [Rpn2Integer, Rpn2Float, Rpn2Rational, Rpn2Complex] \
         or type(y) is Rpn2Complex and type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational, Rpn2Complex]:
        flag = complex(y.value()) == complex(x.value())
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("=: Type error ({}, {})".format(type(y).__name__, type(x).__name__))
    param_stack.push(Rpn2Integer(1 if flag else 0))
    global show_x
    show_x = True


@defword(name='>r', args=1, doc="""\
Push X onto return stack  ( x -- )""")
def w_to_r():
    return_stack.push(param_stack.pop())


@defword(name='?dup', args=1, doc="""\
Duplicate top stack element if non-zero  ( x -- x x | 0 )""")
def w_query_dup():
    x = param_stack.top()
    if type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational, Rpn2Complex]:
        if not x.zerop():
            w_dup()
    else:
        param_stack.push(x)
        raise TypeError("?dup: Type error ({})".format(type(x).__name__))


@defword(name='abort', doc="""\
Abort execution and return to top level""")
def w_abort():
    raise Rpn2Abort()


@defword(name='abort"', doc="""\
Conditionally abort execution  ( f -- )
If flag is non-zero, abort execution and print a message
(up to the closing quotation mark) and return to top level""")
def w_abort_quote():
    pass                        # Grammar rules handle this word


@defword(name='abs', doc="""\
Absolute value  ( x -- abs )

NOTE: For complex numbers, ABS return the modulus (float).""")
def w_abs():
    x = param_stack.pop()
    if type(x) is Rpn2Integer:
        result = Rpn2Integer(abs(x.value()))
    elif type(x) in [Rpn2Float, Rpn2Complex]:
        result = Rpn2Float(abs(x.value()))
    elif type(x) is Rpn2Rational:
        result = Rpn2Rational.from_Fraction(abs(x.value()))
    else:
        param_stack.push(x)
        raise TypeError("abs: Type error ({})".format(type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='again', doc="""\
Execute an indefinite loop forever.
BEGIN xxx AGAIN

LEAVE will exit the loop early.

qv BEGIN, LEAVE, REPEAT, UNTIL, WHILE""")
def w_again():
    pass                        # Grammar rules handle this word


@defword(name='begin', doc="""\
Execute an indefinite loop.
BEGIN xxx AGAIN
BEGIN xxx <flag> UNTIL
BEGIN xxx <flag> WHILE yyy REPEAT

LEAVE will exit the loop early.  Note that the effect of the test in
BEGIN...WHILE is opposite that in BEGIN...UNTIL.  The loop repeats
while something is true, rather than until it becomes true.

Do not confuse this with the BEG command, which sets "begin mode" for
Time Value of Money calculations.

qv AGAIN, LEAVE, REPEAT, UNTIL, WHILE""")
def w_begin():
    pass                        # Grammar rules handle this word


@defword(name='bye', doc="""\
Exit program""")
def w_bye():
    raise Rpn2EndProgram()


@defword(name='case', doc="""\
Execute a sequence of words based on stack value.  Once a match is
executed, no other clauses are considered.  OTHERWISE is optional.
<n> and OF labels must be integers.

<n> CASE
  <x> OF xxx ENDOF
  <y> OF yyy ENDOF
  <z> OF zzz ENDOF
  [ OTHERWISE aaa ]
ENDCASE

qv ENDCASE, ENDOF, OF, OTHERWISE
""")
def w_case():
    pass                        # Grammar rules handle this word


@defword(name='ceil', doc="""\
Ceiling  ( x -- ceil )   Smallest integer greater than or equal to X""")
def w_ceil():
    x = param_stack.pop()
    if type(x) is Rpn2Integer:
        result = x
    elif type(x) in [Rpn2Float, Rpn2Rational]:
        result = Rpn2Integer(math.ceil(x.value()))
    else:
        param_stack.push(x)
        raise TypeError("ceil: Type error ({})".format(type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='cf', args=1)
def w_cf():
    x = param_stack.pop()
    if type(x) is Rpn2Integer:
        if x.value() < 0 or x.value() >= flag_max:
            param_stack.push(x)
            raise ValueError("cf: Argument out of range (0..{} expected)".format(flag_max))
        flag_clear(x.value())
    else:
        param_stack.push(x)
        raise TypeError("cf: Type error ({})".format(type(x).__name__))


@defword(name='chs', args=1, doc="""\
Change sign  ( x -- -x )""")
def w_chs():
    x = param_stack.pop()
    if type(x) is Rpn2Integer:
        result = Rpn2Integer(-1 * x.value())
    elif type(x) is Rpn2Float:
        result = Rpn2Float(-1.0 * x.value())
    elif type(x) is Rpn2Rational:
        result = Rpn2Rational.from_Fraction(Fraction(-1,1) * x.value())
    elif type(x) is Rpn2Complex:
        result = Rpn2Complex(-1.0*x.real(), -1.0*x.imag())
    else:
        param_stack.push(x)
        raise TypeError("chs: Type error ({})".format(type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='clflag', doc="""\
Clear all flags  ( -- )""")
def w_clflag():
    global flags_vec
    flags_vec = 0


@defword(name='clst', doc="""\
Clear the stack""")
def w_clst():
    param_stack.clear()


@defword(name='comb', args=2, doc="""\
Combinations  ( n r -- nCr )
Choose from N objects R at a time, without regard to ordering.

DEFINITION:
          n!
nCr = -----------
      r! * (n-r)!""")
def w_comb():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is Rpn2Integer and type(y) is Rpn2Integer:
        # Python 3.8 has math.comb()
        result = Rpn2Integer(choose_helper(y.value(), x.value()))
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("comb: Type error ({}, {})".format(type(y).__name__, type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='cos', args=1, doc="""\
Cosine  ( angle -- cosine )""")
def w_cos():
    x = param_stack.pop()
    if type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational]:
        result = Rpn2Float(math.cos(convert_mode_to_radians(float(x.value()))))
    elif type(x) is Rpn2Complex:
        result = Rpn2Complex.from_complex(cmath.cos(x.value()))
    else:
        param_stack.push(x)
        raise TypeError("cos: Type error ({})".format(type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='cr', doc="""\
Print a newline""")
def w_cr():
    writeln()


@defword(name='d->r', args=1, doc="""\
Convert degrees to radians ( deg -- rad )""")
def w_d_to_r():
    x = param_stack.pop()
    if type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational]:
        result = Rpn2Float(convert_mode_to_radians(float(x.value()), "d"))
    else:
        param_stack.push(x)
        raise TypeError("d->r: Type error ({})".format(type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='debug', hidden=True)
def w_debug():
    global rpn_debug
    if rpn_debug:
        rpn_debug = False
    else:
        rpn_debug = True
    lnwriteln("debug: Debugging is now {}".format(rpn_debug))


@defword(name='deg', doc="""\
Set angular mode to degrees""")
def w_deg():
    global angle_mode
    angle_mode = "d"


@defword(name='deg?')
def w_deg_query():
    global angle_mode
    param_stack.push(Rpn2Integer(1 if angle_mode == "d" else 0))
    global show_x
    show_x = True


@defword(name='depth', doc="""\
Return current number of elements on stack  ( -- n )""")
def w_depth():
    param_stack.push(Rpn2Integer(param_stack.size()))
    global show_x
    show_x = True


@defword(name='dim', args=1, doc="""\
Dimension(s) of X.

For integers, floats, and rationals (scalars), return 0.
For complex numbers, return 2.
For vectors of length N, return a vector [ N ].
For an M-row by N-col matrix, return a vector [ M N ].""")
def w_dim():
    x = param_stack.pop()
    if type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational]:
        result = Rpn2Integer(0)
    elif type(x) is Rpn2Complex:
        result = Rpn2Integer(2)
    elif type(x) is Rpn2Vector:
        result = Rpn2Vector(Rpn2List(Rpn2Integer(x.size()))) # [ len(x) ]
    elif type(x) is Rpn2Matrix:
        # Pretty ugly.  Need a better method to append items.  Ugh,
        # things get added at the beginning of the list, so we have to
        # add the cols, THEN the rows in order to end up with
        # [ rows cols ].
        l = Rpn2List(Rpn2Integer(x.ncols()))
        l2 = Rpn2List(Rpn2Integer(x.nrows()), l)
        result = Rpn2Vector(l2) # [ rows cols ]
    else:
        param_stack.push(x)
        raise TypeError("dim: Type error ({})".format(type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='do', doc="""\
Execute a definite loop.
<limit> <initial> DO xxx        LOOP
<limit> <initial> DO xxx <incr> +LOOP

The iteration counter is available via I.  LEAVE will exit the loop early.

Example: 10 0 do I . loop
prints 0 1 2 3 4 5 6 7 8 9

qv I, LEAVE, LOOP, +LOOP""")
def w_do():
    pass                        # Grammar rules handle this word


@defword(name='drop', args=1, doc="""\
Remove top stack element  ( x -- )""")
def w_drop():
    param_stack.pop()


@defword(name='dup', args=1, doc="""\
Duplicate top stack element  ( x -- x x )
Equivalent to 0 PICK""")
def w_dup():
    x = param_stack.pop()
    param_stack.push(x)
    param_stack.push(x)


@defword(name='E', doc="""\
Constant: Base of natural logarithms ( -- 2.71828... )""")
def w_E():
    param_stack.push(Rpn2Float(E))
    global show_x
    show_x = True


@defword(name='else', args=1, doc="""\
Execute a conditional test.  xxx is executed if <flag> is non-zero,
otherwise yyy is executed.
<flag> IF xxx [ ELSE yyy ] THEN

qv IF, THEN""")
def w_else():
    pass                        # Grammar rules handle this word


@defword(name='emit', args=1, doc="""\
emit  ( x -- )    Print a single ASCII character
No space or newline is appended.""")
def w_emit():
    x = param_stack.pop()
    if type(x) is not Rpn2Integer:
        param_stack.push(x)
        raise TypeError("emit: Type error ({})".format(type(x).__name__))
    write(chr(x.value()))


@defword(name='endcase', doc="""\
Execute a sequence of words based on stack value.  Once a match is
executed, no other clauses are considered.  OTHERWISE is optional.
<n> and OF labels must be integers.

<n> CASE
  <x> OF xxx ENDOF
  <y> OF yyy ENDOF
  <z> OF zzz ENDOF
  [ OTHERWISE aaa ]
ENDCASE

qv CASE, ENDOF, OF, OTHERWISE
""")
def w_endcase():
    pass                        # Grammar rules handle this word


@defword(name='endof', doc="""\
Execute a sequence of words based on stack value.  Once a match is
executed, no other clauses are considered.  OTHERWISE is optional.
<n> and OF labels must be integers.

<n> CASE
  <x> OF xxx ENDOF
  <y> OF yyy ENDOF
  <z> OF zzz ENDOF
  [ OTHERWISE aaa ]
ENDCASE

qv CASE, ENDCASE, OF, OTHERWISE
""")
def w_endof():
    pass                        # Grammar rules handle this word


@defword(name='eval', str_args=1)
def w_eval():
    s = string_stack.pop().value()
    eval_string(s)


@defword(name='exit', doc="""\
Terminate execution of current word""")
def w_exit():
    raise Rpn2Exit()


@defword(name='exp', args=1, doc="""\
Natural exponential ( x -- e^x )""")
def w_exp():
    x = param_stack.pop()
    if type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational]:
        result = Rpn2Float(math.exp(float(x.value())))
    elif type(x) is Rpn2Complex:
        result = Rpn2Complex.from_complex(cmath.exp(complex(x.value())))
    else:
        param_stack.push(x)
        raise TypeError("exp: Type error ({})".format(type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='fact', args=1, doc="""\
Factorial ( x -- x! )

DEFINITION:
x! = x * (x-1) * (x-2) ... * 2 * 1
0! = 1
X cannot be negative.""")
def w_fact():
    x = param_stack.pop()
    if type(x) is Rpn2Integer:
        if x.value() < 0:
            param_stack.push(x)
            raise ValueError("fact: Argument cannot be negative")
        result = Rpn2Integer(fact_helper(x.value()))
    else:
        param_stack.push(x)
        raise TypeError("fact: Type error ({})".format(type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='FALSE')
def w_FALSE():
    param_stack.push(Rpn2Integer(0))
    global show_x
    show_x = True


@defword(name='fc?', args=1)
def w_fc_query():
    x = param_stack.pop()
    if type(x) is Rpn2Integer:
        if x.value() < 0 or x.value() >= flag_max:
            param_stack.push(x)
            raise ValueError("fc?: Argument out of range (0..{} expected)".format(flag_max))
        result = Rpn2Integer(0 if flag_test(x.value()) else 1)
    else:
        param_stack.push(x)
        raise TypeError("fc?: Type error ({})".format(type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='floor', doc="""\
Floor  ( x -- floor )   Largest integer not greater than X""")
def w_floor():
    x = param_stack.pop()
    if type(x) is Rpn2Integer:
        result = x
    elif type(x) in [Rpn2Float, Rpn2Rational]:
        result = Rpn2Integer(math.floor(x.value()))
    else:
        param_stack.push(x)
        raise TypeError("floor: Type error ({})".format(type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='fs?', args=1)
def w_fs_query():
    x = param_stack.pop()
    if type(x) is Rpn2Integer:
        if x.value() < 0 or x.value() >= flag_max:
            param_stack.push(x)
            raise ValueError("fs?: Argument out of range (0..{} expected)".format(flag_max))
        result = Rpn2Integer(1 if flag_test(x.value()) else 0)
    else:
        param_stack.push(x)
        raise TypeError("fs?: Type error ({})".format(type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='i', doc="""\
Imaginary unit (0,1)  ( -- i )

DEFINITION:
i = sqrt(-1)

Do not confuse this with the I command, which returns the index for a DO loop.""")
def w_i():
    param_stack.push(Rpn2Complex(0,1))
    global show_x
    show_x = True


@defword(name='I', doc="""\
Index of DO loop  ( -- x )

Return the index of the most recent DO loop.

Do not confuse this with the i command, which returns the complex number (0,1).""")
def w_I():
    _I = lookup_variable('_I')
    if _I is None:
        raise RuntimeError("'I' not valid here, only in DO loops")
    elif type(_I.obj()) is not Rpn2Integer:
        raise FatalError("I is not an Rpn2Integer")
    else:
        param_stack.push(_I.obj())


@defword(name='if', args=1, doc="""\
Test condition  ( f -- )
Execute a conditional test.  xxx is executed if <flag> is non-zero.
<flag> IF xxx [ ELSE yyy ] THEN

qv ELSE, THEN""")
def w_if():
    pass                        # Grammar rules handle this word


@defword(name='leave', doc="""\
Exit a DO or BEGIN loop immediately.""")
def w_leave():
    raise Rpn2Leave


@defword(name='lg', args=1, doc="""\
Logarithm [base 2]  ( x -- lg )
X cannot be zero.
Use "ln" for the natural logarithm, and "log" for the common logarithm.""")
def w_lg():
    x = param_stack.pop()
    if     type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational, Rpn2Complex] \
       and x.zerop():
        param_stack.push(x)
        raise ValueError("lg: Argument cannot be zero")

    if    type(x) is Rpn2Integer  and x.value() > 0 \
       or type(x) is Rpn2Float    and x.value() > 0.0 \
       or type(x) is Rpn2Rational and x.value() > 0:
        r = Rpn2Float(math.log2(float(x.value())))
        if type(x) is Rpn2Integer and r.is_integer():
            result = Rpn2Integer(r)
        else:
            result = Rpn2Float(r)
    elif    type(x) is Rpn2Complex \
         or type(x) is Rpn2Integer  and x.value() < 0 \
         or type(x) is Rpn2Float    and x.value() < 0.0 \
         or type(x) is Rpn2Rational and x.value() < 0:
        result = Rpn2Complex.from_complex(cmath.log(complex(x.value()), 2))
    else:
        param_stack.push(x)
        raise TypeError("lg: Type error ({})".format(type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='ln', args=1, doc="""\
Natural logarithm [base e]  ( x -- ln )
X cannot be zero.
Use "log" for the common (base 10) logarithm.""")
def w_ln():
    x = param_stack.pop()
    if     type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational, Rpn2Complex] \
       and x.zerop():
        param_stack.push(x)
        raise ValueError("ln: Argument cannot be zero")

    if    type(x) is Rpn2Integer  and x.value() > 0 \
       or type(x) is Rpn2Float    and x.value() > 0.0 \
       or type(x) is Rpn2Rational and x.value() > 0:
        result = Rpn2Float(math.log(float(x.value())))
    elif    type(x) is Rpn2Complex \
         or type(x) is Rpn2Integer  and x.value() < 0 \
         or type(x) is Rpn2Float    and x.value() < 0.0 \
         or type(x) is Rpn2Rational and x.value() < 0:
        result = Rpn2Complex.from_complex(cmath.log(complex(x.value())))
    else:
        param_stack.push(x)
        raise TypeError("ln: Type error ({})".format(type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='load', str_args=1, doc="""\
Load file specified on string stack  [ file -- ]""")
def w_load():
    filename = string_stack.pop().value()
    if not os.path.isfile(filename):
        lnwriteln("load: \"{}\" is not a valid file".format(filename))
    else:
        load_file(filename)


@defword(name='log', args=1, doc="""\
Common logarithm [base 10]  ( x -- log )
X cannot be zero.
Use "ln" for the natural (base e) logarithm.""")
def w_log():
    x = param_stack.pop()
    if     type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational, Rpn2Complex] \
       and x.zerop():
        param_stack.push(x)
        raise ValueError("log: Argument cannot be zero")

    if    type(x) is Rpn2Integer  and x.value() > 0 \
       or type(x) is Rpn2Float    and x.value() > 0.0 \
       or type(x) is Rpn2Rational and x.value() > 0:
        r = math.log10(float(x.value()))
        if type(x) is Rpn2Integer and r.is_integer():
            result = Rpn2Integer(r)
        else:
            result = Rpn2Float(r)
    elif    type(x) is Rpn2Complex \
         or type(x) is Rpn2Integer  and x.value() < 0 \
         or type(x) is Rpn2Float    and x.value() < 0.0 \
         or type(x) is Rpn2Rational and x.value() < 0:
        result = Rpn2Complex.from_complex(cmath.log10(complex(x.value())))
    else:
        param_stack.push(x)
        raise TypeError("log: Type error ({})".format(type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='loop', doc="""\
Execute a definite loop.
<limit> <initial> DO xxx LOOP

The iteration counter is available via I.  LEAVE will exit the loop early.

Example: 10 0 do I . loop
prints 0 1 2 3 4 5 6 7 8 9

qv DO, I, LEAVE, +LOOP""")
def w_loop():
    pass                        # Grammar rules handle this word


@defword(name='nip', args=2, doc="""\
Drop second stack element  ( y x -- x )
Equivalent to SWAP DROP.  J.V. Noble calls this PLUCK.""")
def w_nip():
    x = param_stack.pop()
    y = param_stack.pop()
    param_stack.push(x)


@defword(name='not', args=1, doc="""\
Logical not  ( f -- !f )

Return a TRUE (1) if x is zero, otherwise FALSE (0).  Logically the same
as 0=, but NOT is intended for boolean manipulations and only is defined
on integers; 0= is meant to compare a number to zero, and works for
integers, reals, rationals, and complex numbers.  NOTE: This is not a
bitwise not.""")
def w_not():
    x = param_stack.pop()
    if type(x) is Rpn2Integer:
        param_stack.push(Rpn2Integer(1 if x.zerop() else 0))
        global show_x
        show_x = True
    else:
        param_stack.push(x)
        raise RuntimeError("not: Type error ({})".format(type(x).__name__))


@defword(name='of', doc="""\
Execute a sequence of words based on stack value.  Once a match is
executed, no other clauses are considered.  OTHERWISE is optional.
<n> and OF labels must be integers.

<n> CASE
  <x> OF xxx ENDOF
  <y> OF yyy ENDOF
  <z> OF zzz ENDOF
  [ OTHERWISE aaa ]
ENDCASE

qv CASE, ENDCASE, ENDOF, OTHERWISE
""")
def w_of():
    pass                        # Grammar rules handle this word


@defword(name='otherwise',  doc="""\
Execute a sequence of words based on stack value.  Once a match is
executed, no other clauses are considered.  OTHERWISE is optional.
<n> and OF labels must be integers.

<n> CASE
  <x> OF xxx ENDOF
  <y> OF yyy ENDOF
  <z> OF zzz ENDOF
  [ OTHERWISE aaa ]
ENDCASE

qv CASE, ENDCASE, ENDOF, OF
""")
def w_otherwise():
    pass                        # Grammar rules handle this word


@defword(name='over', args=2, doc="""\
Duplicate second stack element  ( y x -- y x y )
Equivalent to 1 PICK""")
def w_over():
    x = param_stack.pop()
    y = param_stack.pop()
    param_stack.push(y)
    param_stack.push(x)
    param_stack.push(y)


@defword(name='perm', args=2, doc="""\
Permutations  ( n r -- nPr )
Choose from N objects R at a time, with regard to ordering.

DEFINITION:
        n!
nPr = ------
      (n-r)!""")
def w_perm():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(y) is Rpn2Integer and type(x) is Rpn2Integer:
        # Python 3.8 has math.perm()
        n = y.value()
        r = x.value()
        if r > n or r < 0:
            result = Rpn2Integer(0)
        else:
            t = 1
            while r > 0:
                r -= 1
                t *= n
                n -= 1
            result = Rpn2Integer(t)
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise TypeError("perm: Type error ({}, {})".format(type(y).__name__, type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='PI', doc="""\
Constant: Pi ( -- 3.14159... )

DEFINITION:
PI == TAU/2

Consider using TAU instead of PI to simplify your equations.""")
def w_PI():
    param_stack.push(Rpn2Float(PI))
    global show_x
    show_x = True


@defword(name='r->d', args=1, doc="""\
Convert radians to degrees ( rad -- deg )""")
def w_r_to_d():
    x = param_stack.pop()
    if type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational]:
        result = Rpn2Float(convert_radians_to_mode(float(x.value()), "d"))
    else:
        param_stack.push(x)
        raise TypeError("r->d: Type error ({})".format(type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='r>', doc="""\
Pop return stack onto parameter stack  ( -- x )""")
def w_r_from():
    if return_stack.empty():
        raise RuntimeError("r>: Empty return stack")
    param_stack.push(return_stack.pop())


@defword(name='r@', doc="""\
Copy top of return stack  ( -- x )""")
def w_r_fetch():
    if return_stack.empty():
        raise RuntimeError("r@: Empty return stack")
    param_stack.push(return_stack.top())


@defword(name='rad')
def w_rad():
    global angle_mode
    angle_mode = "r"


@defword(name='rad?')
def w_rad_query():
    global angle_mode
    param_stack.push(Rpn2Integer(1 if angle_mode == "r" else 0))
    global show_x
    show_x = True


@defword(name='rand', doc="""\
Random number  ( -- n )
0 <= n < 1""")
def w_rand():
    param_stack.push(Rpn2Float(random.random()))
    global show_x
    show_x = True


@defword(name='rclst', doc="""\
Clear the return stack.
Do not do this inside a DO loop!""")
def w_rclst():
    return_stack.clear()


@defword(name='repeat', doc="""\
Execute an indefinite loop while a condition is satisfied.
BEGIN xxx <flag> WHILE yyy REPEAT

LEAVE will exit the loop early.  Note that the effect of the test in
BEGIN...WHILE is opposite that in BEGIN...UNTIL.  The loop repeats
while something is true, rather than until it becomes true.

qv BEGIN, AGAIN, LEAVE, UNTIL, WHILE""")
def w_repeat():
    pass                        # Grammar rules handle this word


@defword(name='rot', args=3, doc="""\
Rotate third stack element to the top, rolling others up  ( z y x -- y x z )
Equivalent to 2 ROLL""")
def w_rot():
    x = param_stack.pop()
    y = param_stack.pop()
    z = param_stack.pop()
    param_stack.push(y)
    param_stack.push(x)
    param_stack.push(z)


@defword(name='scopes')
def w_scopes():
    for (i, item) in scope_stack.items_bottom_to_top():
        lnwriteln("{}: {}".format(i, item))


@defword(name='sf', args=1)
def w_sf():
    x = param_stack.pop()
    if type(x) is Rpn2Integer:
        if x.value() < 0 or x.value() >= flag_max:
            param_stack.push(x)
            raise ValueError("sf: Argument out of range (0..{} expected)".format(flag_max))
        flag_set(x.value())
    else:
        param_stack.push(x)
        raise TypeError("sf: Type error ({})".format(type(x).__name__))


@defword(name='shflag', doc="""\
Show status of all flags ( -- )""")
def w_shflag():
    flags = []
    for f in range(flag_max):
        flags.append("%02d:%s" % (f, "YES" if flag_test(f) else "no "))

    columns = global_scope.variable('COLS').obj().value()
    list_in_columns(flags, columns - 1)


@defword(name='show', str_args=1)
def w_show():
    s = string_stack.pop()
    what = lookup_word(s.value())
    if what is None:
        lnwriteln("Could not find word '{}'".format(s))
    else:
        lnwriteln("show: {}".format(what))
        lnwriteln("show: {}".format(repr(what)))


@defword(name='sign', args=1, doc="""\
Signum  ( n -- sign )
Returns -1, 0, or 1.""")
def w_sign():
    x = param_stack.pop()
    if type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational]:
        if x.value() < 0:
            r = -1
        elif x.value() > 0:
            r = +1
        else:
            r = 0
        result = Rpn2Integer(r)
    else:
        param_stack.push(x)
        raise TypeError("sign: Type error ({})".format(type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='sin', args=1, doc="""\
Sine  ( angle -- sine )""")
def w_sin():
    x = param_stack.pop()
    if type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational]:
        result = Rpn2Float(math.sin(convert_mode_to_radians(float(x.value()))))
    elif type(x) is Rpn2Complex:
        result = Rpn2Complex.from_complex(cmath.sin(x.value()))
    else:
        param_stack.push(x)
        raise TypeError("sin: Type error ({})".format(type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='sqrt', args=1, doc="""\
Square root  ( x -- sqrt(x) )
Negative X returns a complex number""")
def w_sqrt():
    x = param_stack.pop()
    if type(x) is Rpn2Integer and x.zerop():
        result = Rpn2Integer(0)
    elif type(x) in [Rpn2Float, Rpn2Rational] and x.zerop():
        result = Rpn2Float(0.0)
    elif type(x) is Rpn2Complex and x.zerop():
        result = Rpn2Complex()
    elif    type(x) is Rpn2Integer  and x.value() > 0 \
         or type(x) is Rpn2Float    and x.value() > 0.0 \
         or type(x) is Rpn2Rational and x.value() > 0:
        r = math.sqrt(float(x.value()))
        if type(x) is Rpn2Integer and r.is_integer():
            result = Rpn2Integer(r)
        else:
            result = Rpn2Float(r)
    elif    type(x) is Rpn2Complex \
         or type(x) is Rpn2Integer  and x.value() < 0 \
         or type(x) is Rpn2Float    and x.value() < 0.0 \
         or type(x) is Rpn2Rational and x.value() < 0:
        result = Rpn2Complex.from_complex(cmath.sqrt(complex(x.value())))
    else:
        param_stack.push(x)
        raise TypeError("sqrt: Type error ({})".format(type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='swap', args=2, doc="""\
Exchange top two stack elements  ( y x -- x y )
Equivalent to 1 ROLL""")
def w_swap():
    x = param_stack.pop()
    y = param_stack.pop()
    param_stack.push(x)
    param_stack.push(y)


@defword(name='tan', doc="""\
Tangent  ( angle -- tangent )""")
def w_tan():
    x = param_stack.pop()
    if type(x) in [Rpn2Integer, Rpn2Float, Rpn2Rational]:
        result = Rpn2Float(math.tan(convert_mode_to_radians(float(x.value()))))
    elif type(x) is Rpn2Complex:
        result = Rpn2Complex.from_complex(cmath.tan(x.value()))
    else:
        param_stack.push(x)
        raise TypeError("tan: Type error ({})".format(type(x).__name__))
    param_stack.push(result)
    global show_x
    show_x = True


@defword(name='TAU', doc="""\
Constant: Tau ( -- 6.28318... )

DEFINITION:
Number of radians in a circle.""")
def w_TAU():
    param_stack.push(Rpn2Float(TAU))
    global show_x
    show_x = True


@defword(name='then', args=1, doc="""\
Execute a conditional test.  xxx is executed if <flag> is non-zero.
<flag> IF xxx [ ELSE yyy ] THEN

qv ELSE, IF""")
def w_then():
    pass                        # Grammar rules handle this word


@defword(name='TRUE')
def w_TRUE():
    param_stack.push(Rpn2Integer(1))
    global show_x
    show_x = True


@defword(name='tuck', args=2, doc="""\
Duplicate top stack element into third position  ( y x -- x y x )
Equivalent to SWAP OVER.  J.V. Noble calls this UNDER.""")
def w_tuck():
    x = param_stack.pop()
    y = param_stack.pop()
    param_stack.push(x)
    param_stack.push(y)
    param_stack.push(x)


@defword(name='until', doc="""\
Execute an indefinite loop until a condition is satisfied.
BEGIN xxx <flag> UNTIL

LEAVE will exit the loop early.  Note that the effect of the test in
BEGIN...WHILE is opposite that in BEGIN...UNTIL.  The loop repeats
while something is true, rather than until it becomes true.

qv AGAIN, BEGIN, LEAVE, REPEAT, WHILE""")
def w_until():
    pass                        # Grammar rules handle this word


@defword(name='vars', doc="""\
List variables and their values""")
def w_vars():
    vars = dict()
    for varname in global_scope.variables():
        var = global_scope.variable(varname)
        if var.hidden():
            continue
        vars[var.name()] = "{}:undef".format(var.name()) if not var.defined() else \
                           "{}={}".format(var.name(), var.obj().value())

    sorted_vars = []
    for key in sorted(vars, key=str.casefold):
        sorted_vars.append(vars[key])
    columns = global_scope.variable('COLS').obj().value()
    list_in_columns(sorted_vars, columns - 1)


@defword(name='vars!')
def w_vars_bang():
    for (i, scope) in scope_stack.items_bottom_to_top():
        lnwriteln("{} vars: {}".format(scope, scope.variables().keys()))


@defword(name='ver', doc="""\
Display the current RPN version.
Also available as @VER""")
def w_ver():
    lnwriteln("RPN version {}".format(global_scope.variable('VER').obj().value()))


@defword(name='vlist')
def w_vlist():
    words = dict()
    for wordname in global_scope.words():
        word = global_scope.word(wordname)
        if word.hidden():
            continue
        words[word.name()] = word.name()
    sorted_words = []
    for key in sorted(words, key=str.casefold):
        sorted_words.append(words[key])
    columns = global_scope.variable('COLS').obj().value()
    list_in_columns(sorted_words, columns - 1)


@defword(name='while', doc="""\
Execute an indefinite loop while a condition is satisfied.
BEGIN xxx <flag> WHILE yyy REPEAT

LEAVE will exit the loop early.  Note that the effect of the test in
BEGIN...WHILE is opposite that in BEGIN...UNTIL.  The loop repeats
while something is true, rather than until it becomes true.

qv AGAIN, BEGIN, LEAVE, REPEAT, UNTIL""")
def w_while():
    pass                        # Grammer rules handle this word


@defword(name='words')
def w_words():
    scope = scope_stack.top()
    lnwriteln("{} words: {}".format(scope, scope.words().keys()))


@defword(name='words!', hidden=True)
def w_words_bang():
    for (i, scope) in scope_stack.items_bottom_to_top():
        lnwriteln("{} words: {}".format(scope, scope.words().keys()))




#############################################################################
#
#       U T I L I T Y   F U N C T I O N S
#
#############################################################################
def memoize(f):
    memoize = {}
    def helper(x):
        if x not in memoize:
            memoize[x] = f(x)
        return memoize[x]
    return helper


def choose_helper(n, r):
    if r > n or r < 0:
        return 0
    if n - r < r:
        r = n - r

    result = 1
    j = 1
    while j <= r:
        result *= n; n -= 1
        result /= j; j += 1
    return result


def convert_mode_to_radians(x, force_mode=None):
    global angle_mode
    mode = force_mode if force_mode is not None else angle_mode
    if mode == "r":
        return x
    elif mode == "d":
        return x / DEG_PER_RAD
    # elif mode == "g":
    #     return x / GRAD_PER_RAD
    else:
        raise Rp2Fatal("{}: Bad angle_mode '{}'".format(whoami(), mode))


def convert_radians_to_mode(r, force_mode=None):
    global angle_mode
    mode = force_mode if force_mode is not None else angle_mode
    if mode == "r":
        return r
    elif mode == "d":
        return r * DEG_PER_RAD
    # elif mode == "g":
    #     return r * GRAD_PER_RAD
    else:
        raise Rp2Fatal("{}: Bad angle_mode '{}'".format(whoami(), mode))


def defvar(name, value, **kwargs):
    global_scope.set_variable(name, Rpn2Variable(name, value, **kwargs))


def old_defword(name, defn, **kwargs):
    global_scope.set_word(name, Rpn2Word(name, defn, **kwargs))


def eval_string(s):
    local_parser = yacc.yacc()
    result = local_parser.parse(s)


@memoize
def fact_helper(x):
    result = 1
    while x > 1:
        result *= x
        x -= 1
    return result


def flag_clear(flag):
    global flags_vec
    if flag < 0 or flag >= flag_max:
        raise Rpn2Fatal("{}: Flag {} out of range".format(whoami(), flag))
    flags_vec &= ~(1<<flag)

def flag_set(flag):
    global flags_vec
    if flag < 0 or flag >= flag_max:
        raise Rpn2Fatal("{}: Flag {} out of range".format(whoami(), flag))
    flags_vec |= 1<<flag

def flag_test(flag):
    global flags_vec
    if flag < 0 or flag >= flag_max:
        raise Rpn2Fatal("{}: Flag {} out of range".format(whoami(), flag))
    return True if flags_vec & 1<<flag != 0 else False


# Jeffrey Magedanz - https://stackoverflow.com/posts/42602689/revisions
def list_in_columns(items, width=79, indent=0, spacing=3):
    """\
Return string listing items along columns.

items : sequence
    List of items to display that must be directly convertible into
    unicode strings.
width : int
    Maximum number of characters per line, including indentation.
indent : int
    Number of spaces in left margin.
spacing : int
    Number of spaces between columns."""

    if not items:
        return u''
    # Ensure all items are strings
### items = [unicode(item) for item in items]
    # Estimate number of columns based on shortest and longest items
    minlen = min(len(item) for item in items)
    maxlen = max(len(item) for item in items)
    # Assume one column with longest width, remaining with shortest.
    # Use negative numbers for ceiling division.
    ncols = 1 - (-(width - indent - maxlen) // (spacing + min(1, minlen)))
    ncols = max(1, min(len(items), ncols))

    # Reduce number of columns until items fit (or only one column)
    while ncols >= 1:
        # Determine number of rows by ceiling division
        nrows = -(-len(items) // ncols)
        # Readjust to avoid empty last column
        ncols = -(-len(items) // nrows)
        # Split items into columns, and test width
        columns = [items[i*nrows:(i+1)*nrows] for i in range(ncols)]
        totalwidth = indent - spacing + sum(
            spacing + max(len(item) for item in column)
            for column in columns
            )
        # Stop if columns fit. Otherwise, reduce number of columns and
        # try again.
        if totalwidth <= width:
            break
        else:
            ncols -= 1

    # Pad all items to column width
    for i, column in enumerate(columns):
        colwidth = max(len(item) for item in column)
        columns[i] = [
            item + ' ' * (colwidth - len(item))
            for item in column
            ]

    # Transpose into rows, and return joined rows
    rows = list(itertools.zip_longest(*columns, fillvalue=''))
    out = '\n'.join(' ' * indent + (u' ' * spacing).join(row).rstrip()
                    for row in rows)
    writeln(out)

def load_file(filename):
    with open(filename, "r") as file:
        contents = file.read()
    eval_string(contents)


def lookup_variable(name):
    for (_, scope) in scope_stack.items_top_to_bottom():
        #lnwriteln("{}: Looking for variable {} in {}...".format(whoami(), name, scope))
        #lnwriteln("{} has variables: {}".format(scope, scope.variables))
        var = scope.variable(name)
        if var is not None:
            # lnwriteln("{}: Found variable {} in scope {}: {}".format(whoami(), name, scope, var))
            return var
    #lnwriteln("{}: Variable {} not found".format(whoami(), name))
    return None


def lookup_word(name):
    for (_, scope) in scope_stack.items_top_to_bottom():
        #lnwriteln("{}: Looking for word {} in {}...".format(whoami(), name, scope))
        #lnwriteln("{} has words: {}".format(scope, scope.words))
        word = scope.word(name)
        if word is not None:
            #lnwriteln("{}: Found word {} in scope {}: {}".format(whoami(), name, scope, word))
            return word
    #lnwriteln("{}: Word {} not found".format(whoami(), name))
    return None


def prompt_string():
    global angle_mode
    return "[{}{}] ".format(angle_mode, param_stack.size())


def push_scope(scope, why):
    #print("Pushing scope {} due to {}".format(scope, why))
    scope_stack.push(scope)

def pop_scope(why):
    scope = scope_stack.pop()
    if scope == global_scope:
        raise Rpn2Fatal("Attempting to pop Global scope!")
    #print("Popped scope {} due to {}".format(scope, why))


def sigquit_handler(signum, frame):
    raise Rpn2EndProgram()


# Simple SIGWINCH handler can become overwhelmed and crash if window
# changes come too fast.  Consider using shutil.get_terminal_size()
def sigwinch_handler(signum, frame):
    stty_size = subprocess.check_output(['stty', 'size']).decode().split()
    if len(stty_size) != 2:
        return

    tty_rows, tty_columns = stty_size
    #lnwriteln("{} x {}".format(tty_rows, tty_columns))
    if int(tty_columns) == 0:
        env_cols = os.getenv("COLUMNS")
        tty_columns = int(env_cols) if env_cols is not None else 80
    if int(tty_rows) == 0:
        env_rows = os.getenv("ROWS")
        tty_rows = int(env_rows) if env_rows is not None else 24
    global_scope.variable('ROWS').set_obj(Rpn2Integer(tty_rows))
    global_scope.variable('COLS').set_obj(Rpn2Integer(tty_columns))


def whoami():
    whoami = ""
    previous_frame = inspect.currentframe().f_back
    if "self" in previous_frame.f_locals:
        whoami += previous_frame.f_locals["self"].__class__.__name__ + "#"
    whoami += previous_frame.f_code.co_name
    return whoami


def write(s):
    sharpout = global_scope.variable('#OUT')
    outval = sharpout.obj().value()
    newline = s.find("\n")
    while newline != -1:
        substring = s[:newline]
        print(substring)
        outval = 0
        s = s[newline+1:]
        newline = s.find("\n")
    outval += len(s)
    print(s, end='')
    sharpout.set_obj(Rpn2Integer(outval))

def writeln(s=""):
    sharpout = global_scope.variable('#OUT')
    print(s)
    sharpout.set_obj(Rpn2Integer(0))

def lnwriteln(s):
    sharpout = global_scope.variable('#OUT')
    if sharpout.obj().value() != 0:
        writeln()
    writeln(s)




#############################################################################
#
#       P R I M A R Y   W O R D S   &   F U N C T I O N S
#
#############################################################################
def initialize():
    global rpn_version

    random.seed()
    w_clflag()
    define_variables()
    define_secondary_words()

    # Read & define ROWS and COLS via stty(1)
    sigwinch_handler(0, 0)

    init_file = os.path.expanduser("~/.rpn2rc")
    if os.path.isfile(init_file):
        load_file(init_file)


def define_variables():
    defvar('COLS',  Rpn2Integer(0))
    defvar('#OUT',  Rpn2Integer(0))
    defvar('ROWS',  Rpn2Integer(0))
    defvar('trace', Rpn2Integer(0))
    defvar('VER',   Rpn2Float(rpn_version))


def define_secondary_words():
    eval_string("""

: BL  doc:"BL  ( -- 32 )   ASCII code for a space character"
      32 ;
: space  doc:"space   Display one space character"
         BL emit ;
: spaces  doc:"spaces  ( n -- )   Display N space characters"
          0 do space loop ;

""")


def main_loop():
    global rpn_debug
    global parse_error
    global show_x

    while True:
        if global_scope.variable('#OUT').obj().value() != 0:
            writeln()
        if show_x and not param_stack.empty():
            writeln("{}".format(str(param_stack.top())))
        show_x = False
        write(prompt_string())
        try:
            s = input() + " "
        except EOFError:
            raise Rpn2EndProgram()
        except KeyboardInterrupt:
            # CTRL/C on input exits program
            raise Rpn2EndProgram()

        global_scope.variable('#OUT').set_obj(Rpn2Integer(0))
        if not s or s == " ":
            continue

        parse_error = False
        try:
            result = parser.parse(s, debug=rpn_debug)
        except Rpn2TopLevel:
            continue

        #print("A:parse({}) => result={} (parse_error={})".format(s, repr(result), parse_error))
        while result is None and not parse_error:
            #print("In ..., parser.token() returns {}".format(parser.token()))
            write("... ")
            try:
                t = input() + " "
            except EOFError:
                break
            except KeyboardInterrupt:
                break
            global_scope.variable('#OUT').set_obj(Rpn2Integer(0))
            s += t
            result = parser.parse(s, debug=rpn_debug)
            #print("B:parse({}) => result={} (parse_error={}".format(s, repr(result), parse_error))
        if global_scope.variable('trace').obj().value() >= 2:
            lnwriteln("trace={}".format(repr(result)))
        elif global_scope.variable('trace').obj().value() >= 1:
            lnwriteln("trace={}".format(str(result)))


def do_exit():
    if global_scope.variable('#OUT').obj().value() != 0:
        writeln()
    if not param_stack.empty():
        if param_stack.size() == 1:
            w_dot(); print()
        else:
            w_dot_s()
    sys.exit(0)



#############################################################################
#
#       M A I N
#
#############################################################################
rpn_debug = False
angle_mode  = "r"               # r=radians, d=degrees, g=grads (not supported)
parse_error = False
flag_max = 64
show_x = False

parser = yacc.yacc()

param_stack  = Rpn2Stack()
return_stack = Rpn2Stack()
scope_stack  = Rpn2Stack()
string_stack = Rpn2Stack()

#print("Creating Global scope {}".format(global_scope))
push_scope(global_scope, "Global scope")

# DEG_PER_RAD  = 360 / TAU
# E            = Base of natural logarithms = exp(1.0)
# GAMMA        = Euler-Mascheroni constant.  Approx: 1 - tanh(ln(1.57)) - 0.57/(9!)
# GRAD_PER_RAD = 400 / TAU
# LN_2         = ln(2)
# LN_10        = ln(10)
# PHI          = Golden ratio = (1 + sqrt(5)) / 2
# PI           = TAU / 2
# TAU          = Number of radians in a circle
GAMMA        =  0.5772156649015328606065120900824024310421593359399235988057672348848677267776646709369470632917467495
LN_2         =  0.6931471805599453094172321214581765680755001343602552541206900094933936219696947156058633269964186875
PHI          =  1.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911375
LN_10        =  2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983
E            =  2.7182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664274
PI           =  3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170680
TAU          =  6.2831853071795864769252867665590057683943387987502116419498891846156328125724179972560696506842341360
DEG_PER_RAD  = 57.2957795130823208767981548141051703324054724665643215491602438612028471483245526324409689958511109442
GRAD_PER_RAD = 63.6619772367581343075535053490057448137838582961825794990669376235587190536906140360455211065012343824


if __name__ == "__main__":
    signal.signal(signal.SIGQUIT, sigquit_handler)
    signal.signal(signal.SIGWINCH, sigwinch_handler)
    initialize()
    w_ver()
    try:
        main_loop()
    except Rpn2EndProgram:
        pass
    except Rpn2Fatal as e:
        if len(e._message) > 0:
            lnwriteln("Fatal error: {}".format(e))
        sys.exit(1)
    do_exit()
