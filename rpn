#!/usr/bin/env python3

import calendar
import cmath
import datetime
from   fractions import Fraction
import getopt
import inspect
import itertools
import math
import os
import queue
import random
import re
import readline
import signal
import statistics
import subprocess
import sys
import tempfile         # edit
import time
import traceback
import tty

RPN_VERSION = 15.6

try:
    import ply.lex  as lex
    import ply.yacc as yacc
except ModuleNotFoundError:
    print("RPN requires the 'ply' library; please consult the README") # OK
    sys.exit(1)

have_numpy = False
try:
    import numpy as np
    have_numpy = True
except ModuleNotFoundError:
    pass

have_scipy = False
if have_numpy:
    try:
        import scipy.integrate
        import scipy.optimize
        have_scipy = True
    except ModuleNotFoundError:
        pass


# Global variables
angle_mode              = "d"         # r=Radians, d=Degrees, g=Gradians
date_re                 = r'^(\d{1,2})\.(\d{2})(\d{4})$'
date_pat                = re.compile(date_re)
default_protected       = True
flags_vec               = 0
force_interactive       = False
go_interactive          = True
got_interrupt           = False
rational_re             = r'(\d+)::(\d+)'
rational_pat            = re.compile(rational_re)
register                = dict()
show_x                  = False
stat_list               = []
time_re                 = r'^[-+]?(\d+)\.(\d{,2})(\d*)$'
time_pat                = re.compile(time_re)

FLAG_TVM_CONTINUOUS     =   8
FLAG_TVM_BEGIN_MODE     =   9
FLAG_DEBUG_ENABLED      =  20
FLAG_PRINTER_ENABLED    =  21
FLAG_DECIMAL_POINT      =  28           # Set: 123,456.123  (US)   Clear: 123.456,123  (Europe)
FLAG_DIGIT_GROUPING     =  29           # Set: 1,234,567.01        Clear: 1234567.01
FLAG_FENCE              =  30           # Flags >= FLAG_FENCE cannot set set by the user
FLAG_DISP_FIX           =  40
FLAG_DISP_ENG           =  41
FLAG_GRAD               =  42
FLAG_RAD                =  43
FLAG_PRINTER_EXISTS     =  55
FLAG_MAX                =  56
JULIAN_OFFSET           = 1721424       # date.toordinal() returns 1 for 0001-01-01, so compensate
PRECISION_MAX           =  16
MATRIX_MAX              = 999
REG_SIZE_MIN            =  17
REG_SIZE_MAX            = 100           # R00..R99; further restricted by SIZE

# DEG_PER_RAD  = 360 / TAU
# E            = Base of natural logarithms = exp(1.0)
# GAMMA        = Euler-Mascheroni constant, approx: 1 - tanh(ln(1.57)) - 0.57/(9!)
# GRAD_PER_RAD = 400 / TAU
# LN_2         = ln(2)
# LN_10        = ln(10)
# PHI          = "Golden ratio" = (1 + sqrt(5)) / 2
# PI           = TAU / 2
# RAD_PER_DEG  = TAU / 360
# RAD_PER_GRAD = TAU / 400
# SQRT_2       = Square root of 2
# TAU          = Number of radians in a circle = 2*PI

RAD_PER_GRAD =  0.0157079632679489661923132169163975144209858469968755291048747229615390820314310449931401741267105853
RAD_PER_DEG  =  0.0174532925199432957692369076848861271344287188854172545609719144017100911460344944368224156963450948
GAMMA        =  0.5772156649015328606065120900824024310421593359399235988057672348848677267776646709369470632917467495
LN_2         =  0.6931471805599453094172321214581765680755001343602552541206900094933936219696947156058633269964186875
SQRT_2       =  1.4142135623730950488016887242096980785696718753769480731766797379907324784621070388503875343276415727
PHI          =  1.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911375
LN_10        =  2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983
E            =  2.7182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664274
PI           =  3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170680
TAU          =  6.2831853071795864769252867665590057683943387987502116419498891846156328125724179972560696506842341360
DEG_PER_RAD  = 57.2957795130823208767981548141051703324054724665643215491602438612028471483245526324409689958511109442
GRAD_PER_RAD = 63.6619772367581343075535053490057448137838582961825794990669376235587190536906140360455211065012343824




#############################################################################
#
#       E X C E P T I O N S
#
#############################################################################
class Rpn_Exception(Exception):
    def __init__(self, msg=""):
        self._message = msg
    def __str__(self):
        return str(self._message)

class Rpn_E_Abort(Rpn_Exception):
    """Rpn_E_Abort is raised by the ABORT and ABORT" words.
It clears the parameter, return, and string stacks.  Caught in p_execute."""


class Rpn_E_End_Program (Rpn_Exception):
    """Rpn_E_End_Program is raised when there is no more input to parse, or
the interrupt key is signaled.  It is caught in __main__, where processing
is halted, the exit routine prints the stack, and the program exits."""


class Rpn_E_Exit(Rpn_Exception):
    """Rpn_E_Exit is raised by the word EXIT and terminates execution
of the current word."""


class Rpn_E_Fatal(Rpn_Exception):
    """Rpn_E_Fatal is raised whenever an internal error is detected that
forces the program to abend.  It is caught in __main__ and causes an
immediate program termination."""


class Rpn_E_Leave(Rpn_Exception):
    """Rpn_E_Leave is raised by the LEAVE word.  This is caught by
BEGIN or DO loops, and causes an immediate exit from the enclosing loop.
If a loop is not currently executing, it is caught in p_execute() and
an error message is printed."""


class Rpn_E_Parse_Error(Rpn_Exception):
    """Rpn_E_Parse_Error is raised by p_error and is caught in eval_string()."""


class Rpn_E_Runtime_Error(Rpn_Exception):
    pass

class Rpn_E_Stack_Overflow(Rpn_Exception):
    pass

class Rpn_E_Stack_Underflow(Rpn_Exception):
    pass

class Rpn_E_Type_Error(Rpn_Exception):
    pass

class Rpn_E_Value_Error(Rpn_Exception):
    pass


# 9.3.1  THROW values
#
# The THROW values {-255...-1} shall be used only as assigned by this
# Standard.  The values {-4095...-256} shall be used only as assigned by a
# system.  If the File-Access or Memory-Allocation word sets are
# implemented, it is recommended that the non-zero values of ior lie
# within the range of system THROW values, as defined above.  In an
# operating-system environment, this can sometimes be accomplished by
# "biasing" the range of operating-system exception-codes to fall within
# the THROW range.  Programs shall not define values for use with THROW in
# the range {-4095...-1}.

throw_code_name = {
    -1 : 'ABORT',
    -2 : 'ABORT"',
    -3 : 'Stack overflow',
    -4 : 'Stack underflow',
    -5 : 'Return stack overflow',
    -6 : 'Return stack underflow',
    -7 : 'DO-loops nested too deeply during execution',
    -8 : 'Dictionary overflow',
    -9 : 'Invalid memory address',
    -10: 'Division by zero',
    -11: 'Result out of range',
    -12: 'Argument type mismatch',
    -13: 'Undefined word',
    -14: 'Interpreting a compile-only word',
    -15: 'Invalid FORGET',
    -16: 'Attempt to use zero-length string as a name',
    -17: 'Pictured numeric output string overflow',
    -18: 'Parsed string overflow',
    -19: 'Definition name too long',
    -20: 'Write to a read-only location',
    -21: 'Unsupported operation',       # e.g., AT-XY on a too-dumb terminal
    -22: 'Control structure mismatch',
    -23: 'Address alignment exception',
    -24: 'Invalid numeric argument',
    -25: 'Return stack imbalance',
    -26: 'Loop parameters unavailable',
    -27: 'Invalid recursion',
    -28: 'User interrupt',
    -29: 'Compiler nesting',
    -30: 'Obsolescent feature',
    -31: '>BODY used on non-CREATEd definition',
    -32: 'Invalid name argument',       # e.g., TO xxx
    -33: 'Block read exception',
    -34: 'Block write exception',
    -35: 'Invalid block number',
    -36: 'Invalid file position',
    -37: 'File I/O exception',
    -38: 'Non-existent file',
    -39: 'Unexpected end of file',
    -40: 'Invalid BASE for floating point conversion',
    -41: 'Loss of precision',
    -42: 'Floating-point divide by zero',
    -43: 'Floating-point result out of range',
    -44: 'Floating-point stack overflow',
    -45: 'Floating-point stack underflow',
    -46: 'Floating-point invalid argument',
    -47: 'Compilation word list deleted',
    -48: 'Invalid POSTPONE',
    -49: 'Search-order overflow',
    -50: 'Search-order underflow',
    -51: 'Compilation word list changed',
    -52: 'Control-flow stack overflow',
    -53: 'Exception stack overflow',
    -54: 'Floating-point underflow',
    -55: 'Floating-point unidentified fault',
    -56: 'QUIT',
    -57: 'Exception in sending or receiving a character',
    -58: '[IF], [ELSE], or [THEN] exception',
}

class Rpn_E_Throw(Rpn_Exception):
    """Exception raised by THROW and caught by CATCH."""


class Rpn_E_Top_Level(Rpn_Exception):
    """Rpn_E_Top_Level causes an immediate return to the top level prompt.
It is caught in main_loop."""




#############################################################################
#
#       D E B U G G I N G
#
#############################################################################
debug_levels = {
    "catch"                     : 0,
    "defvar"                    : 0,
    "dollar_in"                 : 0,
    "eval_string"               : 0,
    "lookup_varname"            : 0,
    "lookup_variable"           : 0,
    "number_in"                 : 0,
    "p_define_word"             : 0,
    "p_executable"              : 0,
    "p_execute"                 : 0,
    "p_fetch_var"               : 0,
    "p_locals_scope"            : 0,
    "p_store_var"               : 0,
    "p_variable"                : 0,
    "parse"                     : 0,
    "prompt"                    : 0,
    "Rpn_Do_Loop#__call__"      : 0,
    "Rpn_Scope#set_variable"    : 0,
    "Rpn_Sequence#__call__"     : 0,
    "Rpn_Sequence#__init__"     : 0,
    "Rpn_Word#__init__"         : 0,
    "scope"                     : 0,
    "show"                      : 0,
    "token"                     : 0,
    "trace"                     : 0,
    "tvm"                       : 0,
}


def typename(s):
    t = type(s).__name__
    if t[:4] == "Rpn_":
        return t[4:]
    return t

def whoami():
    who_i_am = ""
    previous_frame = inspect.currentframe().f_back
    if "self" in previous_frame.f_locals:
        who_i_am += previous_frame.f_locals["self"].__class__.__name__ + "#"
    who_i_am += previous_frame.f_code.co_name
    if who_i_am[:2] == "w_":
        who_i_am = who_i_am[2:]
    return who_i_am

def set_debug_level(resource, level = 1):
    global debug_levels

    if resource not in debug_levels:
        print("set_debug_level: Resource '{}' not valid".format(resource)) # OK
        traceback.print_stack(file=sys.stderr)
        sys.exit(1)             # Harsh!

    if level < 0 or level > 9:
        raise Rpn_E_Fatal("set_debug_level: Level {} out of range (0..9 expected)".format(level))
    debug_levels[resource] = level

def dbg(resource, level = 1, text = None):
    '''Note that a level of -1 will always be True and possibly print the text.
This can be useful to quickly turn a debugging statement on unilaterally;
just change "dbg(res,1,xxx)" to "dbg(res,-1,xxx)".'''
    global debug_levels

    if resource not in debug_levels:
        print("dbg: Resource '{}' not valid".format(resource)) # OK
        traceback.print_stack(file=sys.stderr)
        sys.exit(1)             # Harsh!

    if not flag_set_p(FLAG_DEBUG_ENABLED) or level == 0:
        return False
    flag = debug_levels[resource] >= level
    if flag and text is not None:
        print("{}".format(text), flush=True) # OK
    return flag





#############################################################################
#
#       S U P P O R T   C L A S S E S
#
#############################################################################
class Rpn_Stackable:
    def __init__(self):
        self._value = None
        self._label = None

    def value(self):
        return self._value

    def set_value(self, val):
        self._value = val

    def label(self):
        return self._label

    def set_label(self, label):
        self._label = label

    def __call__(self):
        dbg("trace", 1, "trace({})".format(repr(self)))
        param_stack.push(self)

    def patch_recurse(self, _):
        pass


class Rpn_Abort_Quote:
    def __init__(self, val):
        if len(val) < 7 or val[0:6] != 'abort"' or val[-1] != '"':
            raise Rpn_E_Fatal("{}: Malformed string: '{}'".format(whoami(), val))
        self._str = val[6:-1]

    def stringval(self):
        return self._str

    def __call__(self):
        dbg("trace", 1, "trace({})".format(repr(self)))
        if param_stack.empty():
            raise Rpn_E_Runtime_Error("abort\": Insufficient parameters (1 required)")
        flag = param_stack.pop()
        if type(flag) is not Rpn_Integer:
            param_stack.push(flag)
            raise Rpn_E_Type_Error("abort\": Flag must be an integer")
        if flag.value() != 0:
            lnwriteln("{}".format(self.stringval()))
            raise Rpn_E_Abort()

    def patch_recurse(self, new_word):
        pass

    def __str__(self):
        return "abort\"{}\"".format(self.stringval())

    def __repr__(self):
        return "AbortQuote[{}]".format(repr(self.stringval()))


class Rpn_Begin_Again:
    def __init__(self, seq):
        self._seq = seq

    def __call__(self):
        dbg("trace", 2, "trace({})".format(repr(self)))
        try:
            while True:
                self._seq.__call__()
        except Rpn_E_Leave:
            pass

    def patch_recurse(self, new_word):
        self._seq.patch_recurse(new_word)

    def __str__(self):
        return "begin {} again".format(self._seq)

    def __repr__(self):
        return "BeginAgain[{}]".format(repr(self._seq))


class Rpn_Begin_Until:
    def __init__(self, seq):
        self._seq = seq

    def __call__(self):
        dbg("trace", 2, "trace({})".format(repr(self)))
        try:
            while True:
                self._seq.__call__()
                if param_stack.empty():
                    raise Rpn_E_Runtime_Error("until: Insufficient parameters (1 required)")
                flag = param_stack.pop()
                if type(flag) is not Rpn_Integer:
                    param_stack.push(flag)
                    raise Rpn_E_Type_Error("until: Flag must be an integer")
                if flag.value() != 0:
                    break
        except Rpn_E_Leave:
            pass

    def patch_recurse(self, new_word):
        self._seq.patch_recurse(new_word)

    def __str__(self):
        return "begin {} until".format(self._seq)

    def __repr__(self):
        return "BeginUntil[{}]".format(repr(self._seq))


class Rpn_Begin_While:
    def __init__(self, seq1, seq2):
        self._seq1 = seq1
        self._seq2 = seq2

    def __call__(self):
        dbg("trace", 2, "trace({})".format(repr(self)))
        try:
            while True:
                self._seq1.__call__()
                if param_stack.empty():
                    raise Rpn_E_Runtime_Error("while: Insufficient parameters (1 required)")
                flag = param_stack.pop()
                if type(flag) is not Rpn_Integer:
                    param_stack.push(flag)
                    raise Rpn_E_Type_Error("while: Flag must be an integer")
                if flag.value() == 0:
                    break
                self._seq2.__call__()
        except Rpn_E_Leave:
            pass

    def patch_recurse(self, new_word):
        self._seq1.patch_recurse(new_word)
        self._seq2.patch_recurse(new_word)

    def __str__(self):
        return "begin {} while {} repeat".format(self._seq1, self._seq2)

    def __repr__(self):
        return "BeginWhile[{}, {}]".format(repr(self._seq1), repr(self._seq2))


class Rpn_Case:
    def __init__(self, case_clauses, otherwise_seq):
        self._case_clauses  = case_clauses
        self._otherwise_seq = otherwise_seq

    def __call__(self):
        dbg("trace", 2, "trace({})".format(repr(self)))
        if param_stack.empty():
            raise Rpn_E_Runtime_Error("case: Insufficient parameters (1 required)")
        n = param_stack.pop()
        if type(n) is not Rpn_Integer:
            param_stack.push(n)
            raise Rpn_E_Type_Error("case: Case control parameter must be an integer")
        nval = n.value()

        # Determine the correct sequence to call
        seq = self._otherwise_seq
        for clause in self._case_clauses.items():
            if clause.x() == nval:
                seq = clause
                break

        # Call it with a new scope
        case_scope = Rpn_Scope("Call_Case")
        case_scope.set_variable('caseval', Rpn_Variable("caseval", n))
        try:
            push_scope(case_scope, "Starting Case")
            seq.__call__()
        finally:
            pop_scope("Case complete")

    def patch_recurse(self, new_word):
        self._case_clauses.patch_recurse(new_word)
        self._otherwise_seq.patch_recurse(new_word)

    def __str__(self):
        s = "case "
        for cc in self._case_clauses.items():
            s += str(cc)
        if self._otherwise_seq is not None:
            s += "otherwise {} ".format(self._otherwise_seq)
        s += "endcase"
        return s

    def __repr__(self):
        s = "Case["
        s += ", ".join([ repr(cc) for cc in self._case_clauses.items() ])
        if self._otherwise_seq is not None:
            s += ", Otherwise[{}]".format(repr(self._otherwise_seq))
        return s + "]"


class Rpn_Case_Clause:
    def __init__(self, x, seq):
        self._x = int(x)      # x is a plain integer, not an Rpn_Integer
        self._seq = seq

    def x(self):
        return self._x

    def __call__(self):
        self._seq.__call__()

    def patch_recurse(self, new_word):
        self._seq.patch_recurse(new_word)

    def __str__(self):
        return "{} of {} endof ".format(self._x, self._seq)

    def __repr__(self):
        return "Of[{}={}]".format(self._x, repr(self._seq))


class Rpn_Catch:
    def __init__(self, word, scope):
        if type(word) is not Rpn_Word:
            raise Rpn_E_Fatal("{}: Word {} is not an Rpn_Word".format(whoami(), repr(word)))
        if type(scope) is not Rpn_Scope:
            raise Rpn_E_Fatal("{}: Scope {} is not an Rpn_Scope".format(whoami(), repr(scope)))
        dbg("catch", 1, "{}: Rpn_Catch({})".format(whoami(), word))
        self._word = word
        self._scope = scope

    def __call__(self):
        dbg("trace", 1, "trace({})".format(repr(self)))
        dbg("catch", 1, "Calling {}: word={}, scope={}".format(whoami(), repr(self._word), repr(self._scope)))
        try:
            execute(self._word)
        except Rpn_E_Throw as e:
            dbg("catch", 1, "{}: Caught a throw, e={}".format(whoami(), e))
            param_stack.push(Rpn_Integer(int(e.args[0])))
        else:
            dbg("catch", 1, "{}: Nothing caught, finishing normally".format(whoami()))
            param_stack.push(Rpn_Integer(0))

    def patch_recurse(self, new_word):
        pass

    def __str__(self):
        return "catch {}".format(self._word.name())

    def __repr__(self):
        return "Catch[{}]".format(repr(self._word.name()))


class Rpn_Complex(Rpn_Stackable):
    def __init__(self, real=0.0, imag=0.0):
        super().__init__()
        self.set_real_imag(real, imag)

    @classmethod
    def from_complex(cls, cplx):
        return cls(cplx.real, cplx.imag)

    def real(self):
        return self.value().real

    def imag(self):
        return self.value().imag

    def set_real_imag(self, real, imag):
        self.set_value(complex(float(real), float(imag)))

    def zerop(self):
        return self.real() == 0.0 and self.imag() == 0.0

    def __str__(self):
        s = "({},{})".format(fmt(self.real()), fmt(self.imag()))
        l = r"  \ " + "{}".format(self.label()) if self.label() is not None else ""
        return s + l

    def __repr__(self):
        return "Complex[{}]".format(repr(self.value()))


def frexp10(x):
    """
    Return mantissa and exponent (base 10), similar to base-2 frexp()
    :param x: floating point number
    :return: tuple (mantissa, exponent)
    """
    exp = math.floor(math.log10(x))
    return x/10**exp, exp


class Rpn_Constant:
    def __init__(self, var):
        self._variable = var

    def __call__(self):
        dbg("trace", 1, "trace({})".format(repr(self)))
        if param_stack.empty():
            raise Rpn_E_Runtime_Error("constant: Insufficient parameters (1 required)")
        self._variable.set_obj(param_stack.pop())

    def patch_recurse(self, new_word):
        pass

    def __str__(self):
        return "constant {}".format(self._variable.name())

    def __repr__(self):
        return "Constant[{}]".format(repr(self._variable))


# | Mode | 40 | 41 |
# |------+----+----|
# | sci  |  0 |  0 |
# | eng  |  0 |  1 |
# | fix  |  1 |  0 |
# | std  |  1 |  1 |
# |------+----+----|
#
# | # digits | 36 | 37 | 38 | 39 |
# |----------+----+----+----+----|
# |        0 |  0 |  0 |  0 |  0 |
# |        1 |  0 |  0 |  0 |  1 |
# |        2 |  0 |  0 |  1 |  0 |
# |        3 |  0 |  0 |  1 |  1 |
# |        4 |  0 |  1 |  0 |  0 |
# |        5 |  0 |  1 |  0 |  1 |
# |        6 |  0 |  1 |  1 |  0 |
# |        7 |  0 |  1 |  1 |  1 |
# |        8 |  1 |  0 |  0 |  0 |
# |        9 |  1 |  0 |  0 |  1 |
# |       10 |  1 |  0 |  1 |  0 |
# |       11 |  1 |  0 |  1 |  1 |
# |       12 |  1 |  1 |  0 |  0 |
# |       13 |  1 |  1 |  0 |  1 |
# |       14 |  1 |  1 |  1 |  0 |
# |       15 |  1 |  1 |  1 |  1 |
# |----------+----+----+----+----|
class Rpn_Display_Config:
    def __init__(self):
        self._style = None
        self._prec  = None

    def style(self):
        return self._style

    def set_style(self, style):
        if style not in ["std", "fix", "sci", "eng"]:
            raise Rpn_E_Fatal("{}: Invalid display style '{}'".format(whoami(), style))
        self._style = style

    def prec(self):
        return self._prec

    def set_prec(self, prec):
        global PRECISION_MAX
        if prec < 0 or prec >= PRECISION_MAX:
            raise Rpn_E_Fatal("{}: Invalid display precision '{}' (0..{} expected)".format(whoami(), prec, PRECISION_MAX - 1))
        self._prec = prec
        for bit in range(4):
            if prec & 1<<bit != 0:
                set_flag(39 - bit)
            else:
                clear_flag(39 - bit)

    def eng_notate(self, x):
        """
        Convert a float to a string in engineering units, with specified
        significant figures
        :param x: float to convert
        :param sf: number of significant figures
        :return: string conversion of x in scientific notation
        """

        sf = self.prec()
        if x == 0:
            return "0." + "0"*(sf-1) + "e+00"
        mant_sign = ""
        if x < 0.0:
            mant_sign = "-"
            x = -x
        # Normalize the number and round to get sf significant figures
        mant, exp = frexp10(x)
        r = round(mant, sf-1)
        # Convert back to original scale
        x = r * math.pow(10.0, exp)
        # Get integer exponent to group by factors of 1000
        p = int(math.floor(math.log10(x)))
        p3 = p // 3
        # Get root value string
        value = x / math.pow(10.0, 3*p3)
        num_str = "{:f}".format(value)
        # Slice to length, avoid trailing "."
        if num_str[sf] != ".":
            num_str = num_str[0:sf+1]
        else:
            num_str = num_str[0:sf]
        exp_sign = "-" if p3 < 0 else "+"
        exp_str = "{:02d}".format(abs(3*p3))
        return mant_sign + num_str + "e" + exp_sign + exp_str

    def fmt(self, x, show_label=True):
        if type(x) is float:
            if self.style() == "fix":
                return "{:.{prec}{style}}".format(x, style="f", prec=self.prec())
            if self.style() == "sci":
                return "{:.{prec}{style}}".format(x, style="e", prec=self.prec())
            if self.style() == "eng":
                return self.eng_notate(x)
            if self.style() == "std":
                return str(x)
            raise Rpn_E_Fatal("{}: Invalid style '{}'".format(whoami(), self.style()))
        if type(x) is Rpn_Float:
            s = self.fmt(x.value())
            l = ""
            if show_label and x.label() is not None:
                l = r"  \ " + "{}".format(x.label())
            return s + l
        if type(x) is Rpn_String:
            return x.value()
        return str(x)


class Rpn_Do_Loop:
    def __init__(self, seq):
        self._seq = seq

    def __call__(self):
        dbg("trace", 2, "trace({})".format(repr(self)))
        if param_stack.size() < 2:
            raise Rpn_E_Runtime_Error("do: Insufficient parameters (2 required)")
        x = param_stack.pop()
        y = param_stack.pop()
        if type(y) is not Rpn_Integer or type(x) is not Rpn_Integer:
            param_stack.push(y)
            param_stack.push(x)
            raise Rpn_E_Type_Error("do: Loop control parameters must be integers")
        limit = y.value()
        i = x.value()
        if i == limit:
            #lnwriteln("do: Not executing because initial == limit")
            return

        # Create a new scope
        _I = Rpn_Variable("_I", x)
        do_scope = Rpn_Scope("Call_Do_Loop")
        do_scope.set_variable('_I', _I)

        try:
            push_scope(do_scope, "Starting Do_Loop")
            while True:
                self._seq.__call__()
                i += 1
                _I.set_obj(Rpn_Integer(i))
                if i >= limit:
                    break
        except Rpn_E_Leave:
            pass
        finally:
            pop_scope("Do_Loop complete")

    def patch_recurse(self, new_word):
        self._seq.patch_recurse(new_word)

    def __str__(self):
        return "do {} loop".format(self._seq)

    def __repr__(self):
        return "DoLoop[{}]".format(repr(self._seq))


class Rpn_Do_PlusLoop:
    def __init__(self, seq):
        self._seq = seq

    def __call__(self):
        dbg("trace", 2, "trace({})".format(repr(self)))
        if param_stack.size() < 2:
            raise Rpn_E_Runtime_Error("do: Insufficient parameters (2 required)")
        x = param_stack.pop()
        y = param_stack.pop()
        if type(y) is not Rpn_Integer or type(x) is not Rpn_Integer:
            param_stack.push(y)
            param_stack.push(x)
            raise Rpn_E_Type_Error("do: Loop control parameters must be integers")
        limit = y.value()
        i = x.value()
        if i == limit:
            #lnwriteln("do: Not executing because initial == limit")
            return

        # Create a new scope
        _I = Rpn_Variable("_I", x)
        do_scope = Rpn_Scope("Call_Do_PlusLoop")
        do_scope.set_variable('_I', _I)

        try:
            push_scope(do_scope, "Starting Do_PlusLoop")
            while True:
                self._seq.__call__()
                if param_stack.empty():
                    raise Rpn_E_Runtime_Error("+loop: Insufficient parameters (1 required)")
                incr = param_stack.pop()
                if type(incr) is not Rpn_Integer:
                    param_stack.push(incr)
                    raise Rpn_E_Type_Error("+loop: Increment must be integer")
                i += incr.value()
                _I.set_obj(Rpn_Integer(i))
                if    incr.value() > 0 and i >= limit \
                   or incr.value() < 0 and i < limit:
                    break
        except Rpn_E_Leave:
            pass
        finally:
            pop_scope("Do_PlusLoop complete")

    def patch_recurse(self, new_word):
        self._seq.patch_recurse(new_word)

    def __str__(self):
        return "do {} +loop".format(self._seq)

    def __repr__(self):
        return "DoPlusLoop[{}]".format(repr(self._seq))


class Rpn_Dot_Quote:
    def __init__(self, val):
        if len(val) < 3 or val[0:2] != '."' or val[-1] != '"':
            raise Rpn_E_Fatal("{}: Malformed string: '{}'".format(whoami(), val))
        self._str = val[2:-1]

    def stringval(self):
        return self._str

    def __call__(self):
        dbg("trace", 1, "trace({})".format(repr(self)))
        write("{}".format(self.stringval()))

    def patch_recurse(self, new_word):
        pass

    def __str__(self):
        return ".\"{}\"".format(self.stringval())

    def __repr__(self):
        return "DotQuote[{}]".format(repr(self.stringval()))


class Rpn_Fetch_Var:
    """Fetch variable.

It is normally an error to fetch an undefined variable,
but @?VAR will return 0 if VAR is not defined.

In addition to fetching the value of a variable,
"recall arithmetic" modifies the TOS (X) value in an
additional way: using the variable's value,
        New TOS = Previous TOS +|-|*|/ Variable value
The value stored in Variable is not affected.  Does
the right thing with empty stack (uses zero)."""

    def __init__(self, ident, modifier=None):
        self._identifier = ident
        self._modifier   = modifier

    def identifier(self):
        return self._identifier

    def __call__(self):
        dbg("trace", 1, "trace({})".format(repr(self)))
        (var, _) = lookup_variable(self.identifier())
        if var is None:
            raise Rpn_E_Fatal("{}: Variable has vanished!".format(str(self)))
        if var.obj() is None:
            if self._modifier == '?':
                param_stack.push(Rpn_Integer(0))
                # The variable remains undefined
            else:
                raise Rpn_E_Runtime_Error("{}: Variable is not defined".format(str(self)))
        elif self._modifier == '$' or type(var.obj()) is Rpn_String:
            string_stack.push(var.obj())
        else:
            if self._modifier is not None and self._modifier == '/' and var.obj().zerop():
                raise Rpn_E_Runtime_Error("{}: Cannot divide by zero".format(str(self)))
            if self._modifier is not None and param_stack.empty():
                # Fake a zero on the stack so recall arithmetic continues to work
                param_stack.push(Rpn_Integer(0))
            param_stack.push(var.obj())
            global show_x
            old_show_x = show_x
            if self._modifier == '+':
                w_plus()
            elif self._modifier == '-':
                w_minus()
            elif self._modifier == '*':
                w_star()
            elif self._modifier == '/':
                w_slash()
            show_x = old_show_x

    def patch_recurse(self, new_word):
        pass

    def __str__(self):
        return "@{}{}".format(self._modifier if self._modifier is not None else "",
                              self.identifier())

    def __repr__(self):
        return "Fetch{}[{}]".format(self._modifier if self._modifier is not None else "",
                                    self.identifier())


class Rpn_Float(Rpn_Stackable):
    def __init__(self, val=0.0):
        super().__init__()
        self.set_value(float(val))

    def zerop(self):
        return self.value() == 0.0

    def date_info(self):
        """A float in the form MM.DDYYYY might represent a date.
Extract some information about a date formatted this way.
Success:  (True, dateobj, julian)
          dateobj is datetime.date, julian is an int
Failure:  (False, None, None)"""

        match = date_pat.match("%.6f" % self.value())
        if match is None:
            return (False, None, None)

        mm   = match.group(1)
        dd   = match.group(2)
        yyyy = match.group(3)
        try:
            dateobj = datetime.date(int(yyyy), int(mm), int(dd))
        except ValueError:
            return (False, None, None)

        # date.toordinal() returns 1 for 0001-01-01, so compensate
        julian = dateobj.toordinal() + JULIAN_OFFSET
        return (True, dateobj, julian)

    def time_info(self):
        """A float in the format HH.MMSSssss might represent a time.
Extract some information about a time formatted this way.
Note: This routine can unpack an arbitrary number of hours, potentially
greater than 24, so there may not be a valid timeobj even if it parses okay.
Success:  (True, HH, MM, SS, timeobj)
Failure:  (False, None, None, None, None)"""

        match = time_pat.match("%f" % self.value())
        if match is None:
            return (False, None, None, None, None)

        hh = int(  match.group(1))
        mm = int(  match.group(2))
        ss = float(match.group(3)) / 100.0
        try:
            timeobj = datetime.time(hh, mm, round(ss))
        except ValueError:
            timeobj = None
        return (True, hh, mm, ss, timeobj)

    def __str__(self):
        l = r"  \ " + "{}".format(self.label()) if self.label() is not None else ""
        s = "{}".format(self.value())
        return s + l

    def __repr__(self):
        return "Float[{}]".format(repr(self.value()))


class Rpn_Forget:
    def __init__(self, word, scope):
        if type(word) is not Rpn_Word:
            raise Rpn_E_Fatal("{}: Word {} is not an Rpn_Word".format(whoami(), repr(word)))
        if type(scope) is not Rpn_Scope:
            raise Rpn_E_Fatal("{}: Scope {} is not an Rpn_Scope".format(whoami(), repr(scope)))
        self._word = word
        self._scope = scope

    def __call__(self):
        dbg("trace", 1, "trace({})".format(repr(self)))
        if self._word.protected():
            raise Rpn_E_Runtime_Error("forget: '{}' is protected".format(self._word.name()))
        self._scope.delete_word(self._word.name())

    def patch_recurse(self, new_word):
        pass

    def __str__(self):
        return "forget {}".format(self._word.name())

    def __repr__(self):
        return "Forget[{}]".format(repr(self._word.name()))


class Rpn_Help:
    def __init__(self, ident, doc):
        self._identifier = ident
        self._doc = doc

    def __call__(self):
        dbg("trace", 1, "trace({})".format(repr(self)))
        lnwriteln(self.doc())

    def identifier(self):
        return self._identifier

    def doc(self):
        return self._doc

    def patch_recurse(self, new_word):
        pass

    def __str__(self):
        return "help {}".format(self.identifier())

    def __repr__(self):
        return "Help[{}]".format(repr(self.identifier()))


class Rpn_If:
    def __init__(self, seq):
        self._seq = seq

    def __call__(self):
        dbg("trace", 2, "trace({})".format(repr(self)))
        if param_stack.empty():
            raise Rpn_E_Runtime_Error("if: Insufficient parameters (1 required)")
        flag = param_stack.pop()
        if type(flag) is not Rpn_Integer:
            param_stack.push(flag)
            raise Rpn_E_Type_Error("if: Flag must be an integer")
        if flag.value() != 0:
            self._seq.__call__()

    def patch_recurse(self, new_word):
        self._seq.patch_recurse(new_word)

    def __str__(self):
        return "if {} then".format(self._seq)

    def __repr__(self):
        return "If[{}]".format(repr(self._seq))


class Rpn_If_Else:
    def __init__(self, seq1, seq2):
        self._seq1 = seq1
        self._seq2 = seq2

    def __call__(self):
        dbg("trace", 2, "trace({})".format(repr(self)))
        if param_stack.empty():
            raise Rpn_E_Runtime_Error("if: Insufficient parameters (1 required)")
        flag = param_stack.pop()
        if type(flag) is not Rpn_Integer:
            param_stack.push(flag)
            raise Rpn_E_Type_Error("if: Flag must be an integer")
        if flag.value() != 0:
            self._seq1.__call__()
        else:
            self._seq2.__call__()

    def patch_recurse(self, new_word):
        self._seq1.patch_recurse(new_word)
        self._seq2.patch_recurse(new_word)

    def __str__(self):
        return "if {} else {} then".format(self._seq1, self._seq2)

    def __repr__(self):
        return "IfElse[{}, {}]".format(repr(self._seq1), repr(self._seq2))


class Rpn_Integer(Rpn_Stackable):
    def __init__(self, val=0):
        super().__init__()
        self.set_value(int(val))

    def zerop(self):
        return self.value() == 0

    def __str__(self):
        s = "{}".format(self.value())
        l = r"  \ " + "{}".format(self.label()) if self.label() is not None else ""
        return s + l

    def __repr__(self):
        return "Integer[{}]".format(repr(self.value()))


class Rpn_List:
    def __init__(self, item=None, oldlist=None):
        if item is None and oldlist is None:
            self._list = []
        elif item is not None and oldlist is None:
            self._list = [ item ]
        else:
            val = []
            for x in oldlist.listval():
                val.append(x)
            val.insert(0, item)
            self._list = val

    def listval(self):
        return self._list

    def __getitem__(self, i):
        return self._list[i]

    def __setitem__(self, i, val):
        self._list[i] = val

    def append(self, item):
        self._list.append(item)

    def __call__(self):
        dbg("trace", 2, "trace({})".format(repr(self)))
        for item in self.listval():
            # lnwriteln("{}: {}.__call__()".format(whoami(), item))
            item.__call__()

    def items(self):
        for item in self.listval():
            yield item

    def patch_recurse(self, new_word):
        for item in self.listval():
            item.patch_recurse(new_word)

    def __len__(self):
        return len(self.listval())

    def __str__(self):
        return " ".join([ str(item) for item in self.listval() ])

    def __repr__(self):
        return "List[" + ", ".join([ repr(item) for item in self.listval() ]) + "]"


class Rpn_Matrix(Rpn_Stackable):
    def __init__(self, vals):
        if not have_numpy:
            raise Rpn_E_Runtime_Error("Matrices require 'numpy' library")
        super().__init__()
        #lnwriteln("{}: vals={}".format(whoami(), repr(vals)))
        self._nrows = len(vals)
        cols = -1
        vecs = []
        for x in vals.items():
            #lnwriteln("x={}".format(repr(x)))
            vecs.append(x.value())
            if cols == -1:
                cols = x.size()
            else:
                if x.size() != cols:
                    raise Rpn_E_Runtime_Error("Matrix: Number of columns is not consistent")
        self._ncols = cols
        #lnwriteln("{} rows x {} columns".format(self.nrows(), self.ncols()))
        #print("vecs", vecs)
        self.set_value(np.array(vecs))
        #print("val",repr(self.value()))

    @classmethod
    def from_numpy(cls, x):
        obj = cls(Rpn_List())
        obj._nrows, obj._ncols = x.shape
        obj.set_value(x)
        return obj

    def nrows(self):
        return self._nrows

    def ncols(self):
        return self._ncols

    def __str__(self):
        return str(self.value())

    def __repr__(self):
        return "Matrix[{}]".format(repr(self.value()))


class Rpn_Queue:
    def __init__(self):
        self._q = queue.SimpleQueue()

    def empty(self):
        return self._q.empty()

    def get(self):
        return self._q.get_nowait()

    def put(self, item):
        self._q.put(item)


class Rpn_Rational(Rpn_Stackable):
    def __init__(self, num=0, denom=1):
        super().__init__()
        self.set_value(Fraction(int(num), int(denom)))

    @classmethod
    def from_Fraction(cls, frac):
        return cls(frac.numerator, frac.denominator)

    @classmethod
    def from_string(cls, s):
        match = rational_pat.match(s)
        if match is None:
            raise Rpn_E_Fatal("Rational pattern failed to match '{}'".format(s))
        return cls(match.group(1), match.group(2))

    def numerator(self):
        return self.value().numerator

    def denominator(self):
        return self.value().denominator

    def set_num_denom(self, num, denom):
        self._value = Fraction(int(num), int(denom))

    def zerop(self):
        return self.numerator() == 0

    def __str__(self):
        s = "{}::{}".format(self.numerator(), self.denominator())
        l = r"  \ {}".format(self.label()) if self.label() is not None else ""
        return s + l

    def __repr__(self):
        return "Rational[{}]".format(repr(self.value()))


class Rpn_Recurse:
    def __init__(self, target=None):
        if target is not None and type(target) is not Rpn_Word:
            raise Rpn_E_Fatal("{}: Target '{}' is not an Rpn_Word".format(whoami(), repr(target)))
        self._target = target

    def __call__(self):
        dbg("trace", 1, "trace({})".format(repr(self)))
        if self.target() is None:
            raise Rpn_E_Runtime_Error("recurse: Only valid in colon definition")
        self.target().__call__()

    def target(self):
        return self._target

    def patch_recurse(self, new_word):
        if self.target() is None:
            self._target = new_word
        else:
            raise Rpn_E_Fatal("{}: Invoked on already patched Rpn_Recurse object".format(whoami()))

    def __str__(self):
        return "recurse"

    def __repr__(self):
        if self.target() is None:
            return "Recurse[]"
        return "RWord[{}]".format(repr(self.target().name()))


class Rpn_Scope:
    def __init__(self, name):
        self._name = name
        self._words = {}
        self._variables = {}
        self._all_varnames = Rpn_List() # Isn't varnames simply the key name for the variables dictionary?
        self._in_varnames  = Rpn_List()
        self._out_varnames = Rpn_List()

    def name(self):
        return self._name

    def words(self):
        return self._words

    def variables(self):
        return self._variables

    def set_word(self, identifier, word):
        if type(word) is not Rpn_Word:
            raise Rpn_E_Fatal("{}: Word {} is not an Rpn_Word".format(whoami(), identifier))

        if default_protected:
            if (word.doc() is None or len(word.doc()) == 0) and not word.hidden():
                print("Warning: Word '{}' has no documentation".format(identifier)) # OK
            # if word.args() is None:
            #     print("Warning: Word '{}' has no args!".format(identifier)) # OK

        self._words[identifier] = word

    def delete_word(self, identifier):
        del self._words[identifier]

    def word(self, identifier):
        return self._words.get(identifier)

    def set_variable(self, identifier, var):
        if type(var) is not Rpn_Variable:
            raise Rpn_E_Fatal("{}: Variable {} is not an Rpn_Variable".format(whoami(), identifier))
        dbg(whoami(), 1, "{}: Setting variable '{}' to {} in {}".format(whoami(), identifier, repr(var), repr(self)))
        self._variables[identifier] = var

    def add_varname(self, name):
        self._all_varnames.append(name)

    def all_varnames(self):
        return self._all_varnames

    def set_all_varnames(self, l):
        self._all_varnames = l

    def set_in_varnames(self, l):
        # l is an Rpn_List of 'str'ings
        self._in_varnames = l

    def in_varnames(self):
        return self._in_varnames

    def set_out_varnames(self, l):
        # l is an Rpn_List of 'str'ings
        self._out_varnames = l

    def out_varnames(self):
        return self._out_varnames

    def delete_variable(self, identifier):
        del self._variables[identifier]

    def variable(self, identifier):
        return self._variables.get(identifier)

    def visible_variables(self):
        return list(filter(lambda x: not x[1].hidden(), self.variables().items()))

    def unprotected_words(self):
        return list(filter(lambda x: not x[1].protected(), self.words().items()))

    def decorate_varname(self, varname):
        if varname in self.in_varnames() and varname in self.out_varnames():
            return "inout:{}".format(varname)
        if varname in self.in_varnames():
            return "in:{}".format(varname)
        if varname in self.out_varnames():
            return "out:{}".format(varname)
        return varname

    def __str__(self):
        # XXX Fix variable visibility
        s = ""
        #if len(self.visible_variables()) > 0:
        if len(self.all_varnames()) > 0:
            #s += "|" + " ".join([ self.decorate_varname(x[0]) for x in self.visible_variables() ]) + "|"
            s += "|" + " ".join([ self.decorate_varname(x) for x in self.all_varnames() ]) + "|"
            if len(self.words()) > 0:
                s += " "
        if len(self.words()) > 0:
            s += " ".join([ w.as_definition() for w in self.words().values() ])
        return s

    def __repr__(self):
        return "Scope['{}'={}]".format(self.name(), hex(id(self)))


class Rpn_Sequence:
    def __init__(self, scope_template, exe_list):
        self._scope_template = scope_template
        self._exe_list       = exe_list
        dbg(whoami(), 1, "{}: scope_template={}, exe_list={}".format(whoami(), repr(scope_template), repr(exe_list)))

    def __call__(self):
        dbg("trace", 2, "trace({})".format(repr(self)))

        # Build a runtime scope populated with actual Rpn_Variables.
        # We need to create a new empty scope, populate it with new
        # variables which are named clones of the templates in the
        # sequence's scope, and then push that new scope.  This
        # ensure that each frame gets its own set of local
        # variables.

        if self.scope_template().name()[:6] == "Parse_":
            scope_name = "Call_" + self.scope_template().name()[6:]
        else:
            scope_name = "Call_" + self.scope_template().name()
        scope = Rpn_Scope(scope_name)
        # XXX what about kwargs???
        for varname in self.scope_template().all_varnames():
            var = Rpn_Variable(varname, None)
            scope.set_variable(varname, var)

        if len(self.scope_template().in_varnames()) > 0:
            if param_stack.size() < len(self.scope_template().in_varnames()):
                raise Rpn_E_Runtime_Error("{}: Insufficient parameters ({} required)".format(self.scope_template().name(), len(self.scope_template().in_varnames())))
            in_vars = []
            for varname in self.scope_template().in_varnames().items():
                in_vars.append(varname)
            in_vars.reverse()
            for varname in in_vars:
                obj = param_stack.pop()
                dbg(whoami(), 1, "{}: Setting {} to {}".format(whoami(), varname, obj.value()))
                scope.variable(varname).set_obj(obj)

        dbg(whoami(), 1, "{}: seq={}".format(whoami(), repr(self.seq())))
        pushed_scope = False

        try:
            push_scope(scope, "Calling {}".format(repr(self)))
            pushed_scope = True
            self.seq().__call__()
        except Rpn_E_Exit:
            raise
        finally:
            if len(self.scope_template().out_varnames()) > 0:
                param_stack_pushes = 0
                for varname in self.scope_template().out_varnames().items():
                    var = scope.variable(varname)
                    if var is None:
                        raise Rpn_E_Runtime_Error("{}: {}: Variable '{}' has vanished!".format(whoami(), self.scope_template().name(), varname))
                    if not var.defined():
                        # Undo any previous param_stack pushes if we come across an out variable that's not defined
                        for _ in range(param_stack_pushes):
                            param_stack.pop()
                        raise Rpn_E_Runtime_Error("{}: Variable '{}' was never set".format(self.scope_template().name(), varname))
                    dbg(whoami(), 1, "{} is {}".format(varname, repr(var.obj())))
                    param_stack.push(var.obj())
                    param_stack_pushes += 1
            if pushed_scope:
                pop_scope("{} complete".format(repr(self)))

    def patch_recurse(self, new_word):
        for idx, _ in enumerate(self.seq().items()):
            self.seq()[idx].patch_recurse(new_word)

    def scope_template(self):
        return self._scope_template

    def seq(self):
        return self._exe_list

    def __str__(self):
        scope_str = str(self.scope_template())
        s = "{}{}{}".format(scope_str,
                            " " if len(scope_str) > 0 and len(self.seq()) > 0 else "",
                            str(self.seq()))
        return s

    def __repr__(self):
        return "Sequence[{}, {}]".format(repr(self.scope_template()), repr(self.seq()))


class Rpn_Show:
    def __init__(self, word, scope):
        if type(word) is not Rpn_Word:
            raise Rpn_E_Fatal("{}: Word {} is not an Rpn_Word".format(whoami(), repr(word)))
        if type(scope) is not Rpn_Scope:
            raise Rpn_E_Fatal("{}: Scope {} is not an Rpn_Scope".format(whoami(), repr(scope)))
        self._word = word
        self._scope = scope

    def __call__(self):
        dbg("trace", 1, "trace({})".format(repr(self)))
        writeln(self._word.as_definition())

    def patch_recurse(self, new_word):
        pass

    def __str__(self):
        return "show {}".format(self._word.name())

    def __repr__(self):
        return "Show[{}]".format(repr(self._word.name()))


class Rpn_Stack:
    def __init__(self, min_size=0, max_size=-1):
        self._min_size = min_size
        self._max_size = max_size
        self.clear()

    def clear(self):
        self._stack = []
        self._nitems = 0

    def size(self):
        return self._nitems

    def empty(self):
        return self.size() == 0

    def push(self, item):
        if self.size() == self._max_size:
            raise Rpn_E_Stack_Overflow("Stack overflow ({}) on {}".format(self._max_size, item))
        self._nitems += 1
        self._stack.append(item)

    def pop(self):
        if self.empty():
            raise Rpn_E_Fatal("{}: Empty stack".format(whoami()))
        if self.size() == self._min_size:
            raise Rpn_E_Stack_Underflow("Stack underflow ({})".format(self._min_size))
        self._nitems -= 1
        return self._stack.pop()

    def pick(self, n):
        if n < 0 or n >= self.size():
            raise Rpn_E_Fatal("{}: Bad index".format(whoami()))
        return self._stack[self.size() - 1 - n]

    def roll(self, n):
        if n < 0 or n >= self.size():
            raise Rpn_E_Fatal("{}: Bad index".format(whoami()))
        # Prevent stack underflow in unlucky situations.  Temporarily
        # increase the stack minimum size, because we're just going to
        # push an item back again to restore the situation.
        self._min_size += 1
        item = self._stack.pop(self.size() - 1 - n)
        self._nitems -= 1
        self._min_size -= 1
        self.push(item)

    def top(self):
        if self.empty():
            raise Rpn_E_Fatal("{}: Empty stack".format(whoami()))
        return self._stack[self.size() - 1]

    def items_bottom_to_top(self):
        """Return stack items from bottom to top."""
        i = self._nitems + 1
        for item in self._stack:
            i -= 1
            yield (i-1, item)

    def items_top_to_bottom(self):
        """Return stack items from top to bottom."""
        return reversed(list(self.items_bottom_to_top()))

    def __str__(self):
        sa = []
        for (i, item) in self.items_bottom_to_top():
            sa.append("{}: {}".format(i, fmt(item)))
        #print(sa)
        return "\n".join(sa)

    def __repr__(self):
        sa = []
        for (i, item) in self.items_bottom_to_top():
            sa.append("{}: {}".format(i, repr(item)))
        #print(sa)
        return "Stack[{}]".format(", ".join(sa))


class Rpn_Store_Var:
    """Store variable.

In addition to storing a value directly in a variable,
"storage arithmetic" modifies the variable's value in an
additional way: using the TOS value,
        Variable New value = Previous value +|-|*|/ TOS
The TOS is consumed as normal."""

    def __init__(self, ident, modifier=None):
        self._identifier = ident
        self._modifier   = modifier

    def identifier(self):
        return self._identifier

    def __call__(self):
        dbg("trace", 1, "trace({})".format(repr(self)))
        (var, _) = lookup_variable(self.identifier())
        stringp = bool(self._modifier == '$')
        if var is None:
            raise Rpn_E_Fatal("{}: Variable has vanished!".format(str(self)))
        if var.readonly():
            raise Rpn_E_Runtime_Error("{}: Variable cannot be modified".format(str(self)))
        if var.constant():
            raise Rpn_E_Runtime_Error("{}: Constant cannot be modified".format(str(self)))
        if stringp and string_stack.empty():
            raise Rpn_E_Runtime_Error("{}: Insufficient string parameters (1 required)".format(str(self)))
        if not stringp and param_stack.empty():
            raise Rpn_E_Runtime_Error("{}: Insufficient parameters (1 required)".format(str(self)))
        if self._modifier == '/' and param_stack.top().zerop():
            raise Rpn_E_Value_Error("{}: X cannot be zero".format(str(self)))

        cur_obj = var.obj()
        new_obj = string_stack.top() if stringp else param_stack.top()
        for pre_hook_func in var.pre_hooks():
            try:
                pre_hook_func(self.identifier(), cur_obj, new_obj)
            except Rpn_E_Runtime_Error as e:
                lnwriteln(str(e))
                return

        if not stringp and self._modifier is not None:
            param_stack.push(cur_obj)
            w_swap()
            if self._modifier == '+':
                w_plus()
            elif self._modifier == '-':
                w_minus()
            elif self._modifier == '*':
                w_star()
            elif self._modifier == '/':
                w_slash()

        old_obj = cur_obj
        var.set_obj(new_obj)
        cur_obj = var.obj()
        if stringp:
            string_stack.pop()
        else:
            param_stack.pop()

        for post_hook_func in var.post_hooks():
            post_hook_func(self.identifier(), old_obj, cur_obj)

    def patch_recurse(self, new_word):
        pass

    def __str__(self):
        return "!{}{}".format(self._modifier if self._modifier is not None else "",
                              self.identifier())

    def __repr__(self):
        return "Store{}[{}]".format(self._modifier if self._modifier is not None else "",
                                    self.identifier())


class Rpn_String:
    def __init__(self, val):
        self._value = val

    @classmethod
    def from_string(cls, s):
        return cls("{}".format(s))

    def value(self):
        return self._value

    def set_value(self, val):
        self._value = val

    def __call__(self):
        dbg("trace", 1, "trace({})".format(repr(self)))
        string_stack.push(self)

    def patch_recurse(self, new_word):
        pass

    def __str__(self):
        return "\"{}\"".format(str(self.value()))

    def __repr__(self):
        return "String[{}]".format(repr(self.value()))


class Rpn_Token_Mgr:
    qtok = Rpn_Queue()
    e = 0

    @classmethod
    def get_more_tokens(cls):
        tok_count = 0
        data = ""
        global sharpout
        prompt = prompt_string()
        global show_x

        # Read characters from input stream
        while data == "":
            if show_x and not param_stack.empty():
                writeln("{}".format(fmt(param_stack.top())))
            show_x = False

            lnwrite()
            sharpout.set_obj(Rpn_Integer(len(prompt)))
            data = input(prompt)
            sharpout.set_obj(Rpn_Integer(0))

        # Get all the tokens
        lexer.input(data)
        while True:
            tok = lexer.token()
            if not tok:
                break
            cls.qtok.put(tok)
            dbg("token", 3, "Lexer returned {}, queueing".format(tok))
            tok_count += 1

        return tok_count

    @classmethod
    def next_token(cls):
        global got_interrupt
        if cls.qtok.empty():
            if cls.e == 0:
                new_toks = 0
                while new_toks == 0:
                    try:
                        new_toks = Rpn_Token_Mgr.get_more_tokens()
                    except EOFError:
                        # ^D (eof) on input signals end of input tokens
                        lnwrite()
                        return
                    except KeyboardInterrupt:
                        # ^C can either void the parse_stack, or the end program
                        if parse_stack.empty():
                            if got_interrupt:
                                raise Rpn_E_End_Program()
                            lnwriteln("[Interrupt; once more to quit]")
                            got_interrupt = True
                            continue
                        lnwriteln("[Interrupt]")
                        raise Rpn_E_Top_Level()
                    else:
                        got_interrupt = False

        try:
            yield cls.qtok.get()
        except queue.Empty:
            return


class Rpn_Variable:
    def __init__(self, rawname, obj=None, **kwargs):
        global default_protected

        if not Rpn_Variable.name_valid_p(rawname):
            raise Rpn_E_Fatal("Invalid variable name '{}'".format(rawname))

        self._constant   = False
        self._doc        = None
        self._hidden     = False
        self._rawname    = rawname
        self._noshadow   = False
        self._protected  = default_protected
        self._readonly   = False
        self._rpnobj     = obj
        self._pre_hooks  = []
        self._post_hooks = []

        # `constant' is created by user word "constant".  Constants are
        # initialized from the paramteter stack and cannot be modified
        # after creation.
        if "constant" in kwargs:
            self._constant = kwargs["constant"]
            del kwargs["constant"]

        # `doc' is the variable's documentation string.  For future use,
        # not currently implemented.
        if "doc" in kwargs:
            self._doc = kwargs["doc"]
            del kwargs["doc"]

        # `hidden' means that the variable does not appear in the VARS
        # command.  In all other respects (lookup, store, fetch) the
        # variable behaves normally.
        if "hidden" in kwargs:
            self._hidden = kwargs["hidden"]
            del kwargs["hidden"]

        # `noshadow' means that no variable of the same name can be
        # created in a lower scope.  This ensures that every operation
        # will find the original variable.
        if "noshadow" in kwargs:
            self._noshadow = kwargs["noshadow"]
            del kwargs["noshadow"]

        # `protected' variables cannot be UNDEFined.  However, they can
        # be modified or shadowed.
        if "protected" in kwargs:
            self._protected = kwargs["protected"]
            del kwargs["protected"]

        # `readonly' means variable may not be modified by the user.
        # Very similar to constant.  Users cannot create readonly variables,
        # only constants.  One previous difference was it was supposed
        # to be a syntax error to attempt to modify a constant, while it
        # was a runtime error to attempt to modify a readonly variable.
        # This distinction is not currently enforced.
        if "readonly" in kwargs:
            self._readonly = kwargs["readonly"]
            del kwargs["readonly"]

        # `pre_hooks' is a list of functions that are called before a
        # user-mode "!VAR" or "undef VAR".  It is called with the
        # following parameters: variable name, old object (be sure to
        # take .value()), and the new proposed value.  For "undef", new
        # value is None.  If system wants to prevent the change, the
        # pre_hook function should raise a Rpn_E_Runtime_Error
        # exception.  Nothing needs to be returned.
        if "pre_hooks" in kwargs:
            self._pre_hooks = kwargs["pre_hooks"]
            del kwargs["pre_hooks"]

        # `post_hooks' is a list of functions that are called after a
        # user-mode "!VAR" or "undef VAR".  It is used to update other
        # things that depend on the variable's new value.  Two
        # parameters are passed: the variable name, and some object:
        # usually the new value object, but if the variable is deleted
        # then None will be passed.  Nothing needs to be returned, and
        # no exceptions should be raised.
        if "post_hooks" in kwargs:
            self._post_hooks = kwargs["post_hooks"]
            del kwargs["post_hooks"]

        # If there are any keywords left over, they must be ones we
        # don't know about and we want to flag them as errors.
        if len(kwargs) > 0:
            for (key, val) in kwargs.items():
                print("Unrecognized keyword '{}'={}".format(key, val)) # OK
                raise Rpn_E_Fatal("Could not construct variable '{}'".format(rawname))

    @classmethod
    def name_valid_p(cls, name):
        return not (name is None or len(name) == 0 or \
                    name[0] in ['+', '-', '*', '/', '?'])

    def obj(self):
        return self._rpnobj

    def set_obj(self, newobj):
        self._rpnobj = newobj

    def name(self):
        return self._rawname

    def defined(self):
        return self.obj() is not None

    def constant(self):
        return self._constant

    def hidden(self):
        return self._hidden

    def noshadow(self):
        return self._noshadow

    def protected(self):
        return self._protected

    def readonly(self):
        return self._readonly

    def pre_hooks(self):
        return self._pre_hooks

    def post_hooks(self):
        return self._post_hooks

    def __str__(self):
        return str(self._rawname)

    def __repr__(self):
        return "Variable[{},addr={},value={}]".format(self._rawname, hex(id(self)), repr(self.obj()))


class Rpn_Vector(Rpn_Stackable):
    def __init__(self, vals):
        if not have_numpy:
            raise Rpn_E_Runtime_Error("Vectors require 'numpy' library")
        super().__init__()
        if type(vals) is not Rpn_List:
            raise Rpn_E_Fatal("{}: vals is not an Rpn_List ({})".format(whoami(), repr(vals)))
        self.set_value(np.array([ elem.value() for elem in vals.listval() ]))

    @classmethod
    def from_numpy(cls, x):
        obj = cls(Rpn_List())
        # print(type(obj))
        # print("from_numpy: {}".format(repr(obj)))
        obj.set_value(x)
        # print("from_numpy: {}".format(repr(obj)))
        return obj

    def size(self):
        return self.value().size

    def __str__(self):
        if self.size() == 0:
            return "[]"
        return "[ " + " ".join([ str(to_rpn_class(e)) for e in self.value() ]) +" ]"

    def __repr__(self):
        return "Vector[{}]".format(repr(self.value()))


class Rpn_Word:
    def __init__(self, name, defn, **kwargs):
        global default_protected

        self._args      = 0
        self._defn      = defn  # Rpn_Sequence
        self._doc       = None
        self._hidden    = False
        self._name      = name
        self._protected = default_protected
        self._str_args  = 0

        my_print_x = None

        if name is None or len(name) == 0:
            raise Rpn_E_Fatal("Invalid word name '{}'".format(name))
        if defn is None:
            raise Rpn_E_Fatal("{}: defn is None".format(name))
        #dbg(whoami(), 3, "defn is {}".format(type(defn)))

        if "args" in kwargs:
            self._args = kwargs['args']
            del kwargs["args"]

        if "doc" in kwargs:
            self._doc = kwargs["doc"]
            del kwargs["doc"]

        if "hidden" in kwargs:
            self._hidden = kwargs["hidden"]
            del kwargs["hidden"]

        if "print_x" in kwargs:
            my_print_x = kwargs["print_x"]
            del kwargs["print_x"]

        if "protected" in kwargs:
            self._protected = kwargs["protected"]
            del kwargs["protected"]

        if "str_args" in kwargs:
            self._str_args = kwargs["str_args"]
            del kwargs["str_args"]

        if len(kwargs) > 0:
            for (key, val) in kwargs.items():
                print("Unrecognized keyword '{}'={}".format(key, val)) # OK
                raise Rpn_E_Fatal("Could not construct word '{}'".format(name))

        kwargs["print_x"] = my_print_x

    def __call__(self):
        dbg("trace", 1, "trace({})".format(repr(self)))
        if param_stack.size() < self.args():
            raise Rpn_E_Runtime_Error("{}: Insufficient parameters ({} required)".format(self.name(), self.args()))
        if string_stack.size() < self.str_args():
            raise Rpn_E_Runtime_Error("{}: Insufficient string parameters ({} required)".format(self.name(), self.str_args()))

        try:
            self._defn.__call__()
        except Rpn_E_Exit:
            if self.name() == "exit":
                raise

    def name(self):
        return self._name

    def args(self):
        return self._args

    def str_args(self):
        return self._str_args

    def doc(self):
        return self._doc

    def hidden(self):
        return self._hidden

    def protected(self):
        return self._protected

    def as_definition(self):
        if typename(self._defn) == 'function':
            return self.name()
        if type(self._defn) is Rpn_Sequence:
            return ": {} {}{} ;".format(self.name(),
                                        'doc:"{}"\n'.format(self.doc()) if self.doc() is not None and len(self.doc()) > 0 else "",
                                        str(self._defn))
        raise Rpn_E_Fatal("{}: Unhandled type {}".format(whoami(), type(self._defn)))

    def __str__(self):
        return self.name()

    def patch_recurse(self, new_word):
        pass

    def __repr__(self):
        return "Word[{}]".format(self.name())
        # if typename(self._defn) == 'function':
        #     return "Word[{}]".format(self.name())
        # else:
        #     return "Word[{}, {}]".format(self.name(), repr(self._defn))




#############################################################################
#
#       L E X E R
#
#############################################################################
reserved_words = {
    '+loop'     : 'PLUS_LOOP',
    'again'     : 'AGAIN',
    'begin'     : 'BEGIN',
    'case'      : 'CASE',
    'catch'     : 'CATCH',
    'constant'  : 'CONSTANT',
    'do'        : 'DO',
    'else'      : 'ELSE',
    'endcase'   : 'ENDCASE',
    'endof'     : 'ENDOF',
    'forget'    : 'FORGET',
    'help'      : 'HELP',
    'if'        : 'IF',
    'loop'      : 'LOOP',
    'of'        : 'OF',
    'otherwise' : 'OTHERWISE',
    'recurse'   : 'RECURSE',
    'repeat'    : 'REPEAT',
    'show'      : 'SHOW',
    'then'      : 'THEN',
    'undef'     : 'UNDEF',
    'until'     : 'UNTIL',
    'variable'  : 'VARIABLE',
    'while'     : 'WHILE',
}

tokens = [
    'ABORT_QUOTE',
    'AT_SIGN',
    'CLOSE_BRACKET',
    'CLOSE_PAREN',
    'COLON',
    'COMMA',
    'DOC_STR',
    'DOT_QUOTE',
    'EXCLAM',
    'FLOAT',
    'IDENTIFIER',
    'INTEGER',
    'OPEN_BRACKET',
    'OPEN_PAREN',
    'RATIONAL',
    'SEMICOLON',
    'STRING',
    'VBAR',
    'WS',
] + list(reserved_words.values())

def t_newline(t):
    r'\n+'
    t.lexer.lineno += len(t.value)

def t_STRING(t):
    r'"([^"]|\n)*"'
    #r'"([^"\\]*(\\.[^"\\]*)*)"' # Nice, but doesn't work with multi-line strings
    #r'"(?:[^"\\]++|\\.)*+"'     # This causes a stack overflow
    t.type = 'STRING'
    return t

def t_RATIONAL(t):
    r'\d+::\d+'
    t.type = 'RATIONAL'
    return t

# def t_CMPLX(t):
#     r'\([-+]?(\d+(\.\d*[eE][-+]?\d+|[eE][-+]?\d+|\.\d*))|(\d*(\.\d+[eE][-+]?\d+|[eE][-+]?\d+|\.\d+)),[-+]?(\d+(\.\d*[eE][-+]?\d+|[eE][-+]?\d+|\.\d*))|(\d*(\.\d+[eE][-+]?\d+|[eE][-+]?\d+|\.\d+))\)'
#     t.type = 'CMPLX'
#     return t

def t_FLOAT(t):
    r'[-+]?(\d+(\.\d*[eE][-+]?\d+|[eE][-+]?\d+|\.\d*))|(\d*(\.\d+[eE][-+]?\d+|[eE][-+]?\d+|\.\d+))'
    t.value = str(float(t.value))
    t.type = 'FLOAT'
    return t

# Beware bad input - e.g., "0b177" is parsed as two token, "0b1" and "77".
# Note a little Python magic: int(xxx, 0) will guess base and parse "0x", etc.
# On the whole, the benefits outweigh the drawbacks.
def t_INTEGER(t):
    r'[-+]?((((0x)|(0X))[0-9a-fA-F]+)|(((0o)|(0O))[0-7]+)|(((0b)|(0B))[0-1]+)|(\d+))'
    t.value = str(int(t.value, 0))
    t.type = 'INTEGER'
    return t

def t_ABORT_QUOTE(t):
    r'abort"([^"]|\n)*"'
    return t

def t_AT_SIGN(t):
    r'@'
    t.type = 'AT_SIGN'
    return t

def t_BACKSLASH(t):
    r'\\.*'

    # \ consumes the remainder of the line.
    # Instead of setting type and returning t, doing nothing will ignore
    # the token.  We want this behaviour, because otherwise the
    # BACKSLASH token is returned and the parser attempts to execute it.
    # This is problematic in places where an executable is not expected.
    # For example, consider:
    #     \ This comment is valid.
    #     case
    #        1 of ."Found one" endof
    #        \ This comment is NOT valid because a case-clause is expected.
    #        otherwise ."Found other value"
    #     endcase

def t_CLOSE_PAREN(t):
    r'\)'
    t.type = 'CLOSE_PAREN'
    return t

def t_CLOSE_BRACKET(t):
    r'\]'
    t.type = 'CLOSE_BRACKET'
    return t

def t_COMMA(t):
    r','
    t.type = 'COMMA'
    return t

def t_DOC_STR(t):
    r'doc:"([^"]|\n)*"'
    return t

def t_DOT_QUOTE(t):
    r'\."([^"]|\n)*"'
    return t

def t_EXCLAM(t):
    r'!'
    t.type = 'EXCLAM'
    return t

def t_OPEN_BRACKET(t):
    r'\['
    t.type = 'OPEN_BRACKET'
    return t

def t_OPEN_PAREN(t):
    r'\('
    t.type = 'OPEN_PAREN'
    return t

def t_VBAR(t):
    r'\|'
    t.type = 'VBAR'
    return t

def t_WS(t):
    r'[ \t\n]+'

def t_IDENTIFIER(t):
    r'[-#$%&\*+,./:;<=>?A-Z^_a-z~][-!"#$%&\'*+,./0-9:;<=>?@A-Z^_a-z~]*'

    single_chars = {
        ':': 'COLON',
        ';': 'SEMICOLON',
    }
    if len(t.value) == 1:
        if t.value in single_chars:
            t.type = single_chars[t.value]
    else:
        #print("ID:'{}'".format(t.value))
        t.type = reserved_words.get(t.value, 'IDENTIFIER')
    return t

def t_error(t):
    #print("Illegal character '%s'" % t.value[0])
    t.value = t.value[0]
    t.type = 'ERROR'
    t.lexer.skip(1)
    return t




#############################################################################
#
#       P A R S E R
#
#############################################################################
def p_empty(p):
    '''empty :'''

    pass

def p_error(p):
    raise Rpn_E_Parse_Error(p if p is not None else 'EOF')


def p_evaluate(p):
    '''evaluate : cmd
                | cmd evaluate'''

def p_cmd(p):
    '''cmd :  executable  execute'''


def p_executable(p):
    '''executable : abort_quote
                  | begin_again
                  | begin_until
                  | begin_while
                  | case
                  | catch
                  | colon_def
                  | constant
                  | do_loop
                  | do_plusloop
                  | dot_quote
                  | fetch_var
                  | forget
                  | help
                  | if_then
                  | if_else_then
                  | matrix
                  | number
                  | recurse
                  | show
                  | store_var
                  | string
                  | undef
                  | variable
                  | vector
                  | word'''

    p[0] = p[1]
    dbg("p_executable", 1, "p_executable: {}".format(p[0]))

def p_execute(p):
    '''execute : empty'''

    executable = p[-1]
    if executable is None:
        return

    dbg("p_execute", 1, "p_execute: {}".format(repr(executable)))
    execute(executable)


def p_abort_quote(p):
    '''abort_quote : ABORT_QUOTE'''

    p[0] = Rpn_Abort_Quote(p[1])


def p_begin_again(p):
    '''begin_again : BEGIN sequence AGAIN'''

    p[0] = Rpn_Begin_Again(p[2])


def p_begin_until(p):
    '''begin_until : BEGIN sequence UNTIL'''

    p[0] = Rpn_Begin_Until(p[2])


def p_begin_while(p):
    '''begin_while : BEGIN sequence WHILE sequence REPEAT'''

    p[0] = Rpn_Begin_While(p[2], p[4])


def p_case(p):
    '''case : CASE push_case_scope case_causes_list otherwise_list ENDCASE pop_case_scope'''

    p[0] = Rpn_Case(p[3], p[4])

def p_push_case_scope(p):
    '''push_case_scope : empty'''

    scope = Rpn_Scope("Parse_case")
    all_varnames = Rpn_List()
    all_varnames.append("caseval")
    scope.set_all_varnames(all_varnames)
    push_scope(scope, "Parsing Case (vars={})".format(all_varnames))

def p_case_causes_list(p):
    '''case_causes_list : case_clause
                        | case_clause case_causes_list'''

    if len(p) == 2:
        p[0] = Rpn_List(p[1])
    else:
        p[0] = Rpn_List(p[1], p[2])

def p_case_clause(p):
    '''case_clause : INTEGER OF sequence ENDOF'''

    p[0] = Rpn_Case_Clause(p[1], p[3])

def p_otherwise_list(p):
    '''otherwise_list : empty
                      | OTHERWISE sequence'''

    if len(p) == 2:
        p[0] = Rpn_List()
    else:
        p[0] = Rpn_List(p[2])

def p_pop_case_scope(p):
    '''pop_case_scope : empty'''

    pop_scope("Parse Case complete")


def p_catch(p):
    '''catch : CATCH IDENTIFIER'''

    name = p[2]
    (word, scope) = lookup_word(name)
    if word is None:
        lnwriteln("catch: Word '{}' not found".format(name))
        raise SyntaxError

    dbg("catch", 1, "{}: Creating Rpn_Catch obj for {}".format(whoami(), word))
    p[0] = Rpn_Catch(word, scope)


def p_colon_def(p):
    '''colon_def : COLON IDENTIFIER docstring sequence SEMICOLON define_word'''

    # This returns None because `define_word' does all the work
    p[0] = None

def p_define_word(p):
    '''define_word : empty'''

    sequence   = p[-2]
    doc_str    = p[-3]
    identifier = p[-4]
    # lnwriteln("{}: identifier={}  doc_str={}  sequence={}".format(whoami(), identifier, repr(doc_str), repr(sequence)))

    kwargs = dict()
    if doc_str is not None:
        if len(doc_str) < 6 or doc_str[0:5] != 'doc:"' or doc_str[-1] != '"':
            raise Rpn_E_Fatal("{}: Malformed doc_str: '{}'".format(whoami(), doc_str))
        doc_str = doc_str[5:-1]
        kwargs['doc'] = doc_str

    # p_sequence() has already popped the scope for this word, so
    # creating it now in scope_stack.top() will be correct.
    new_word = Rpn_Word(identifier, sequence, **kwargs)
    dbg("p_define_word", 1, "{}: Defining word {}={} in scope {}".format(whoami(), identifier, repr(new_word), repr(scope_stack.top())))
    sequence.patch_recurse(new_word)
    scope_stack.top().set_word(identifier, new_word)

    p[0] = new_word
    dbg("p_define_word", 2, "{}: Returning {}".format(whoami(), repr(p[0])))

def p_docstring(p):
    '''docstring : empty
                 | DOC_STR'''

    p[0] = p[1]

def p_recurse(p):
    '''recurse : RECURSE'''

    p[0] = Rpn_Recurse()

def p_colon_def_error(p):
    '''colon_def : COLON IDENTIFIER docstring error SEMICOLON '''

    lnwriteln("{}: Syntax error in definition".format(p[2]))
    raise SyntaxError


def p_do_loop(p):
    '''do_loop : DO sequence LOOP'''

    p[0] = Rpn_Do_Loop(p[2])


def p_do_plusloop(p):
    '''do_plusloop : DO sequence PLUS_LOOP'''

    p[0] = Rpn_Do_PlusLoop(p[2])


def p_dot_quote(p):
    '''dot_quote : DOT_QUOTE'''

    p[0] = Rpn_Dot_Quote(p[1])


def p_forget(p):
    '''forget : FORGET IDENTIFIER'''

    name = p[2]
    (word, scope) = lookup_word(name)
    if word is None:
        lnwriteln("forget: Word '{}' not found".format(name))
        raise SyntaxError

    p[0] = Rpn_Forget(word, scope)


def p_help(p):
    '''help : HELP AGAIN
            | HELP BEGIN
            | HELP CASE
            | HELP CATCH
            | HELP COLON
            | HELP CONSTANT
            | HELP DO
            | HELP DOT_QUOTE
            | HELP ELSE
            | HELP ENDCASE
            | HELP ENDOF
            | HELP FORGET
            | HELP HELP
            | HELP IDENTIFIER
            | HELP IF
            | HELP LOOP
            | HELP OF
            | HELP OTHERWISE
            | HELP PLUS_LOOP
            | HELP RECURSE
            | HELP REPEAT
            | HELP SEMICOLON
            | HELP SHOW
            | HELP THEN
            | HELP UNDEF
            | HELP UNTIL
            | HELP VARIABLE
            | HELP WHILE'''

    name = p[2]
    (word, _) = lookup_word(name)
    if word is None:
        lnwriteln("help: Word '{}' not found".format(name))
        raise SyntaxError

    p[0] = Rpn_Help(name, word.doc() if word.doc() is not None \
                                    and len(word.doc()) > 0 \
                    else "No help available for '{}'".format(name))


def p_if_then(p):
    '''if_then : IF sequence THEN'''

    p[0] = Rpn_If(p[2])


def p_if_else_then(p):
    '''if_else_then : IF sequence ELSE sequence THEN'''

    p[0] = Rpn_If_Else(p[2], p[4])


def p_show(p):
    '''show : SHOW IDENTIFIER'''

    name = p[2]
    (word, scope) = lookup_word(name)
    if word is None:
        lnwriteln("show: Word '{}' not found".format(name))
        raise SyntaxError

    p[0] = Rpn_Show(word, scope)


def p_store_var(p):
    '''store_var : EXCLAM IDENTIFIER'''

    ident = p[2]
    if ident[0] in ['+', '-', '*', '/', '$']:
        modifier = ident[0]
        ident = ident[1:]
    else:
        modifier = None
    if not Rpn_Variable.name_valid_p(ident):
        lnwriteln("!: Variable name '{}' not valid".format(ident))
        raise SyntaxError
    dbg(whoami(), 1, "{}: Looking up {}".format(whoami(), ident))
    (varname, _) = lookup_varname(ident)
    if varname is None:
        lnwriteln("!: Variable '{}' not found".format(ident))
        raise SyntaxError
    p[0] = Rpn_Store_Var(ident, modifier)


# A "word" is not just an identifier: a word is something that is
# findable somewhere in the scope_stack.  It is a syntax error if
# the identifier is not found.
def p_word(p):
    '''word : IDENTIFIER'''

    name = p[1]
    (word, _) = lookup_word(name)
    if word is None:
        lnwriteln("Word '{}' not found".format(name))
        raise SyntaxError

    p[0] = word


def p_sequence(p):
    '''sequence : locals_scope executables_list'''

    # `locals_scope' is an Rpn_Scope; `executables_list' is an Rpn_List
    #scope = pop_scope("p_sequence() is finishing")
    pop_scope("p_sequence() is finishing")
    p[0] = Rpn_Sequence(p[1], p[2])


def p_locals_scope(p):
    '''locals_scope : empty
                    | VBAR ids_list VBAR'''

    scope_name = None
    idx = -1
    while scope_name is None:
        if p[idx] in ['begin', 'do', 'else', 'if', 'otherwise']:
            scope_name = p[idx]
        elif p[idx] == 'of':
            scope_name = "of_" + p[idx - 1]
        elif p[idx] == ':':
            scope_name = p[idx + 1]
        else:
            # lnwriteln("p_locals_scope: Not sure about {}".format(p[idx]))
            # scope_name = "locals"
            idx -= 1

    all_varnames = Rpn_List()
    in_varnames  = Rpn_List()
    out_varnames = Rpn_List()

    scope = Rpn_Scope("Parse_" + scope_name)
    dbg(whoami(), 1, "{}: Creating new scope {}".format(whoami(), repr(scope)))

    if len(p) == 4:
        for varname in p[2].items():
            # Already tested for name_valid_p and noshadow in p_ids_list()
            if varname[:3] == 'in:':
                varname = varname[3:]
                dbg(whoami(), 3, "{} is an IN variable".format(varname))
                in_varnames.append(varname)
            elif varname[:4] == 'out:':
                varname = varname[4:]
                dbg(whoami(), 3, "{} is an OUT variable".format(varname))
                out_varnames.append(varname)
            elif varname[:6] == 'inout:':
                varname = varname[6:]
                dbg(whoami(), 3, "{} is an INOUT variable".format(varname))
                in_varnames.append(varname)
                out_varnames.append(varname)
            dbg(whoami(), 1, "{}: Adding varname '{}'".format(whoami(), varname))
            all_varnames.append(varname)

        scope.set_all_varnames(all_varnames)
        scope.set_in_varnames(in_varnames)
        scope.set_out_varnames(out_varnames)

    push_scope(scope, "New sequence (locals={})".format(all_varnames))
    p[0] = scope


def p_ids_list(p):
    '''ids_list : empty
                | IDENTIFIER ids_list'''

    if len(p) == 2:
        p[0] = Rpn_List()
    elif len(p) == 3:
        ident = p[1]
        if not Rpn_Variable.name_valid_p(ident):
            lnwriteln("|{}|: Variable name is not valid".format(ident))
            raise SyntaxError
        (var, _) = lookup_variable(ident)
        if var is not None and var.noshadow():
            lnwriteln("|{}|: Variable cannot be shadowed".format(ident))
            raise SyntaxError
        p[0] = Rpn_List(p[1], p[2])


def p_executables_list(p):
    '''executables_list : empty
                        | executable executables_list'''

    if len(p) == 2:
        p[0] = Rpn_List()
    elif len(p) == 3:
        if p[1] is None:
            p[0] = p[2]
        else:
            p[0] = Rpn_List(p[1], p[2])
    # lnwriteln("{}: Returning {}".format(whoami(), p[0])))


def p_number(p):
    '''number : real
              | rational
              | complex'''

    p[0] = p[1]


def p_real(p):
    '''real : integer
            | float'''

    p[0] = p[1]


def p_integer(p):
    '''integer : INTEGER'''

    p[0] = Rpn_Integer(p[1])


def p_float(p):
    '''float : FLOAT'''

    p[0] = Rpn_Float(p[1])


def p_rational(p):
    '''rational : RATIONAL'''

    p[0] = Rpn_Rational.from_string(p[1])


def p_complex(p):
    '''complex : OPEN_PAREN real COMMA real CLOSE_PAREN '''

    p[0] = Rpn_Complex(p[2].value(), p[4].value())


def p_string(p):
    '''string : STRING'''

    s = p[1]
    if len(s) < 2 or s[0] != '"' or s[-1] != '"':
        raise Rpn_E_Fatal("{}: Malformed string: '{}'".format(whoami(), s))
    p[0] = Rpn_String(s[1:-1])


def p_vector(p):
    '''vector : OPEN_BRACKET numbers_list CLOSE_BRACKET'''

    if have_numpy:
        p[0] = Rpn_Vector(p[2])
    else:
        raise Rpn_E_Parse_Error("Vectors require 'numpy' library")


def p_numbers_list(p):
    '''numbers_list : empty
                    | number numbers_list'''

    if len(p) == 2:
        p[0] = Rpn_List()
    elif len(p) == 3:
        p[0] = Rpn_List(p[1], p[2])


def p_matrix(p):
    '''matrix : OPEN_BRACKET vectors_list CLOSE_BRACKET'''

    if have_numpy:
        p[0] = Rpn_Matrix(p[2])
    else:
        raise Rpn_E_Parse_Error("Matrices require 'numpy' library")


def p_constant(p):
    '''constant : CONSTANT IDENTIFIER'''

    ident = p[2]
    #print("p_constant {}".format(ident))
    if not Rpn_Variable.name_valid_p(ident):
        lnwriteln("CONSTANT: '{}' is not valid".format(ident))
        raise SyntaxError

    (var, scope) = lookup_variable(ident)
    if var is not None and var.noshadow():
        lnwriteln("CONSTANT: '{}' cannot be shadowed".format(ident))
        raise SyntaxError

    if scope is not None and scope == scope_stack.top():
        lnwriteln("CONSTANT: '{}' redefined".format(ident))
        raise SyntaxError

    var = Rpn_Variable(ident, None, constant=True)
    #print("{}: Creating variable {} at address {} in {}".format(whoami(), ident, hex(id(var)), repr(scope)))
    scope_stack.top().add_varname(ident)
    scope_stack.top().set_variable(ident, var)
    p[0] = Rpn_Constant(var)


def p_undef(p):
    '''undef : UNDEF IDENTIFIER'''

    ident = p[2]
    if not Rpn_Variable.name_valid_p(ident):
        lnwriteln("UNDEF: '{}' is not valid".format(ident))
        raise SyntaxError

    (var, scope) = lookup_variable(ident)
    if var is None:
        lnwriteln("UNDEF: Variable '{}' not found".format(ident))
        raise SyntaxError

    if var.protected():
        lnwriteln("UNDEF: Variable '{}' protected".format(ident))
        raise SyntaxError

    if scope != scope_stack.top():
        lnwriteln("UNDEF: Variable '{}' out of scope".format(ident))
        raise SyntaxError

    cur_obj = var.obj()
    new_obj = None
    for pre_hook_func in var.pre_hooks():
        try:
            pre_hook_func(ident, cur_obj, new_obj)
        except Rpn_E_Runtime_Error as e:
            lnwriteln(str(e))
            return

    old_obj = cur_obj
    scope_stack.top().delete_variable(ident)
    cur_obj = None

    for post_hook_func in var.post_hooks():
        post_hook_func(ident, old_obj, cur_obj)


def p_variable(p):
    '''variable :  VARIABLE IDENTIFIER'''

    ident = p[2]
    if not Rpn_Variable.name_valid_p(ident):
        lnwriteln("VARIABLE: '{}' is not valid".format(ident))
        raise SyntaxError

    (var, scope) = lookup_variable(ident)
    if var is not None and var.noshadow():
        lnwriteln("VARIABLE: '{}' cannot be shadowed".format(ident))
        raise SyntaxError

    if scope is not None and scope == scope_stack.top():
        lnwriteln("VARIABLE: '{}' redefined".format(ident))
        raise SyntaxError

    var = Rpn_Variable(ident)
    dbg(whoami(), 1, "{}: Creating variable {} at address {} in {}".format(whoami(), ident, hex(id(var)), repr(scope_stack.top())))
    scope_stack.top().add_varname(ident)
    scope_stack.top().set_variable(ident, var)


def p_vectors_list(p):
    '''vectors_list : vector
                    | vector vectors_list'''

    #lnwriteln("{}: len={}".format(whoami(), len(p)))
    if len(p) == 2:
        p[0] = Rpn_List(p[1])
    elif len(p) == 3:
        p[0] = Rpn_List(p[1], p[2])


def p_fetch_var(p):
    '''fetch_var : AT_SIGN IDENTIFIER'''

    ident = p[2]
    if ident[0] in ['+', '-', '*', '/', '?', '$']:
        modifier = ident[0]
        ident = ident[1:]
    else:
        modifier = None
    if not Rpn_Variable.name_valid_p(ident):
        writeln("@: Variable name '{}' not valid".format(ident))
        raise SyntaxError
    dbg(whoami(), 1, "{}: Looking up {}".format(whoami(), ident))
    (varname, _) = lookup_varname(ident)
    if varname is None:
        writeln("@: Variable '{}' not found".format(ident))
        raise SyntaxError
    p[0] = Rpn_Fetch_Var(ident, modifier)





#############################################################################
#
#       W O R D   D E F I N I T I O N S
#
#############################################################################
global_scope = Rpn_Scope("GLOBAL")

class defword():
    """Register the following word definition in the global scope"""

    def __init__(self, **kwargs):
        self._kwargs = kwargs

    def __call__(self, f):
        def wrapped_f(**kwargs):
            #print("Decorator args: {}".format(self._kwargs))
            f()
            if "print_x" in self._kwargs and \
               self._kwargs["print_x"] is not None:
                global show_x
                show_x = self._kwargs["print_x"]
        if "name" in self._kwargs and len(self._kwargs["name"]) > 0:
            name = self._kwargs["name"]
            del self._kwargs["name"]
        else:
            raise Rpn_E_Runtime_Error("Missing or invalid \"name\" attribute")
        word = Rpn_Word(name, wrapped_f, **self._kwargs)
        global global_scope
        global_scope.set_word(name, word)
        return wrapped_f


@defword(name='#->$', args=1, print_x=False, doc="""\
Convert top of stack to string  ( n -- )""")
def w_num_to_dollar():
    string_stack.push(Rpn_String("{}".format(fmt(param_stack.pop(), False))))


@defword(name='#in', print_x=False, doc="""\
Read numeric input from the user.  #IN recognizes integers and floats,
but not rationals or complex numbers.  The value is put on the stack.
No prompt is provided.

qv PROMPT""")
def w_number_in():
    global sharpout
    x = ''
    while len(x) == 0:
        try:
            x = input()
            dbg(whoami(), 1, "#in: '{}'".format(x))
        except EOFError:
            raise Rpn_E_Runtime_Error()
        finally:
            sharpout.set_obj(Rpn_Integer(0))

    newlexer = lexer.clone()
    newlexer.input(x)
    tok = newlexer.token()

    if tok.type == 'INTEGER':
        param_stack.push(Rpn_Integer(int(tok.value)))
    elif tok.type == 'FLOAT':
        param_stack.push(Rpn_Float(float(tok.value)))
    else:
        raise Rpn_E_Runtime_Error("#in: Could not parse '{}'".format(x))


@defword(name='$.', str_args=1, print_x=False, doc="""\
Print top item from string stack  [ str -- ]
No extraneous white space or newline is printed.""")
def w_dollar_dot():
    write(string_stack.pop().value())


@defword(name='$.!', hidden=True, print_x=False, str_args=1)
def w_dollar_dot_bang():
    lnwriteln(repr(string_stack.top()))


@defword(name='$in', print_x=False, doc="""\
Read a string from the keyboard.  THe value is placed on the string stack.
No prompt is provided.""")
def w_dollar_in():
    global sharpout
    x = ''
    while len(x) == 0:
        try:
            x = input()
            dbg(whoami(), 1, "$in: '{}'".format(x))
        except EOFError:
            raise Rpn_E_Runtime_Error()
        finally:
            sharpout.set_obj(Rpn_Integer(0))

    string_stack.push(Rpn_String(x))



@defword(name='$.s', print_x=False, doc="""\
Display string stack.""")
def w_dollar_dot_s():
    if not string_stack.empty():
        lnwriteln(string_stack)


@defword(name='$.s!', print_x=False, hidden=True)
def w_dollar_dot_s_bang():
    if not string_stack.empty():
        lnwriteln(repr(string_stack))


@defword(name='$=', str_args=2, doc="""\
Test if two strings are equal  ( -- flag )""")
def w_dollar_equal():
    s1 = string_stack.pop()
    s2 = string_stack.pop()
    param_stack.push(Rpn_Integer(bool_to_int(s1.value() == s2.value())))


@defword(name='$cat', str_args=2, doc="""\
Concatentate two strings.

EXAMPLE:
"foo" "bar" $cat "baz" $cat  =>  "foobarbaz" """)
def w_dollar_cat():
    s1 = string_stack.pop()
    s2 = string_stack.pop()
    string_stack.push(Rpn_String.from_string(s2.value() + s1.value()))


@defword(name='$clst', print_x=False, doc="""\
Clear the string stack""")
def w_dollar_clst():
    string_stack.clear()


@defword(name='$depth', doc="""\
String stack depth  ( -- n )""")
def w_dollar_depth():
    param_stack.push(Rpn_Integer(string_stack.size()))


@defword(name='$drop', str_args=1, doc="""\
Drop top of string stack  ( -- )""")
def w_dollar_drop():
    string_stack.pop()


@defword(name='$len', str_args=1, doc="""\
Length of top element of string stack  ( -- n )""")
def w_dollar_len():
    s = string_stack.top()
    r = len(s.value())
    param_stack.push(Rpn_Integer(r))


@defword(name='$swap', str_args=2, doc="""\
Exchange top two string stack elements  [ "y" "x" -- "x" "y" ]""")
def w_dollar_swap():
    sx = string_stack.pop()
    sy = string_stack.pop()
    string_stack.push(sx)
    string_stack.push(sy)


@defword(name='%', args=2, print_x=True, doc="""\
Percentage  ( base rate -- base percent )

Base is maintained in Y.

DEFINTION:
                 rate
percent = base * ----
                 100""")
def w_percent():
    x = param_stack.pop()
    y = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       and type(y) in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        base = float(y.value())
        rate = float(x.value())
        r = base * rate / 100.0
        if type(x) is Rpn_Integer and type(y) is Rpn_Integer and r.is_integer():
            result = Rpn_Integer(r)
        else:
            result = Rpn_Float(r)
        result.set_label("%")
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("%: Type error ({}, {})".format(typename(y), typename(x)))
    param_stack.push(y)
    param_stack.push(result)


@defword(name='%ch', args=2, print_x=True, doc="""\
Percentage change  ( old new -- %change )

DEFINITION:

          new - old
%Change = --------- * 100
             old

old cannot be zero.""")
def w_percent_ch():
    x = param_stack.pop()
    y = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       and type(y) in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        if y.zerop():
            param_stack.push(y)
            param_stack.push(x)
            raise Rpn_E_Value_Error("%ch: Y cannot be zero")

        old = float(y.value())
        new = float(x.value())
        r = (new - old) * 100.0 / old
        if type(x) is Rpn_Integer and type(y) is Rpn_Integer and r.is_integer():
            result = Rpn_Integer(r)
        else:
            result = Rpn_Float(r)
        result.set_label("%ch")
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("%ch: Type error ({}, {})".format(typename(y), typename(x)))
    # The HP-32SII preserves the Y value (like %) but we do not
    param_stack.push(result)


@defword(name='%t', args=2, print_x=True, doc="""\
Percent of total  ( total amount -- %tot )

DEFINITION:

         amount
%Total = ------ * 100
         total

total cannot be zero.""")
def w_percent_t():
    x = param_stack.pop()
    y = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       and type(y) in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        if y.zerop():
            param_stack.push(y)
            param_stack.push(x)
            raise Rpn_E_Value_Error("%t: Y cannot be zero")

        total  = float(y.value())
        amount = float(x.value())
        r = amount * 100.0 / total
        if type(x) is Rpn_Integer and type(y) is Rpn_Integer and r.is_integer():
            result = Rpn_Integer(r)
        else:
            result = Rpn_Float(r)
        result.set_label("%t")
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("%t: Type error ({}, {})".format(typename(y), typename(x)))
    # The HP-32SII preserves the Y value (like %) but we do not
    param_stack.push(result)


@defword(name='*', args=2, print_x=True, doc="""\
Multiplication  ( y x -- y*x )""")
def w_star():
    """\
|----------+----------+---------+----------+---------+--------+--------|
| Integer  | Integer  | Float   | Rational | Complex |        |        |
| Float    | Float    | Float   | Float    | Complex |        |        |
| Rational | Rational | Float   | Rational | Complex |        |        |
| Complex  | Complex  | Complex | Complex  | Complex |        |        |
| Vector   |          |         |          |         |        |        |
| Matrix   |          |         |          |         |        |        |
|----------+----------+---------+----------+---------+--------+--------|
| ^Y    X> | Integer  | Float   | Rational | Complex | Vector | Matrix |"""
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is Rpn_Integer and type(y) is Rpn_Integer:
        result = Rpn_Integer(y.value() * x.value())
    elif    type(x) is Rpn_Float and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational] \
         or type(y) is Rpn_Float and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(float(y.value()) * float(x.value()))
    elif    type(x) is Rpn_Rational and type(y) in [Rpn_Integer, Rpn_Rational] \
         or type(y) is Rpn_Rational and type(x) in [Rpn_Integer, Rpn_Rational]:
        result = Rpn_Rational.from_Fraction(y.value() * x.value())
    elif    type(x) is Rpn_Complex and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
         or type(y) is Rpn_Complex and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        result = Rpn_Complex.from_complex(complex(y.value()) * complex(x.value()))
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("*: Type error ({}, {})".format(typename(y), typename(x)))
    param_stack.push(result)


@defword(name='*/', args=3, print_x=True, doc="""\
Multiply and divide  ( z y x -- z*y/x )

X cannot be zero.""")
def w_star_slash():
    x = param_stack.pop()
    y = param_stack.pop()
    z = param_stack.pop()
    if    type(x) not in [Rpn_Integer, Rpn_Rational, Rpn_Float, Rpn_Complex] \
       or type(y) not in [Rpn_Integer, Rpn_Rational, Rpn_Float, Rpn_Complex] \
       or type(z) not in [Rpn_Integer, Rpn_Rational, Rpn_Float, Rpn_Complex]:
        param_stack.push(z)
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("*/: Type error ({}, {}, {})".format(typename(z), typename(y), typename(x)))
    if z.zerop():
        param_stack.push(z)
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("*/: X cannot be zero")

    param_stack.push(z)
    param_stack.push(y)
    w_star()
    param_stack.push(x)
    w_slash()


@defword(name='+', args=2, print_x=True, doc="""\
Addition  ( y x -- y+x )""")
def w_plus():
    """\
|----------+----------+---------+----------+---------+--------+--------|
| Integer  | Integer  | Float   | Rational | Complex | Vector | Matrix |
| Float    | Float    | Float   | Float    | Complex | Vector | Matrix |
| Rational | Rational | Float   | Rational | Complex | Vector | Matrix |
| Complex  | Complex  | Complex | Complex  | Complex | Vector | Matrix |
| Vector   | Vector   | Vector  | Vector   | Vector  | Vector |        |
| Matrix   | Matrix   | Matrix  | Matrix   | Matrix  |        | Matrix |
|----------+----------+---------+----------+---------+--------+--------|
| ^Y    X> | Integer  | Float   | Rational | Complex | Vector | Matrix |"""
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is Rpn_Integer and type(y) is Rpn_Integer:
        result = Rpn_Integer(y.value() + x.value())
    elif    type(x) is Rpn_Float and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational] \
         or type(y) is Rpn_Float and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(float(y.value()) + float(x.value()))
    elif    type(x) is Rpn_Rational and type(y) in [Rpn_Integer, Rpn_Rational] \
         or type(y) is Rpn_Rational and type(x) in [Rpn_Integer, Rpn_Rational]:
        result = Rpn_Rational.from_Fraction(y.value() + x.value())
    elif    type(x) is Rpn_Complex and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
         or type(y) is Rpn_Complex and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        result = Rpn_Complex.from_complex(complex(y.value()) + complex(x.value()))
    elif    type(x) is Rpn_Vector and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
         or type(y) is Rpn_Vector and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        r = np.add(y.value(), x.value())
        result = Rpn_Vector.from_numpy(r)
    elif type(x) is Rpn_Vector and type(y) is Rpn_Vector:
        if x.size() != y.size():
            param_stack.push(y)
            param_stack.push(x)
            raise Rpn_E_Value_Error("+: Conformability error: Vectors ({} and {}) are not same size".format(y, x))
        r = np.add(y.value(), x.value())
        # print(type(r))
        # print(r)
        result = Rpn_Vector.from_numpy(r)
    elif    type(x) is Rpn_Matrix and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
         or type(y) is Rpn_Matrix and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        r = np.add(y.value(), x.value())
        result = Rpn_Matrix.from_numpy(r)
    elif type(x) is Rpn_Matrix and type(y) is Rpn_Matrix:
        if x.nrows() != y.nrows() or x.ncols() != y.ncols():
            param_stack.push(y)
            param_stack.push(x)
            raise Rpn_E_Value_Error("+: Conformability error: Matrices ({} and {}) are not same size".format(y, x))
        r = np.add(y.value(), x.value())
        # print(type(r))
        # print(r)
        result = Rpn_Matrix.from_numpy(r)
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("+: Type error ({}, {})".format(typename(y), typename(x)))
    param_stack.push(result)


@defword(name='+loop', doc="""\
Execute a definite loop.
<limit> <initial> DO ... <incr> +LOOP

The iteration counter is available via I.  LEAVE will exit the loop early.

Example: 10 0 do I . 2 +loop
prints 0 2 4 6 8

qv DO, I, LEAVE, LOOP""")
def w_plusloop():
    pass                        # Grammar rules handle this word


@defword(name='-', args=2, print_x=True, doc="""\
Subtraction  ( y x -- y-x )""")
def w_minus():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is Rpn_Integer and type(y) is Rpn_Integer:
        result = Rpn_Integer(y.value() - x.value())
    elif    type(x) is Rpn_Float and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational] \
         or type(y) is Rpn_Float and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(float(y.value()) - float(x.value()))
    elif    type(x) is Rpn_Rational and type(y) in [Rpn_Integer, Rpn_Rational] \
         or type(y) is Rpn_Rational and type(x) in [Rpn_Integer, Rpn_Rational]:
        result = Rpn_Rational.from_Fraction(y.value() - x.value())
    elif    type(x) is Rpn_Complex and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
         or type(y) is Rpn_Complex and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        result = Rpn_Complex.from_complex(complex(y.value()) - complex(x.value()))
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("-: Type error ({}, {})".format(typename(y), typename(x)))
    param_stack.push(result)


@defword(name='.', args=1, print_x=False, doc="""\
Print top stack value  ( x -- )
A space is also printed after the number, but no newline.
If you need a newline, call CR.""")
def w_dot():
    write("{} ".format(fmt(param_stack.pop())))


@defword(name='.!', hidden=True, print_x=False, args=1)
def w_dot_bang():
    lnwriteln(repr(param_stack.top()))


@defword(name='."', doc="""\
Display string enclosed by quotation marks.
No newline is printed afterwards.

NOTE: The string begins immediately after the first ", so
  ."Hello, world!"
is correct.  This is different from Forth, where the must be a space after ." """)
def w_dot_quote():
    pass                        # Grammar rules handle this word


@defword(name='.all', args=1, print_x=False, doc="""\
Print X in a variety of formats  ( x -- )""")
def w_dot_all():
    x = param_stack.pop()
    xval = x.value()

    out = "{}".format(fmt(x))
    more = ""
    if type(x) is Rpn_Integer:
        more += "  Hex={}".format(hex(x.value()))
        more += "  Oct={}".format(oct(x.value()))

        ascii_char = ["NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
                      "BS",  "HT",  "LF",  "VT",  "FF",  "CR",  "SO",  "SI",
                      "DLE", "DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB",
                      "CAN", "EM",  "SUB", "ESC", "FS",  "GS",  "RS",  "US",
                      "SP",  "!",   "\"",  "#",   "$",   "%",   "&",   "'",
                      "(",   ")",   "*",   "+",   ",",   "-",   ".",   "/",
                      "0",   "1",   "2",   "3",   "4",   "5",   "6",   "7",
                      "8",   "9",   ":",   ";",   "<",   "=",   ">",   "?",
                      "@",   "A",   "B",   "C",   "D",   "E",   "F",   "G",
                      "H",   "I",   "J",   "K",   "L",   "M",   "N",   "O",
                      "P",   "Q",   "R",   "S",   "T",   "U",   "V",   "W",
                      "X",   "Y",   "Z",   "[",   "\\",  "]",   "^",   "_",
                      "`",   "a",   "b",   "c",   "d",   "e",   "f",   "g",
                      "h",   "i",   "j",   "k",   "l",   "m",   "n",   "o",
                      "p",   "q",   "r",   "s",   "t",   "u",   "v",   "w",
                      "x",   "y",   "z",   "{",   "|",   "}",   "~",   "DEL"]
        if xval >= 0 and xval <= 127:
            more += "  Char={}".format(ascii_char[xval])

    out += more
    writeln(out)


@defword(name='.bin', args=1, print_x=False, doc="""\
Print X in binary  ( i -- )
X must be an integer.""")
def w_dot_bin():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error(".b: Type error ({})".format(typename(x)))

    write("{} ".format(bin(x.value())))


@defword(name='.hex', args=1, print_x=False, doc="""\
Print X in hexadecimal  ( i -- )
X must be an integer.""")
def w_dot_hex():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error(".x: Type error ({})".format(typename(x)))

    write("{} ".format(hex(x.value())))


@defword(name='.oct', args=1, print_x=False, doc="""\
Print X in octal  ( i -- )
X must be an integer.""")
def w_dot_oct():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error(".o: Type error ({})".format(typename(x)))

    write("{} ".format(oct(x.value())))


@defword(name='.r', args=2, print_x=False, doc="""\
Print N right-justified in WIDTH  ( n width -- )

This never outputs more than WIDTH characters, and will silently truncate the
representation to fit.  It is wise to check the size of your values before
printing - you have been warned!  No space is printed after the number.""")
def w_dot_r():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error(".r: Width must be an integer ({})".format(typename(x)))
    width = x.value()
    if width < 0:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error(".r: Width must not be negative")
    if width == 0:
        return

    s = fmt(y, False)       # No label
    if len(s) > width:
        s = s[:width]       # This seems a bit harsh, but it's documented
    write("{:>{width}}".format(s, width=width))


@defword(name='.s', print_x=False, doc="""\
Print stack non-destructively""")
def w_dot_s():
    if not param_stack.empty():
        lnwriteln(param_stack)


@defword(name='.s!', hidden=True, print_x=False, doc="""\
Print stack non-destructively""")
def w_dot_s_bang():
    if not param_stack.empty():
        lnwriteln(repr(param_stack))


@defword(name='/', args=2, print_x=True, doc="""\
Division  ( y x -- y/x )
X cannot be zero.""")
def w_slash():
    """\
|----------+----------+---------+----------+---------+--------+--------|
| Integer  | Float    | Float   | Rational | Complex |        |        |
| Float    | Float    | Float   | Float    | Complex |        |        |
| Rational | Rational | Float   | Rational | Complex |        |        |
| Complex  | Complex  | Complex | Complex  | Complex |        |        |
| Vector   |          |         |          |         |        |        |
| Matrix   |          |         |          |         |        |        |
|----------+----------+---------+----------+---------+--------+--------|
| ^Y    X> | Integer  | Float   | Rational | Complex | Vector | Matrix |"""
    x = param_stack.pop()
    y = param_stack.pop()

    if     type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
       and x.zerop():
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("/: X cannot be zero")

    if    type(x) is Rpn_Rational and type(y) in [Rpn_Integer, Rpn_Rational] \
       or type(y) is Rpn_Rational and type(x) in [Rpn_Integer, Rpn_Rational]:
        result = Rpn_Rational.from_Fraction(y.value() / x.value())
    elif    type(x) in [Rpn_Integer, Rpn_Float] and type(y) in [Rpn_Integer, Rpn_Float] \
         or type(x) is Rpn_Rational and type(y) is Rpn_Float \
         or type(y) is Rpn_Rational and type(x) is Rpn_Float:
        r = float(y.value()) / float(x.value())
        if type(x) is Rpn_Integer and type(y) is Rpn_Integer and r.is_integer():
            result = Rpn_Integer(r)
        else:
            result = Rpn_Float(r)
    elif    type(x) is Rpn_Complex and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
         or type(y) is Rpn_Complex and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        result = Rpn_Complex.from_complex(complex(y.value()) / complex(x.value()))
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("/: Type error ({}, {})".format(typename(y), typename(x)))
    param_stack.push(result)


@defword(name='/mod', args=2, print_x=True, doc="""\
Division quotient and remainder  ( y x -- remainder quotient )

Divide integers Y by X, returning integer remainder and quotient.
Signs are whatever Python // and % give you.""")
def w_slash_mod():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("/mod: Type error ({}, {})".format(typename(y), typename(x)))
    if x.zerop():
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("/mod: X cannot be zero")
    rem =  y.value() %  x.value()
    quot = y.value() // x.value()
    param_stack.push(Rpn_Integer(rem))
    param_stack.push(Rpn_Integer(quot))


@defword(name=':', doc="""\
Define a new word  ( -- )
: WORD  [def ...]  ;

Define WORD with the specified definition.
Terminate the definition with a semi-colon.

qv SHOW""")
def w_colon():
    pass                        # Grammar rules handle this word


@defword(name=';', doc="""\
Terminate WORD definition  ( -- )
: WORD  [def ...]  ;""")
def w_semicolon():
    pass                        # Grammar rules handle this word


@defword(name='<', args=2, print_x=True, doc="""\
Test if Y is less than X  ( y x -- flag )""")
def w_less_than():
    x = param_stack.pop()
    y = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       and type(y) in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        yval = float(y.value())
        xval = float(x.value())
        param_stack.push(Rpn_Integer(bool_to_int(yval < xval)))
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("<: Type error ({}, {})".format(typename(y), typename(x)))


@defword(name='<<', args=2, print_x=True, doc="""\
<<  ( i2 i1 -- i2 << i1 )  Bitwise left shift""")
def w_leftshift():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("<<: Type error ({}, {})".format(typename(y), typename(x)))

    if x.value() < 0:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("<<: Shift amount may not be negative")

    param_stack.push(Rpn_Integer(y.value() << x.value()))


@defword(name='<=', args=2, print_x=True, doc="""\
Test if Y is less than or equal to X  ( y x -- flag )""")
def w_less_than_or_equal():
    x = param_stack.pop()
    y = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       and type(y) in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        yval = float(y.value())
        xval = float(x.value())
        param_stack.push(Rpn_Integer(bool_to_int(yval <= xval)))
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("<=: Type error ({}, {})".format(typename(y), typename(x)))


@defword(name='<>', args=2, print_x=True, doc="""\
Test if Y is not equal to X  ( y x -- flag )""")
def w_not_equal():
    """\
|----------+----------+---------+----------+---------+--------+--------|
| Integer  |   xxxx   |  xxx    |  xxxx    | xxxx    |        |        |
| Float    |   xxxxx  |  xxx    |   xxxx   | xxx     |        |        |
| Rational |   xxxx   |  xxx    |  xxxxx   | xxxx    |        |        |
| Complex  |    xxxx  |  xxx    |   xxx    | xxx     |        |        |
| Vector   |          |         |          |         |        |        |
| Matrix   |          |         |          |         |        |        |
|----------+----------+---------+----------+---------+--------+--------|
| ^Y    X> | Integer  | Float   | Rational | Complex | Vector | Matrix |"""
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is Rpn_Integer and type(y) is Rpn_Integer:
        flag = y.value() == x.value()
    elif    type(x) is Rpn_Float and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational] \
         or type(y) is Rpn_Float and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        flag = float(y.value()) == float(x.value()) # Beware floating point equality lossage
    elif    type(x) is Rpn_Rational and type(y) in [Rpn_Integer, Rpn_Rational] \
         or type(y) is Rpn_Rational and type(x) in [Rpn_Integer, Rpn_Rational]:
        flag = Fraction(y.value()) == Fraction(x.value())
    elif    type(x) is Rpn_Complex and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
         or type(y) is Rpn_Complex and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        flag = complex(y.value()) == complex(x.value())
    # XXX - it should be possible to compare vectors and matrices for equality:
    # Check if dimensions and components match
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("<>: Type error ({}, {})".format(typename(y), typename(x)))
    param_stack.push(Rpn_Integer(bool_to_int(not flag)))


@defword(name='=', args=2, print_x=True, doc="""\
Test if Y is equal to X  ( y x -- flag )""")
def w_equal():
    """\
|----------+----------+---------+----------+---------+--------+--------|
| Integer  |   xxxx   |  xxx    |  xxxx    | xxxx    |        |        |
| Float    |   xxxxx  |  xxx    |   xxxx   | xxx     |        |        |
| Rational |   xxxx   |  xxx    |  xxxxx   | xxxx    |        |        |
| Complex  |    xxxx  |  xxx    |   xxx    | xxx     |        |        |
| Vector   |          |         |          |         |        |        |
| Matrix   |          |         |          |         |        |        |
|----------+----------+---------+----------+---------+--------+--------|
| ^Y    X> | Integer  | Float   | Rational | Complex | Vector | Matrix |"""
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is Rpn_Integer and type(y) is Rpn_Integer:
        flag = y.value() == x.value()
    elif    type(x) is Rpn_Float and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational] \
         or type(y) is Rpn_Float and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        flag = float(y.value()) == float(x.value()) # Beware floating point equality lossage
    elif    type(x) is Rpn_Rational and type(y) in [Rpn_Integer, Rpn_Rational] \
         or type(y) is Rpn_Rational and type(x) in [Rpn_Integer, Rpn_Rational]:
        flag = Fraction(y.value()) == Fraction(x.value())
    elif    type(x) is Rpn_Complex and type(y) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
         or type(y) is Rpn_Complex and type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        flag = complex(y.value()) == complex(x.value())
    # XXX - it should be possible to compare vectors and matrices for equality:
    # Check if dimensions and components match
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("=: Type error ({}, {})".format(typename(y), typename(x)))
    param_stack.push(Rpn_Integer(bool_to_int(flag)))


@defword(name='>', args=2, print_x=True, doc="""\
Test if Y is greater than X  ( y x -- flag )""")
def w_greater_than():
    x = param_stack.pop()
    y = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       and type(y) in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        yval = float(y.value())
        xval = float(x.value())
        param_stack.push(Rpn_Integer(bool_to_int(yval > xval)))
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error(">: Type error ({}, {})".format(typename(y), typename(x)))


@defword(name='>=', args=2, print_x=True, doc="""\
Test if Y is greater than or equal to X  ( y x -- flag )""")
def w_greater_than_or_equal():
    x = param_stack.pop()
    y = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       and type(y) in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        yval = float(y.value())
        xval = float(x.value())
        param_stack.push(Rpn_Integer(bool_to_int(yval >= xval)))
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error(">=: Type error ({}, {})".format(typename(y), typename(x)))


@defword(name='>>', args=2, print_x=True, doc="""\
>>  ( i2 i1 -- i2 >> i1 )  Bitwise right shift""")
def w_rightshift():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error(">>: Type error ({}, {})".format(typename(y), typename(x)))

    if x.value() < 0:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error(">>: Shift amount may not be negative")

    param_stack.push(Rpn_Integer(y.value() >> x.value()))


@defword(name='>c', args=2, doc="""\
Construct a complex number from two reals  ( y x -- complex[x,y] )""")
def w_to_c():
    x = param_stack.pop()
    y = param_stack.pop()
    if    type(x) not in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       or type(y) not in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error(">c: Type error ({}, {})".format(typename(y), typename(x)))
    param_stack.push(Rpn_Complex(float(x.value()), float(y.value())))


@defword(name='>r', args=1, doc="""\
Push X onto return stack  ( x -- )""")
def w_to_r():
    return_stack.push(param_stack.pop())


if have_numpy:
    @defword(name='>v2', args=2, doc="""\
Create a 2-vector from the stack  ( y x -- v )""")
    def w_to_v_2():
        x = param_stack.pop()
        y = param_stack.pop()
        if    type(x) not in [Rpn_Integer, Rpn_Rational, Rpn_Float, Rpn_Complex] \
           or type(y) not in [Rpn_Integer, Rpn_Rational, Rpn_Float, Rpn_Complex]:
            param_stack.push(y)
            param_stack.push(x)
            raise Rpn_E_Type_Error(">v2: Type error ({}, {})".format(typename(y), typename(x)))
        l = Rpn_List()
        l.append(y)
        l.append(x)
        v = Rpn_Vector(l)
        param_stack.push(v)


if have_numpy:
    @defword(name='>v3', args=3, doc="""\
Create a 3-vector from the stack  ( z y x -- v )""")
    def w_to_v_3():
        x = param_stack.pop()
        y = param_stack.pop()
        z = param_stack.pop()
        if    type(x) not in [Rpn_Integer, Rpn_Rational, Rpn_Float, Rpn_Complex] \
           or type(y) not in [Rpn_Integer, Rpn_Rational, Rpn_Float, Rpn_Complex] \
           or type(z) not in [Rpn_Integer, Rpn_Rational, Rpn_Float, Rpn_Complex]:
            param_stack.push(z)
            param_stack.push(y)
            param_stack.push(x)
            raise Rpn_E_Type_Error(">v3: Type error ({}, {}, {})".format(typename(z), typename(y), typename(x)))
        l = Rpn_List()
        l.append(z)
        l.append(y)
        l.append(x)
        v = Rpn_Vector(l)
        param_stack.push(v)


@defword(name='?', print_x=False, doc="""\
?[topic]   Display information on a variety of topics""")
def w_info():
    print("""\
rpn is a general-purpose calculator and programming language based loosely
on Forth and Hewlett-Packard calculators.

The following topics provide additional information:
    ?datatypes
    ?variables""")


@defword(name='?datatypes', print_x=False, hidden=True, doc='')
def w_info_datatypes():
    print("""\
rpn supports the following datatypes, which may be placed directly on the
parameter stack.  Examples are also shown.

- Integer       1234
- Float         3.14159
- Rational      355::113
- Complex       (1.2, 3.4)
- Vector        [1 2 3 4]
- Matrix        [[1 0 0 0]
                 [0 1 0 0]
                 [0 0 1 0]
                 [0 0 0 1]]

Additionally, a String datatype is defined, which are placed on a separate
string stack.  "This is a sample string" """)


@defword(name='?dup', args=1, doc="""\
Duplicate top stack element if non-zero  ( x -- x x | 0 )""")
def w_query_dup():
    x = param_stack.top()
    if type(x) not in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        param_stack.push(x)
        raise Rpn_E_Type_Error("?dup: Type error ({})".format(typename(x)))
    if not x.zerop():
        w_dup()


@defword(name='?variables', print_x=False, hidden=True, doc='')
def w_info_variables():
    print("""\
Data from the stack may be stored in variables.  The syntax to store an object
is !VAR.  For example, to store the constant Pi (3.14...) into variable "mypi",
type:
        PI !mypi
Note that variables must be declared before they may be used.  To declare a
variable, which is initially created in an undefined state, type:
        variable mypi
Then the above example will work.  Variables local to a function can be defined
as follows:
        : myfunc  | x y z |   . . .  ;
x, y, and z will be locally defined only in the function "myfunc".

Values stored in variables may be pushed onto the stack with @VAR.

Note how this syntax differs from Forth's.  In Forth, one would say
        VAR @
This syntax is not allowed in Rpn because the "address" of a variable is never
exposed, and so it cannot ever be placed, however briefly, on the stack.  This
also means the that problem of accessing illegal memory cannot arise: the
variable is either findable by the system through its name, or it is not.""")


@defword(name='^', args=2, print_x=True, doc="""\
Exponentiation  ( y x -- y^x )""")
def w_caret():
    x = param_stack.pop()
    y = param_stack.pop()
    if    type(x) not in [Rpn_Integer, Rpn_Rational, Rpn_Float, Rpn_Complex] \
       or type(y) not in [Rpn_Integer, Rpn_Rational, Rpn_Float, Rpn_Complex]:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("^: Type error ({}, {})".format(typename(y), typename(x)))

    r = pow(y.value(), x.value())
    if type(r) is int:
        result = Rpn_Integer(r)
    elif type(r) is float:
        result = Rpn_Float(r)
    elif type(r) is complex:
        result = Rpn_Complex.from_complex(r)
    else:
        raise Rpn_E_Fatal("pow() returned a strange type '{}'".format(type(r)))
    param_stack.push(result)


@defword(name='abort', doc="""\
Abort execution and return to top level

qv ABORT", EXIT, LEAVE""")
def w_abort():
    raise Rpn_E_Abort()


@defword(name='abort"', doc="""\
Conditionally abort execution  ( flag -- )
If flag is non-zero, abort execution and print a message
(up to the closing quotation mark) and return to top level

qv ABORT, EXIT, LEAVE""")
def w_abort_quote():
    pass                        # Grammar rules handle this word


@defword(name='abs', args=1, print_x=True, doc="""\
Absolute value  ( x -- |x| )

NOTE: For complex numbers, ABS return the modulus (as a float).""")
def w_abs():
    x = param_stack.pop()
    if type(x) is Rpn_Integer:
        result = Rpn_Integer(abs(x.value()))
    elif type(x) in [Rpn_Float, Rpn_Complex]:
        result = Rpn_Float(abs(x.value()))
    elif type(x) is Rpn_Rational:
        result = Rpn_Rational.from_Fraction(abs(x.value()))
    elif type(x) is Rpn_Vector:
        if x.size() == 0:
            param_stack.push(x)
            raise Rpn_E_Value_Error("abs: X cannot be an empty vector")
        sumsq = 0.0
        for val in x.value():
            sumsq += val ** 2
        r = to_python_class(sumsq)
        t = type(r)
        if t is float:
            result = Rpn_Float(math.sqrt(r))
        elif t is complex:
            result = Rpn_Complex.from_complex(cmath.sqrt(r))
        else:
            raise Rpn_E_Fatal("{}: Cannot handle type {}".format(whoami(), t))
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("abs: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='acos', args=1, print_x=True, doc="""\
Inverse cosine  ( cosine -- angle )
|x| <= 1""")
def w_acos():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        try:
            r = math.acos(float(x.value()))
        except ValueError:
            param_stack.push(x)
            raise Rpn_E_Value_Error("acos: Argument {} out of range".format(x.value()))
        result = Rpn_Float(convert_radians_to_mode(r))
        result.set_label(angle_mode_label())
    elif type(x) is Rpn_Complex:
        try:
            r = cmath.acos(x.value())
        except ValueError:
            param_stack.push(x)
            raise Rpn_E_Value_Error("acos: Argument {} out of range".format(x.value()))
        result = Rpn_Complex.from_complex(r)
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("acos: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='acosh', args=1, print_x=True, doc="""\
Inverse hyperbolic cosine  ( cosine_h -- angle )

DEFINITION:
acosh(x) = ln(x + sqrt(x^2 - 1)), x >= 1""")
def w_acosh():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        try:
            r = math.acosh(float(x.value()))
        except ValueError:
            param_stack.push(x)
            raise Rpn_E_Value_Error("acosh: Argument {} out of range".format(x.value()))
        result = Rpn_Float(r)
    elif type(x) is Rpn_Complex:
        try:
            r = cmath.acosh(x.value())
        except ValueError:
            param_stack.push(x)
            raise Rpn_E_Value_Error("acosh: Argument {} out of range".format(x.value()))
        result = Rpn_Complex.from_complex(r)
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("acosh: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='again', doc="""\
Execute an indefinite loop forever.
BEGIN ... AGAIN

LEAVE will exit the loop early.

qv BEGIN, LEAVE, REPEAT, UNTIL, WHILE""")
def w_again():
    pass                        # Grammar rules handle this word


@defword(name='alog', args=1, print_x=True, doc="""\
Common exponential [antilogarithm]  ( x -- 10^x )""")
def w_alog():
    x = param_stack.pop()
    if type(x) not in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        param_stack.push(x)
        raise Rpn_E_Type_Error("alog: Type error ({})".format(typename(x)))
    r = 10.0 ** x.value()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(r)
    elif type(x) is Rpn_Complex:
        result = Rpn_Complex.from_complex(r)
    param_stack.push(result)


@defword(name='and', args=2, print_x=True, doc="""\
Logical AND  ( flag flag -- flag )
(This is not a bitwise AND - use BITAND for that.)""")
def w_and():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("and: Type error ({}, {})".format(typename(y), typename(y)))

    if x.value() not in [0, 1]:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("and: X must be TRUE (1) or FALSE (0), not {}".format(x.value()))
    if y.value() not in [0, 1]:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("and: Y must be TRUE (1) or FALSE (0), not {}".format(y.value()))

    param_stack.push(Rpn_Integer(x.value() and y.value()))


@defword(name='asin', args=1, print_x=True, doc="""\
Inverse sine  ( sine -- angle )
|x| <= 1""")
def w_asin():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        try:
            r = math.asin(float(x.value()))
        except ValueError:
            param_stack.push(x)
            raise Rpn_E_Value_Error("asin: Argument {} out of range".format(x.value()))
        result = Rpn_Float(convert_radians_to_mode(r))
        result.set_label(angle_mode_label())
    elif type(x) is Rpn_Complex:
        try:
            r = cmath.asin(x.value())
        except ValueError:
            param_stack.push(x)
            raise Rpn_E_Value_Error("asin: Argument {} out of range".format(x.value()))
        result = Rpn_Complex.from_complex(r)
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("asin: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='asinh', args=1, print_x=True, doc="""\
Inverse hyperbolic sine  ( sine_h -- angle )

DEFINITION:
asinh(x) = ln(x + sqrt(x^2 + 1))""")
def w_asinh():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        try:
            r = math.asinh(float(x.value()))
        except ValueError:
            param_stack.push(x)
            raise Rpn_E_Value_Error("asinh: Argument {} out of range".format(x.value()))
        result = Rpn_Float(r)
    elif type(x) is Rpn_Complex:
        try:
            r = cmath.asinh(x.value())
        except ValueError:
            param_stack.push(x)
            raise Rpn_E_Value_Error("asinh: Argument {} out of range".format(x.value()))
        result = Rpn_Complex.from_complex(r)
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("asinh: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='atan', args=1, print_x=True, doc="""\
Inverse tangent  ( tangent -- angle )

NOTE:
Consider using atan2 instead, especially if you are computing atan(y/x).""")
def w_atan():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        try:
            r = math.atan(float(x.value()))
        except ValueError:
            param_stack.push(x)
            raise Rpn_E_Value_Error("atan: Argument {} out of range".format(x.value()))
        result = Rpn_Float(convert_radians_to_mode(r))
        result.set_label(angle_mode_label())
    elif type(x) is Rpn_Complex:
        try:
            r = cmath.atan(x.value())
        except ValueError:
            param_stack.push(x)
            raise Rpn_E_Value_Error("atan: Argument {} out of range".format(x.value()))
        result = Rpn_Complex.from_complex(r)
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("atan: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='atan2', args=2, print_x=True, doc="""\
Inverse tangent of y/x  ( y x -- angle )""")
def w_atan2():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        try:
            r = math.atan2(float(y.value()), float(x.value()))
        except ValueError:
            param_stack.push(y)
            param_stack.push(x)
            raise Rpn_E_Value_Error("atan2: Invalid arguments ({} {})".format(y.value(), x.value()))
        result = Rpn_Float(convert_radians_to_mode(r))
        result.set_label(angle_mode_label())
    elif type(x) is Rpn_Complex:
        # Python cmath doesn't have atan2, so fake it
        if x.zerop():
            param_stack.push(y)
            param_stack.push(x)
            raise Rpn_E_Value_Error("atan2: Invalid arguments ({} {})".format(y.value(), x.value()))
        r = cmath.atan(y / x)
        result = Rpn_Complex.from_complex(r)
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("atan2: Type error ({} {})".format(typename(y), typename(x)))
    param_stack.push(result)


@defword(name='atanh', args=1, print_x=True, doc="""\
Inverse hyperbolic tangent  ( tangent_h -- angle )

DEFINITION:
atanh(x) = 1/2 ln((1+x) / (1-x)), |x| < 1""")
def w_atanh():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        try:
            r = math.atanh(float(x.value()))
        except ValueError:
            param_stack.push(x)
            raise Rpn_E_Value_Error("atanh: Argument {} out of range".format(x.value()))
        result = Rpn_Float(r)
    elif type(x) is Rpn_Complex:
        try:
            r = cmath.atanh(x.value())
        except ValueError:
            param_stack.push(x)
            raise Rpn_E_Value_Error("atanh: Argument {} out of range".format(x.value()))
        result = Rpn_Complex.from_complex(r)
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("atanh: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='beg', doc="""\
Set "Begin" (annuity due) financial mode.

Do not confuse this with the "begin" command, which starts a loop.""")
def w_beg():
    set_flag(FLAG_TVM_BEGIN_MODE)


@defword(name='begin', doc="""\
Execute an indefinite loop.
BEGIN ... AGAIN
BEGIN ... <flag> UNTIL
BEGIN ... <flag> WHILE ... REPEAT

LEAVE will exit the loop early.  Note that the effect of the test in
BEGIN...WHILE is opposite that in BEGIN...UNTIL.  The loop repeats
while something is true, rather than until it becomes true.

Do not confuse this with the "beg" command, which sets 'begin mode' for
Time Value of Money calculations.

qv AGAIN, LEAVE, REPEAT, UNTIL, WHILE""")
def w_begin():
    pass                        # Grammar rules handle this word


@defword(name='binom', args=3, print_x=True, doc="""\
Binomial probability ( n k p -- prob )

Return the probability of an event occurring exactly k times in n attempts,
where the probability of it occurring in a single attempt is p.

DEFINITION:
binom(n,k,p) = comb(n,k) * p^k * (1-p)^(n-k)""")
def w_binom():
    x = param_stack.pop()
    y = param_stack.pop()
    z = param_stack.pop()
    if    type(x) not in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       or type(y) is not Rpn_Integer \
       or type(z) is not Rpn_Integer:
        param_stack.push(z)
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("binom: Type error ({}, {}, {})".format(typename(z), typename(y), typename(x)))
    p = float(x.value())
    k = y.value()
    n = z.value()

    if p == 0:
        r = 1 if k == 0 else 0
    elif p == 1:
        r = 1 if k == n else 0
    else:
        r = comb_helper(n, k) * p**k * (1.0-p)**(n-k)

    param_stack.push(Rpn_Float(r))


@defword(name='bitand', args=2, print_x=True, doc="""\
bitand  ( i2 i1 -- i2 AND i1 )  Bitwise AND

Perform a bitwise boolean AND on two integers""")
def w_bitand():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("bitand: Type error ({}, {})".format(typename(y), typename(x)))

    param_stack.push(Rpn_Integer(y.value() & x.value()))


@defword(name='bitnot', args=1, print_x=True, doc="""\
bitnot  ( i1 -- NOT i1 )  Bitwise NOT

Perform a bitwise boolean NOT on an integer.  Sometimes known as INVERT.""")
def w_bitnot():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("bitnot: Type error ({})".format(typename(x)))

    param_stack.push(Rpn_Integer(~ x.value()))


@defword(name='bitor', args=2, print_x=True, doc="""\
bitor  ( i2 i1 -- i2 OR i1 )  Bitwise OR

Perform a bitwise boolean OR on two integers""")
def w_bitor():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("bitor: Type error ({}, {})".format(typename(y), typename(x)))

    param_stack.push(Rpn_Integer(y.value() | x.value()))


@defword(name='bitxor', args=2, print_x=True, doc="""\
bitxor  ( i2 i1 -- i2 XOR i1 )  Bitwise XOR

Perform a bitwise boolean Exclusive OR on two integers""")
def w_bitxor():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("bitxor: Type error ({}, {})".format(typename(y), typename(x)))

    param_stack.push(Rpn_Integer(y.value() ^ x.value()))


@defword(name='bye', doc="""\
Exit program""")
def w_bye():
    raise Rpn_E_End_Program()


@defword(name='c>', args=1, doc="""\
c>  ( c -- y x )  Extract imaginary and real parts of a complex number""")
def w_c_from():
    x = param_stack.pop()
    if type(x) is not Rpn_Complex:
        param_stack.push(x)
        raise Rpn_E_Type_Error("c>: Type error ({})".format(typename(x)))
    param_stack.push(Rpn_Float(x.imag()))
    param_stack.push(Rpn_Float(x.real()))


@defword(name='case', doc="""\
Execute a sequence of words based on stack value.  Once a match is
executed, no other clauses are considered.  OTHERWISE is optional.
<n> and OF labels must be integers.  CASE consumes the top of stack
like any word; however the integer value is available to the sequence
in variable "caseval".

<n> CASE
  <x> OF ... ENDOF
  <y> OF ... ENDOF
  <z> OF ... ENDOF
  [ OTHERWISE ... ]
ENDCASE

qv ENDCASE, ENDOF, OF, OTHERWISE""")
def w_case():
    pass                        # Grammar rules handle this word


@defword(name='catch', doc="""\
Catch any exceptions.

catch WORD

qv THROW""")
def w_catch():
    pass                        # Grammar rules handle this word


@defword(name='ceil', args=1, print_x=True, doc="""\
Ceiling  ( x -- ceil )   Smallest integer greater than or equal to X""")
def w_ceil():
    x = param_stack.pop()
    if type(x) is Rpn_Integer:
        result = x
    elif type(x) in [Rpn_Float, Rpn_Rational]:
        result = Rpn_Integer(math.ceil(x.value()))
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("ceil: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='cf', args=1, doc="""\
Clear flag  ( f -- )

Do not confuse this with "CF", which is for Compounding Frequency""")
def w_cf():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("cf: Type error ({})".format(typename(x)))
    flag = x.value()
    if flag < 0 or flag >= FLAG_MAX:
        param_stack.push(x)
        raise Rpn_E_Value_Error("cf: Flag {} out of range (0..{} expected)".format(flag, FLAG_MAX - 1))
    if flag >= FLAG_FENCE:
        param_stack.push(x)
        raise Rpn_E_Value_Error("cf: Flag {} cannot be modified".format(flag))
    clear_flag(flag)


@defword(name='chr', args=1, print_x=False, doc="""\
chr  ( x -- )  Push string for a single ASCII character.""")
def w_chr():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("chr: Type error ({})".format(typename(x)))
    string_stack.push(Rpn_String("{}".format(chr(x.value()))))


# Some HP calcs call this NEGATE, but why type 6 characters when 3 will do?
@defword(name='chs', args=1, print_x=True, doc="""\
Negation (change sign)  ( x -- -x )""")
def w_chs():
    x = param_stack.pop()
    if type(x) is Rpn_Integer:
        result = Rpn_Integer(-1 * x.value())
    elif type(x) is Rpn_Float:
        result = Rpn_Float(-1.0 * x.value())
    elif type(x) is Rpn_Rational:
        result = Rpn_Rational.from_Fraction(Fraction(-1,1) * x.value())
    elif type(x) is Rpn_Complex:
        result = Rpn_Complex(-1.0*x.real(), -1.0*x.imag())
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("chs: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='clfin', doc="""\
Clear financial variables""")
def w_clfin():
    global tvm_N, tvm_INT, tvm_PV, tvm_PMT, tvm_FV, tvm_CF, tvm_PF

    clear_flag(FLAG_TVM_CONTINUOUS) # Clear (0, default)=Discrete compounding;   Set (1)=Continuous compounding
    clear_flag(FLAG_TVM_BEGIN_MODE) # Clear (0, default)=End (ordinary annuity); Set (1)=Begin (annuity due)

    cf = Rpn_Integer(1)
    cf.set_label("CF")
    pf = Rpn_Integer(1)
    pf.set_label("PF")

    tvm_N   .set_obj(None)
    tvm_INT .set_obj(None)
    tvm_PV  .set_obj(None)
    tvm_PMT .set_obj(None)
    tvm_FV  .set_obj(None)
    tvm_CF  .set_obj(cf)
    tvm_PF  .set_obj(pf)


@defword(name='clflag', doc="""\
Clear all flags  ( -- )""")
def w_clflag():
    for i in range(FLAG_FENCE):
        clear_flag(i)


@defword(name='clreg', doc="""]
Clear all registers.""")
def w_clreg():
    global register
    register = dict()
    for i in range(REG_SIZE_MAX):
        register[i] = Rpn_Float(0.0)


@defword(name='clrst', print_x=False, doc="""\
Clear the return stack.

Do not confuse this with the "clst" command, which clears the parameter stack.""")
def w_clrst():
    return_stack.clear()


@defword(name='clstat', print_x=False, doc="""\
Clear the statistics array""")
def w_clstat():
    global stat_list
    stat_list = []


@defword(name='clst', print_x=False, doc="""\
Clear the stack

Do not confuse this with the "clrst" command, which clears the return stack.

DEFINITION:
: clst  depth 0 do drop loop ;""")
def w_clst():
    param_stack.clear()


@defword(name='comb', args=2, print_x=True, doc="""\
Combinations  ( n r -- nCr )
Choose from N objects R at a time, without regard to ordering.

DEFINITION:
          n!
nCr = -----------
      r! * (n-r)!""")
def w_comb():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("comb: Type error ({}, {})".format(typename(y), typename(x)))

    # Python 3.8 has math.comb()
    n = y.value()
    r = x.value()
    result = Rpn_Integer(comb_helper(n, r))

    param_stack.push(result)


@defword(name='constant', doc="""\
Declare a constant variable  ( n -- )
CONSTANT <ccc>""")
def w_constant():
    pass                        # Grammar rules handle this word


@defword(name='cos', args=1, print_x=True, doc="""\
Cosine  ( angle -- cosine )""")
def w_cos():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(math.cos(convert_mode_to_radians(float(x.value()))))
    elif type(x) is Rpn_Complex:
        result = Rpn_Complex.from_complex(cmath.cos(x.value()))
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("cos: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='cosh', args=1, print_x=True, doc="""\
Hyperbolic cosine  ( angle -- cosine_h )

DEFINITION:
          e^x + e^(-x)
cosh(x) = ------------
               2""")
def w_cosh():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(math.cosh(float(x.value())))
    elif type(x) is Rpn_Complex:
        result = Rpn_Complex.from_complex(cmath.cosh(x.value()))
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("cosh: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='CPF', args=1, doc="""\
Set CF and PF to N  ( n -- )""")
def w_cpf():
    global tvm_CF, tvm_PF

    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("CPF: Type error ({})".format(typename(x)))
    n = x.value()
    if n < 1:
        param_stack.push(x)
        raise Rpn_E_Value_Error("CPF: N must be positive")

    tvm_CF.set_obj(x)
    tvm_PF.set_obj(x)


@defword(name='cr', print_x=False, doc="""\
Print a newline""")
def w_cr():
    writeln()


def sum3(y):
    return int(y * 365.25) - int(y / 100) + int(y / 400)

def m306(m):
    return int(m * 30.6001)

@defword(name='d->hp', args=1, print_x=True, doc="""\
Convert date to HP day number  ( MM.DDYYYY -- day# )

Day # 0 = October 15, 1582""")
def w_d_to_hp():
    day0_julian = 2299160
    x = param_stack.pop()
    if type(x) is not Rpn_Float:
        param_stack.push(x)
        raise Rpn_E_Type_Error("d->hp: Type error ({})".format(typename(x)))

    (valid, dateobj, julian) = x.date_info()
    if not valid:
        param_stack.push(x)
        raise Rpn_E_Value_Error("d->hp: {} is not a valid date".format(x.value()))

    if dateobj.month < 3:
        m = dateobj.month + 13
        y = dateobj.year - 1
    else:
        m = dateobj.month + 1
        y = dateobj.year

    daynum = sum3(y) + m306(m) + dateobj.day - 578164
    if julian - daynum + day0_julian != 0:
        lnwriteln("d->hp: Result differs from Julian")

    result = Rpn_Integer(daynum)
    result.set_label("HP day")
    param_stack.push(result)


@defword(name='d->jd', args=1, print_x=True, doc="""\
Convert date to Julian day number ( MM.DDYYYY -- julian )""")
def w_d_to_jd():
    x = param_stack.pop()
    if type(x) is not Rpn_Float:
        param_stack.push(x)
        raise Rpn_E_Type_Error("d->jd: Type error ({})".format(typename(x)))

    (valid, _, julian) = x.date_info() # middle value is dateobj
    if not valid:
        param_stack.push(x)
        raise Rpn_E_Value_Error("d->jd: {} is not a valid date".format(x.value()))

    result = Rpn_Integer(julian)
    result.set_label("Julian day")
    param_stack.push(result)


@defword(name='d->r', args=1, print_x=True, doc="""\
Convert degrees to radians ( deg -- rad )""")
def w_d_to_r():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(convert_mode_to_radians(float(x.value()), "d"))
        result.set_label("Rad")
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("d->r: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='date', print_x=True, doc="""\
Current date  ( -- MM.DDYYYY )""")
def w_date():
    d = datetime.date.today().strftime("%m.%d%Y")
    result = Rpn_Float(d)
    result.set_label("MM.DDYYYY (Current)")
    param_stack.push(result)


@defword(name='dateinfo', args=1, hidden=True, print_x=False, doc="""\
Show date_info() for Float  ( x -- )""")
def w_dateinfo():
    x = param_stack.pop()
    if type(x) is not Rpn_Float:
        param_stack.push(x)
        raise Rpn_E_Type_Error("dateinfo: Type error ({})".format(typename(x)))
    writeln("dateinfo: {}".format(x.date_info()))


@defword(name='date+', args=2, print_x=True, doc="""\
Add N days to date  ( date1 N -- date2 )""")
def w_date_plus():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Float:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("date+: Type error ({}, {})".format(typename(y), typename(y)))

    (valid, dateobj, julian) = y.date_info()
    if not valid:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("date+: {} is not a valid date".format(y.value()))

    new_julian = julian + x.value()
    dateobj = datetime.date.fromordinal(new_julian - JULIAN_OFFSET)
    result = Rpn_Float("%d.%02d%04d" % (dateobj.month, dateobj.day, dateobj.year))
    result.set_label("DD.MMYYYY")
    param_stack.push(result)


@defword(name='date-', args=2, print_x=True, doc="""\
Subtract N days from date  ( date1 N -- date2 )""")
def w_date_minus():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Float:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("date-: Type error ({}, {})".format(typename(y), typename(y)))

    (valid, dateobj, julian) = y.date_info()
    if not valid:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("date-: {} is not a valid date".format(y.value()))

    new_julian = julian - x.value()
    dateobj = datetime.date.fromordinal(new_julian - JULIAN_OFFSET)
    result = Rpn_Float("%d.%02d%04d" % (dateobj.month, dateobj.day, dateobj.year))
    result.set_label("DD.MMYYYY")
    param_stack.push(result)


@defword(name='dbg.token', hidden=True)
def w_dbg_token():
    set_flag(FLAG_DEBUG_ENABLED)
    set_debug_level("token", 3)


@defword(name='ddays', args=2, print_x=True, doc="""\
Number of days between two dates  ( date1 date2 -- ddays )
Usually the earlier date is in Y, and later date in X.""")
def w_ddays():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Float or type(y) is not Rpn_Float:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("ddays: Type error ({}, {})".format(typename(y), typename(y)))

    (valid, _, xjulian) = x.date_info() # middle value is dateobj
    if not valid:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("ddays: {} is not a valid date".format(x.value()))

    (valid, _, yjulian) = y.date_info() # middle value is dateobj
    if not valid:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("ddays: {} is not a valid date".format(y.value()))

    # Y is expected to be earlier, so we subtract in this order to get a
    # positive value for "later"
    result = Rpn_Integer(xjulian - yjulian)
    result.set_label("Delta days")
    param_stack.push(Rpn_Integer(xjulian - yjulian))


@defword(name='DEG', print_x=False, doc="""\
Constant: Degrees per radian  ( -- 57.29577... )

DEFINITION:
DEG == 360/TAU == 180/PI

WARNING:
Do not confuse this with \"deg\" (which sets the angular mode to degrees).""")
def w_DEG():
    result = Rpn_Float(DEG_PER_RAD)
    result.set_label("Deg/Rad")
    param_stack.push(result)


@defword(name='deg', doc="""\
Set angular mode to degrees.

WARNING:
Do not confuse this with \"DEG\" (which is the number of degress per radian).""")
def w_deg():
    global angle_mode
    angle_mode = "d"
    clear_flag(FLAG_RAD)
    clear_flag(FLAG_GRAD)


@defword(name='depth', print_x=True, doc="""\
Current number of elements on stack  ( -- n )""")
def w_depth():
    param_stack.push(Rpn_Integer(param_stack.size()))


@defword(name='dim', args=1, print_x=True, doc="""\
Dimension(s) of X.

For integers, floats, and rationals (scalars):
                              return 0
For complex numbers:          return 2
For vectors of length N:      return a vector [N]
For an M-row by N-col matrix: return a vector [M N]""")
def w_dim():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Integer(0)
    elif type(x) is Rpn_Complex:
        result = Rpn_Integer(2)
    elif type(x) is Rpn_Vector:
        result = Rpn_Vector(Rpn_List(Rpn_Integer(x.size())))
    elif type(x) is Rpn_Matrix:
        # Pretty ugly.  Need a better method to append items.  Ugh,
        # things get added at the beginning of the list, so we have to
        # add the cols, THEN the rows in order to end up with
        # [ rows cols ].
        l = Rpn_List(Rpn_Integer(x.ncols()))
        l2 = Rpn_List(Rpn_Integer(x.nrows()), l)
        result = Rpn_Vector(l2) # [ rows cols ]
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("dim: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='do', doc="""\
Execute a definite loop.
<limit> <initial> DO ...        LOOP
<limit> <initial> DO ... <incr> +LOOP

The iteration counter is available via I.  LEAVE will exit the loop early.

Example: 10 0 do I . loop
prints 0 1 2 3 4 5 6 7 8 9

qv I, LEAVE, LOOP, +LOOP""")
def w_do():
    pass                        # Grammar rules handle this word


if have_numpy:
    @defword(name='dot', args=2, print_x=True, doc="""\
Vector dot product  ( vec_y vec_x -- real )""")
    def w_dot_prod():
        x = param_stack.pop()
        y = param_stack.pop()
        if type(x) is Rpn_Vector and type(y) is Rpn_Vector:
            try:
                r = y.value().dot(x.value())
            except ValueError:
                param_stack.push(y)
                param_stack.push(x)
                raise Rpn_E_Value_Error("dot: Conformability error: Vectors ({} and {}) are not same size".format(y, x))

            result = to_rpn_class(r)
        else:
            param_stack.push(y)
            param_stack.push(x)
            raise Rpn_E_Type_Error("dot: Type error ({}, {})".format(typename(y), typename(x)))

        param_stack.push(result)


@defword(name='dow', args=1, print_x=True, doc="""\
Day of week  ( MM.DDYYYY -- dow )
1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat, 7=Sun""")
def w_dow():
    x = param_stack.pop()
    if type(x) is not Rpn_Float:
        param_stack.push(x)
        raise Rpn_E_Type_Error("dow: Type error ({})".format(typename(x)))

    (valid, dateobj, _) = x.date_info() # third value is julian
    if not valid:
        param_stack.push(x)
        raise Rpn_E_Value_Error("dow: {} is not a valid date".format(x.value()))

    result = Rpn_Integer(dateobj.isoweekday())
    result.set_label("Day of week")
    param_stack.push(result)


@defword(name='dow$', args=1, print_x=False, doc="""\
Day of week name  ( dow -- )  [ -- abbrev ]
Return abbreviated day of week name as string.  dow should be between 1 and 7.

qv DOW""")
def w_dow_dollar():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("dow$: Type error ({})".format(typename(x)))
    dow = x.value()
    if dow < 1 or dow > 7:
        param_stack.push(x)
        raise Rpn_E_Value_Error("dow$: Day of week out of range (1..7 expected)")
    dow_abbrev = { 1: "Mon", 2: "Tue", 3: "Wed", 4: "Thu",
                   5: "Fri", 6: "Sat", 7: "Sun" }
    string_stack.push(Rpn_String.from_string(dow_abbrev[dow]))


@defword(name='drop', args=1, print_x=False, doc="""\
Remove top stack element  ( x -- )""")
def w_drop():
    param_stack.pop()


@defword(name='dup', args=1, doc="""\
Duplicate top stack element  ( x -- x x )
Equivalent to 0 PICK""")
def w_dup():
    x = param_stack.top()
    param_stack.push(x)


@defword(name='E', print_x=False, doc="""\
Constant: Base of natural logarithms ( -- 2.71828... )""")
def w_E():
    result = Rpn_Float(E)
    result.set_label("E")
    param_stack.push(result)


@defword(name='edit', hidden=True, doc="""\
Edit some text""")
def w_edit():
    env = os.environ
    if "VISUAL" in env:
        editor = env.get("VISUAL")
    elif "EDITOR" in env:
        editor = env.get("EDITOR")
    else:
        editor = "ed"

    # Set initial value
    initial_value = b"Initial string"

    with tempfile.NamedTemporaryFile(suffix=".tmp") as tf:
        tf.write(initial_value)
        tf.flush()
        subprocess.call([ editor, tf.name ])
        tf.seek(0)
        edited_message = tf.read()

    print(edited_message.decode("utf-8"))


@defword(name='expm1', args=1, print_x=True, doc="""\
Calculate (e^X)-1 accurately  ( x -- (e^x)-1 )""")
def w_e_x_minus_1():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(math.expm1(x.value()))
    elif type(x) is Rpn_Complex:
        result = Rpn_Complex.from_complex(cmath.exp(x.value()) - 1.0)
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("expm1: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='else', args=1, doc="""\
Execute a conditional test.
<flag> IF ... [ ELSE ... ] THEN

qv IF, THEN""")
def w_else():
    pass                        # Grammar rules handle this word


@defword(name='emit', args=1, print_x=False, doc="""\
emit  ( x -- )  Print a single ASCII character
No space or newline is appended.""")
def w_emit():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("emit: Type error ({})".format(typename(x)))
    write(chr(x.value()))


@defword(name='end', doc="""\
Set "End" (ordinary annuity) financial mode.""")
def w_end():
    clear_flag(FLAG_TVM_BEGIN_MODE)


@defword(name='endcase', doc="""\
Execute a sequence of words based on stack value.  Once a match is
executed, no other clauses are considered.  OTHERWISE is optional.
<n> and OF labels must be integers.

<n> CASE
  <x> OF ... ENDOF
  <y> OF ... ENDOF
  <z> OF ... ENDOF
  [ OTHERWISE ... ]
ENDCASE

qv CASE, ENDOF, OF, OTHERWISE""")
def w_endcase():
    pass                        # Grammar rules handle this word


@defword(name='endof', doc="""\
Execute a sequence of words based on stack value.  Once a match is
executed, no other clauses are considered.  OTHERWISE is optional.
<n> and OF labels must be integers.

<n> CASE
  <x> OF ... ENDOF
  <y> OF ... ENDOF
  <z> OF ... ENDOF
  [ OTHERWISE ... ]
ENDCASE

qv CASE, ENDCASE, OF, OTHERWISE""")
def w_endof():
    pass                        # Grammar rules handle this word


@defword(name='eng', args=1, print_x=False, doc="""\
Set engineering display  ( n -- )

N specifies the total number of significant digits.""")
def w_eng():
    global PRECISION_MAX
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("eng: Type error ({})".format(typename(x)))

    if x.value() < 0 or x.value() >= PRECISION_MAX:
        param_stack.push(x)
        raise Rpn_E_Value_Error("eng: Precision '{}' out of range (0..{} expected)".format(x.value(), PRECISION_MAX - 1))

    disp_stack.top().set_style("eng")
    disp_stack.top().set_prec(x.value())
    clear_flag(FLAG_DISP_FIX)
    set_flag(FLAG_DISP_ENG)


@defword(name='epoch', print_x=True, doc="""\
Seconds since epoch  ( -- secs )""")
def w_epoch():
    now = calendar.timegm(time.gmtime())
    result = Rpn_Integer(now)
    result.set_label("Epoch")
    param_stack.push(result)


@defword(name='erf', args=1, print_x=True, doc="""\
Error function  ( x -- erf[x] )""")
def w_erf():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        try:
            r = math.erf(float(x.value()))
        except ValueError:
            param_stack.push(x)
            raise Rpn_E_Value_Error("erf: Invalid argument")
        result = Rpn_Float(r)
    elif type(x) is Rpn_Complex:
        if not have_scipy:
            param_stack.push(x)
            raise Rpn_E_Runtime_Error("erf: Complex support requires 'scipy' library")
        r = scipy.special.erf(x.value())
        result = Rpn_Complex.from_complex(r)
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("erf: Type error({})".format(typename(x)))
    result.set_label("erf")
    param_stack.push(result)


@defword(name='erfc', args=1, print_x=True, doc="""\
Complementary error function  ( x -- erfc[x] )

DEFINITION:
erfc(x) = 1 - erf(x)""")
def w_erfc():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        try:
            r = math.erfc(float(x.value()))
        except ValueError:
            param_stack.push(x)
            raise Rpn_E_Value_Error("erfc: Invalid argument")
        result = Rpn_Float(r)
    elif type(x) is Rpn_Complex:
        if not have_scipy:
            param_stack.push(x)
            raise Rpn_E_Runtime_Error("erfc: Complex support requires 'scipy' library")
        r = scipy.special.erfc(x.value())
        result = Rpn_Complex.from_complex(r)
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("erfc: Type error({})".format(typename(x)))
    result.set_label("erfc")
    param_stack.push(result)


@defword(name='eval', str_args=1, doc="""\
Evaluate string on top of stack as a command sequence.""")
def w_eval():
    s = string_stack.pop().value()
    eval_string(s)


@defword(name='exit', doc="""\
Terminate execution of current word""")
def w_exit():
    raise Rpn_E_Exit()


@defword(name='exp', args=1, print_x=True, doc="""\
Natural exponential ( x -- e^x )""")
def w_exp():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(math.exp(float(x.value())))
    elif type(x) is Rpn_Complex:
        result = Rpn_Complex.from_complex(cmath.exp(complex(x.value())))
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("exp: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='fact', args=1, print_x=True, doc="""\
Factorial ( x -- x! )

DEFINITION:
x! = x * (x-1) * (x-2) ... * 2 * 1
0! = 1
X cannot be negative.

qv gamma""")
def w_fact():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("fact: Type error ({})".format(typename(x)))
    if x.value() < 0:
        param_stack.push(x)
        raise Rpn_E_Value_Error("fact: X cannot be negative")
    result = Rpn_Integer(fact_helper(x.value()))
    param_stack.push(result)


@defword(name='fc?', args=1, print_x=True, doc="""\
Test if flag is clear  ( -- bool )""")
def w_fc_query():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("fc?: Type error ({})".format(typename(x)))

    flag = x.value()
    if flag < 0 or flag >= FLAG_MAX:
        param_stack.push(x)
        raise Rpn_E_Value_Error("fc?: Flag {} out of range (0..{} expected)".format(flag, FLAG_MAX - 1))
    result = Rpn_Integer(bool_to_int(not flag_set_p(flag)))
    param_stack.push(result)


@defword(name='fc?c', args=1, print_x=True, doc="""\
Test if flag is clear, then clear  ( -- bool )""")
def w_fc_query_clear():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("fc?c: Type error ({})".format(typename(x)))

    flag = x.value()
    if flag < 0 or flag >= FLAG_MAX:
        param_stack.push(x)
        raise Rpn_E_Value_Error("fc?c: Flag {} out of range (0..{} expected)".format(flag, FLAG_MAX - 1))
    result = Rpn_Integer(bool_to_int(not flag_set_p(flag)))
    param_stack.push(result)
    if flag < FLAG_FENCE:
        clear_flag(flag)


@defword(name='fc?s', args=1, print_x=True, doc="""\
Test if flag is clear, then set  ( -- bool )""")
def w_fc_query_set():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("fc?s: Type error ({})".format(typename(x)))

    flag = x.value()
    if flag < 0 or flag >= FLAG_MAX:
        param_stack.push(x)
        raise Rpn_E_Value_Error("fc?s: Flag {} out of range (0..{} expected)".format(flag, FLAG_MAX - 1))
    result = Rpn_Integer(bool_to_int(not flag_set_p(flag)))
    param_stack.push(result)
    if flag < FLAG_FENCE:
        set_flag(flag)


@defword(name='fib', args=1, print_x=True, doc="""\
N'th Fibonacci number  ( n -- fib )

DEFINITION:
fib(0) = 0
fib(1) = 1
fib(n) = fib(n-1) + fib(n-2)

n cannot be negative.""")
def w_fib():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("fib: Type error ({})".format(typename(x)))
    if x.value() < 0:
        param_stack.push(x)
        raise Rpn_E_Value_Error("fib: X cannot be negative")
    result = Rpn_Integer(fib_helper(x.value()))
    param_stack.push(result)


@defword(name='fix', args=1, print_x=False, doc="""\
Set fixed display  ( n -- )

N specifies the number of digits after the decimal point.""")
def w_fix():
    global PRECISION_MAX
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("fix: Type error ({})".format(typename(x)))

    if x.value() < 0 or x.value() >= PRECISION_MAX:
        param_stack.push(x)
        raise Rpn_E_Value_Error("fix: Precision '{}' out of range (0..{} expected)".format(x.value(), PRECISION_MAX - 1))

    disp_stack.top().set_style("fix")
    disp_stack.top().set_prec(x.value())
    set_flag(FLAG_DISP_FIX)
    clear_flag(FLAG_DISP_ENG)


@defword(name='floor', args=1, print_x=True, doc="""\
Floor  ( x -- floor )   Largest integer not greater than X""")
def w_floor():
    x = param_stack.pop()
    if type(x) is Rpn_Integer:
        result = x
    elif type(x) in [Rpn_Float, Rpn_Rational]:
        result = Rpn_Integer(math.floor(x.value()))
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("floor: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='fmod', args=2, print_x=True, doc="""\
Floating point remainder  ( y x -- rem )

Return the remainder of dividing y by x.  Preferred for floats;
'mod' is preferred for integers.""")
def w_fmod():
    x = param_stack.pop()
    y = param_stack.pop()
    if    type(x) not in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       or type(y) not in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("fmod: Type error ({}, {})".format(typename(y), typename(x)))
    if x.zerop():
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("fmod: X cannot be zero")
    r = math.fmod(float(y.value()), float(x.value()))
    param_stack.push(Rpn_Float(r))


@defword(name='forget', doc="""\
Forget the definition of the following word.""")
def w_forget():
    pass                        # Grammar rules handle this word


# HP-41 calls this FRC, HP-42 calls this FP.  I like FRAC (which appeared
# on the HP-34C) because it is very clear but still short enough.
@defword(name='frac', print_x=True, args=1, doc="""\
Fractional part ( x.q -- 0.q )""")
def w_frac():
    x = param_stack.pop()
    if type(x) is Rpn_Integer:
        param_stack.push(Rpn_Integer(0))
    elif type(x) in [Rpn_Rational, Rpn_Float]:
        result = Rpn_Float(x.value() - int(x.value()))
        param_stack.push(result)
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("frac: Type error ({})".format(typename(x)))


@defword(name='fs?', print_x=True, args=1, doc="""\
Test if flag is set  ( -- bool )""")
def w_fs_query():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("fs?: Type error ({})".format(typename(x)))

    flag = x.value()
    if flag < 0 or flag >= FLAG_MAX:
        param_stack.push(x)
        raise Rpn_E_Value_Error("fs?: Flag {} out of range (0..{} expected)".format(flag, FLAG_MAX - 1))
    result = Rpn_Integer(bool_to_int(flag_set_p(flag)))
    param_stack.push(result)


@defword(name='fs?c', print_x=True, args=1, doc="""\
Test if flag is set, then clear  ( -- bool )""")
def w_fs_query_clear():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("fs?c: Type error ({})".format(typename(x)))

    flag = x.value()
    if flag < 0 or flag >= FLAG_MAX:
        param_stack.push(x)
        raise Rpn_E_Value_Error("fs?c: Flag {} out of range (0..{} expected)".format(flag, FLAG_MAX - 1))
    result = Rpn_Integer(bool_to_int(flag_set_p(flag)))
    param_stack.push(result)
    if flag < FLAG_FENCE:
        clear_flag(flag)


@defword(name='fs?s', print_x=True, args=1, doc="""\
Test if flag is set, then set  ( -- bool )""")
def w_fs_query_set():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("fs?s: Type error ({})".format(typename(x)))

    flag = x.value()
    if flag < 0 or flag >= FLAG_MAX:
        param_stack.push(x)
        raise Rpn_E_Value_Error("fs?s: Flag {} out of range (0..{} expected)".format(flag, FLAG_MAX - 1))
    result = Rpn_Integer(bool_to_int(flag_set_p(flag)))
    param_stack.push(result)
    if flag < FLAG_FENCE:
        set_flag(flag)


@defword(name='fsolve', args=1, str_args=1, print_x=True, doc="""\
Root solving  ( init.guess -- root )
Name of function must be on string stack.

Implemented via scipy.optimize.fsolve()""")
def w_fsolve():
    x = param_stack.pop()
    if    type(x) not in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        param_stack.push(x)
        raise Rpn_E_Type_Error("fsolve: Type error ({})".format(typename(x)))
    #init_guess = float(x.value())
    func_to_solve = string_stack.pop().value()
    # XXX - look up func_to_solve, error if not defined

    # XXX There are probably error conditions/exceptions I need to catch
    def func(x):
        param_stack.push(Rpn_Float(x))
        eval_string(func_to_solve)
        return param_stack.pop().value()

    r = scipy.optimize.fsolve(func, 3)
    # The return value of fsolve is a numpy array of length n for a root
    # finding problem with n variables.
    result = Rpn_Float(r[0])
    result.set_label("fsolve")
    param_stack.push(result)


@defword(name='FV', print_x=True, doc="""\
Calculate Future Value (FV)

DEFINITION:
     PMT * k         N    (      PMT * k )
FV = ------- - (1+ip)  * (  PV + -------  )
       ip                 (        ip    )

k = 1 if END, 1+ip if BEGIN""")
def w_FV():
    global tvm_N, tvm_INT, tvm_PV, tvm_PMT, tvm_FV, tvm_CF, tvm_PF

    if any_undefined_p([tvm_N, tvm_INT, tvm_PV, tvm_PMT]):
        raise Rpn_E_Runtime_Error("FV: Need N, INT, PV, and PMT")

    PV  = tvm_PV .obj().value()
    A   = tvm_A()
    C   = tvm_C()

    # FV = -[PV + A(PV + C)]
    fv = -1.0 * (PV + A*(PV + C))
    dbg("tvm", 1, "fv={}".format(fv))

    result = Rpn_Float(fv)
    result.set_label("FV")
    tvm_FV.set_obj(result)
    param_stack.push(result)


@defword(name='GAMMA', print_x=False, doc="""\
Constant: Euler-Mascheroni number ( -- 0.5772... )

DEFINITION:
GAMMA = lim(n->inf, (-ln n + SUM(k=1,n, 1/k)))

Do not confuse this with the "gamma" function.""")
def w_GAMMA():
    result = Rpn_Float(GAMMA)
    result.set_label("GAMMA")
    param_stack.push(result)


@defword(name='gamma', args=1, print_x=True, doc="""\
Gamma function  ( x -- gamma[x] )

Do not confuse this with the constant "GAMMA".""")
def w_gamma():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        try:
            r = math.gamma(float(x.value()))
        except ValueError:
            param_stack.push(x)
            raise Rpn_E_Value_Error("gamma: X cannot be a non-positive integer")
        if type(x) is Rpn_Integer:
            result = Rpn_Integer(r)
        else:
            result = Rpn_Float(r)
    elif type(x) is Rpn_Complex:
        if not have_scipy:
            param_stack.push(x)
            raise Rpn_E_Runtime_Error("gamma: Complex support requires 'scipy' library")
        r = scipy.special.gamma(x.value())
        if math.isnan(r.real) or math.isnan(r.imag):
            param_stack.push(x)
            raise Rpn_E_Value_Error("gamma: X cannot be a non-positive integer")
        result = Rpn_Complex.from_complex(r)
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("gamma: Type error({})".format(typename(x)))
    result.set_label("gamma")
    param_stack.push(result)


@defword(name='gcd', args=2, doc="""\
Greatest common divisor ( y x -- gcd )

: gcd  begin ?dup while tuck mod repeat ;""")
def w_gcd():
    x = param_stack.pop()
    y = param_stack.pop()
    if    type(x) is not Rpn_Integer \
       or type(y) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("gcd: Type error ({}, {})".format(typename(y), typename(x)))

    xval = x.value()
    yval = y.value()
    if xval < 0 or yval < 0:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("gcd: X and Y cannot be negative")
    if xval == 0 or yval == 0:
        param_stack.push(Rpn_Integer(0))
    else:
        r = gcd_helper(xval, yval)
        param_stack.push(Rpn_Integer(r))


if sys.version_info >= (3,8):
    @defword(name='gmean', print_x=True, doc="""\
    Print the geometric mean of the statistics data""")
    def w_gmean():
        global stat_list
        if len(stat_list) == 0:
            raise Rpn_E_Runtime_Error("gmean: No statistics data")
        try:
            m = statistics.geometric_mean(stat_list)
        except statistics.StatisticsError as e:
            raise Rpn_E_Runtime_Error("gmean: {}".format(str(e)))
        result = Rpn_Float(m)
        result.set_label("gmean")
        param_stack.push(result)


@defword(name='grad', doc="""\
Set angular mode to gradians""")
def w_grad():
    global angle_mode
    angle_mode = "g"
    clear_flag(FLAG_RAD)
    set_flag(FLAG_GRAD)


@defword(name='help', doc="""\
Show documentation for the following word.""")
def w_help():
    pass                        # Grammar rules handle this word


@defword(name='hmean', print_x=True, doc="""\
Print the harmonic mean of the statistics data""")
def w_hmean():
    global stat_list
    if len(stat_list) == 0:
        raise Rpn_E_Runtime_Error("hmean: No statistics data")
    try:
        m = statistics.harmonic_mean(stat_list)
    except statistics.StatisticsError as e:
        raise Rpn_E_Runtime_Error("hmean: {}".format(str(e)))
    result = Rpn_Float(m)
    result.set_label("hmean")
    param_stack.push(result)


@defword(name='hms', args=1, print_x=True, doc="""\
Convert decimal hours to hours/minutes/seconds  ( HH.nnn -- HH.MMSS )""")
def w_hms():
    x = param_stack.pop()
    if type(x) is Rpn_Integer:
        result = Rpn_Float(x.value())
    elif type(x) in [Rpn_Float, Rpn_Rational]:
        negative = x.value() < 0
        hr = abs(x.value())
        (minutes, seconds) = divmod(hr * 3600, 60)
        (hours, minutes)   = divmod(minutes, 60)
        if negative:
            hours *= -1.0
        result = Rpn_Float("%d.%02d%02d" % (hours, minutes, seconds))
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("hms: Type error ({})".format(typename(x)))
    result.set_label("HH.MMSS")
    param_stack.push(result)


@defword(name='hms+', args=2, print_x=True, doc="""\
Add hours/minutes/seconds  ( HH.MMSS HH.MMSS -- HH.MMSS )""")
def w_hms_plus():
    x = param_stack.pop()
    y = param_stack.pop()
    if    type(x) not in [Rpn_Integer, Rpn_Float] \
       or type(y) not in [Rpn_Integer, Rpn_Float]:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("hms+: Type error ({}, {})".format(typename(y), typename(x)))

    #ynegative = y.value() < 0
    if type(y) is Rpn_Integer:
        (yvalid, yhh, ymm, yss, _) = Rpn_Float(y.value()).time_info()
    else:
        (yvalid, yhh, ymm, yss, _) = y.time_info()
    if not yvalid:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("hms+: Time {} is not valid".format(y.value()))

    #xnegative = y.value() < 0
    if type(x) is Rpn_Integer:
        (xvalid, xhh, xmm, xss, _) = Rpn_Float(x.value()).time_info()
    else:
        (xvalid, xhh, xmm, xss, _) = x.time_info()
    if not xvalid:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("hms+: Time {} is not valid".format(x.value()))

    (hh, mm, ss) = normalize_hms(yhh + xhh, ymm + xmm, yss + xss)
    #print("hh=",hh,"mm=",mm,"ss=",ss)
    result = Rpn_Float("%d.%02d%02d" % (hh, mm, ss))
    result.set_label("HH.MMSS")
    param_stack.push(result)


@defword(name='hms-', args=2, print_x=True, doc="""\
Subtract hours/minutes/seconds  ( HH.MMSS HH.MMSS -- HH.MMSS )""")
def w_hms_minus():
    x = param_stack.pop()
    y = param_stack.pop()
    if    type(x) not in [Rpn_Integer, Rpn_Float] \
       or type(y) not in [Rpn_Integer, Rpn_Float]:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("hms-: Type error ({}, {})".format(typename(y), typename(x)))

    if type(y) is Rpn_Integer:
        (yvalid, yhh, ymm, yss, _) = Rpn_Float(y.value()).time_info()
    else:
        (yvalid, yhh, ymm, yss, _) = y.time_info()
    if not yvalid:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("hms-: Time {} is not valid".format(y.value()))

    if type(x) is Rpn_Integer:
        (xvalid, xhh, xmm, xss, _) = Rpn_Float(x.value()).time_info()
    else:
        (xvalid, xhh, xmm, xss, _) = x.time_info()
    if not xvalid:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("hms-: Time {} is not valid".format(x.value()))

    (hh, mm, ss) = normalize_hms(yhh - xhh, ymm - xmm, yss - xss)
    #print("hh=",hh,"mm=",mm,"ss=",ss)
    result = Rpn_Float("%d.%02d%02d" % (hh, mm, ss))
    result.set_label("HH.MMSS")
    param_stack.push(result)


@defword(name='hp->d', args=1, print_x=True, doc="""\
Convert HP day number to date  ( day# -- MM.DDYYYY )

Day # 0 = October 15, 1582""")
def w_hp_to_d():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("hp->d: Type error ({})".format(typename(x)))

    daynum = x.value()
    if daynum < 0 or daynum > datetime.date.max.toordinal():
        param_stack.push(x)
        raise Rpn_E_Value_Error("hp->d: X out of range")

    # dateobj = datetime.date.fromordinal(x.value() - JULIAN_OFFSET)
    # result = Rpn_Float("%d.%02d%04d" % (dateobj.month, dateobj.day, dateobj.year))
    d0 = daynum + 578164
    y0 = int((d0 - 121.5) / 365.2425)
    # m0 = int((d0 - sum3(y0)) / 30.6001)
    # while m0 < 4:
    #     y0 -= 1
    #     m0 = int((d0 -
    #
    # result.set_label("MM.DDYYYY")
    # param_stack.push(result)


@defword(name='hr', args=1, print_x=True, doc="""\
Convert hours/minutes/seconds to decimal hours  ( HH.MMSS -- HH.nnn )""")
def w_hr():
    x = param_stack.pop()
    if type(x) is Rpn_Integer:
        result = Rpn_Float(x.value())
    elif type(x) in [Rpn_Float, Rpn_Rational]:
        negative = -1.0 if x.value() < 0 else 1.0
        hms = Rpn_Float(abs(float(x.value()) if type(x) is Rpn_Rational else x.value()))
        (valid, hh, mm, ss, _) = hms.time_info()
        if not valid:
            param_stack.push(x)
            raise Rpn_E_Value_Error("hr: Time {} is not valid".format(x.value()))

        hr = float(hh) + float(mm)/60.0 + float(ss)/3600.0
        result = Rpn_Float(negative * hr)
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("hr: Type error ({})".format(typename(x)))
    result.set_label("HH.nnn")
    param_stack.push(result)


@defword(name='hypot', args=2, doc="""\
hypot  ( y x -- hypot )  Hypotenuse distance

Square root of the sum of squares.

DEFINITION:
hypot = sqrt(x^2 + y^2)""")
def w_hypot():
    x = param_stack.pop()
    y = param_stack.pop()
    if    type(x) not in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       or type(y) in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("hypot: Type error ({}, {})".format(typename(y), typename(x)))

    yval = float(y.value())
    xval = float(x.value())
    param_stack.push(Rpn_Float(math.hypot(xval, yval)))


@defword(name='I', doc="""\
Index of DO current loop  ( -- x )

Return the index of the most recent DO loop.

Do not confuse this with the "i" command,
which returns the complex number (0,1).""")
def w_I():
    (_I, _) = lookup_variable('_I')
    if _I is None:
        raise Rpn_E_Runtime_Error("'I' not valid here, only in DO loops")
    if type(_I.obj()) is not Rpn_Integer:
        raise Rpn_E_Fatal("I is not an Rpn_Integer")
    param_stack.push(_I.obj())


if have_numpy:
    @defword(name='idn', args=1, print_x=True, doc="""\
Create an NxN identity matrix  ( n -- mat )""")
    def w_idn():
        x = param_stack.pop()
        size = 0
        if type(x) is Rpn_Integer:
            size = x.value()
            if size < 1 or size > MATRIX_MAX:
                param_stack.push(x)
                raise Rpn_E_Value_Error("idn: X out of range (1..{} expected)".format(MATRIX_MAX))
        elif type(x) is Rpn_Vector:
            vsize = x.size()
            if vsize != 2:
                param_stack.push(x)
                raise Rpn_E_Value_Error("idn: Only matrices can be created")
            if int(x.value()[0]) != int(x.value()[1]):
                param_stack.push(x)
                raise Rpn_E_Value_Error("idn: Only square matrices can be created")
            size = x.value()[0]
        else:
            param_stack.push(x)
            raise Rpn_E_Type_Error("idn: Type error ({})".format(typename(x)))


        result = Rpn_Matrix.from_numpy(np.identity(size, dtype=np.int64))
        param_stack.push(result)


@defword(name='if', args=1, doc="""\
Test condition  ( flag -- )
Execute a conditional test.
<flag> IF ... [ ELSE ... ] THEN

qv ELSE, THEN""")
def w_if():
    pass                        # Grammar rules handle this word


@defword(name='INT', print_x=True, doc="""\
Calculate INTerest rate (INT)

Do not confuse this with the "int" command, which truncates values to integers.""")
def w_INT():
    global tvm_N, tvm_INT, tvm_PV, tvm_PMT, tvm_FV, tvm_CF, tvm_PF

    if any_undefined_p([tvm_N, tvm_PV, tvm_PMT, tvm_FV]):
        raise Rpn_E_Runtime_Error("INT: Need N, PV, PMT, and FV")

    N   = tvm_N  .obj().value()
    PV  = tvm_PV .obj().value()
    PMT = tvm_PMT.obj().value()
    FV  = tvm_FV .obj().value()

    # For PMT == 0:
    #   i = (FV/PV)^(1/n) - 1
    # For PMT != 0, i must be solved by iteration
    if PMT == 0:
        # XXX Trap math exceptions
        i_eff = math.expm1(math.log(-1.0*(FV/PV)) / N)
    else:
        i_eff = solve_for_interest()

    i = int_eff_to_nom(i_eff)
    dbg("tvm", 1, "i={}".format(i))
    result = Rpn_Float(100.0 * i)
    result.set_label("INT")
    tvm_INT.set_obj(result)
    param_stack.push(result)


@defword(name='int', args=1, print_x=True, doc="""\
int  ( x -- int )   Truncate to integer

The result is whatever Python's int() function returns.  Do not confuse this
with the "INT" command, which solves for financial interest rates.
Consider using floor or ceil instead.""")
def w_int():
    x = param_stack.pop()
    if type(x) is Rpn_Integer:
        result = x
    elif type(x) in [Rpn_Float, Rpn_Rational]:
        result = Rpn_Integer(int(x.value()))
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("int: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='J', doc="""\
Index of DO outer DO loop  ( -- x )

Return the index of the DO loop enclosing the current one""")
def w_J():
    (_J, _) = lookup_variable('_I', 2)
    if _J is None:
        raise Rpn_E_Runtime_Error("'J' not valid here, only in nested DO loops")
    if type(_J.obj()) is not Rpn_Integer:
        raise Rpn_E_Fatal("J is not an Rpn_Integer")
    param_stack.push(_J.obj())


@defword(name='jd->$', args=1, doc="""\
Convert julian day number to ISO date string  ( julian -- ) [ -- "YYYY-MM-DD" ]

EXAMPLE:
2369915 jd->$  ==>  "1776-07-04" """)
def w_jd_to_dollar():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("jd->$: Type error ({})".format(typename(x)))

    if x.value() < 1 or x.value() > datetime.date.max.toordinal():
        param_stack.push(x)
        raise Rpn_E_Value_Error("jd->$: X out of range (1..{} expected)".format(datetime.date.max.toordinal()))

    dateobj = datetime.date.fromordinal(x.value() - JULIAN_OFFSET)
    result = Rpn_String("%d-%02d-%02d" % (dateobj.year, dateobj.month, dateobj.day))
    string_stack.push(result)


@defword(name='jd->d', args=1, print_x=True, doc="""\
Convert julian day number to date  ( julian -- MM.DDYYYY )

EXAMPLE:
2369915 jd->d  ==>  7.041776""")
def w_jd_to_d():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("jd->d: Type error ({})".format(typename(x)))

    if x.value() < 1 or x.value() > datetime.date.max.toordinal():
        param_stack.push(x)
        raise Rpn_E_Value_Error("jd->d: X out of range (1..{} expected)".format(datetime.date.max.toordinal()))

    dateobj = datetime.date.fromordinal(x.value() - JULIAN_OFFSET)
    result = Rpn_Float("%d.%02d%04d" % (dateobj.month, dateobj.day, dateobj.year))
    result.set_label("MM.DDYYYY")
    param_stack.push(result)


if have_scipy:
    @defword(name='Jv', args=2, print_x=True, doc="""\
Jv  ( order x -- J_v(x) )

Bessel function of the first kind of real order and complex argument.
Implemented via scipy.special.jv(order, x)""")
    def w_Jv():
        x = param_stack.pop()
        y = param_stack.pop()
        if    type(x) not in [Rpn_Integer, Rpn_Rational, Rpn_Float, Rpn_Complex] \
           or type(y) not in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
            param_stack.push(y)
            param_stack.push(x)
            raise Rpn_E_Type_Error("Jv: Type error ({}, {})".format(typename(y), typename(x)))
        order = float(y.value())
        xval = x.value()
        r = scipy.special.jv(order, xval)
        if type(r) is np.float64 and math.isnan(r):
            param_stack.push(y)
            param_stack.push(x)
            raise Rpn_E_Type_Error("Jv: Not a number")

        if type(x) is Rpn_Complex:
            result = Rpn_Complex.from_complex(r)
        else:
            result = Rpn_Float(r)
        param_stack.push(result)


@defword(name='inv', args=1, print_x=True, doc="""\
Inverse  ( x -- 1/x )
X cannot be zero.""")
def w_inv():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
       and x.zerop():
        param_stack.push(x)
        raise Rpn_E_Value_Error("inv: X cannot be zero")

    if type(x) is Rpn_Integer:
        result = Rpn_Float(1.0 / float(x.value()))
    elif type(x) is Rpn_Rational:
        result = Rpn_Rational(x.denominator(), x.numerator())
    elif type(x) is Rpn_Float:
        result = Rpn_Float(1.0 / x.value())
    elif type(x) is Rpn_Complex:
        r = complex(1,0) / x.value()
        result = Rpn_Complex.from_complex(r)
    # elif type(x) is Rpn_Vector:
    #     # Vectors are not invertible
    # elif type(x) is Rpn_Matrix:
    #     # Numpy can do this; either
    #     # m = np.matrix([[],[]])
    #     # m.I
    #     # -or
    #     # b = np.array([[],[]])
    #     # np.linalg.inv(b)
    #     # And remember that not every matrix is invertible (singular ones)
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("inv: Type error ({})".format(typename(x)))

    param_stack.push(result)


@defword(name='key', print_x=True, doc="""\
ASCII code of single keystroke  ( -- key )
KEY will block until input is provided.""")
def w_key():
    k = _Getch()()
    val = ord(k) if k != '' else 0
    #lnwriteln("You pressed <{}>, value={}".format(k, val))
    param_stack.push(Rpn_Integer(val))


@defword(name='lcm', args=2, doc="""\
Least common multiple ( y x -- lcm )

DEFINITION:
              x * y
lcm(x, y) = ---------
            gcd(x, y)""")
def w_lcm():
    x = param_stack.pop()
    y = param_stack.pop()
    if    type(x) is not Rpn_Integer \
       or type(y) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("lcm: Type error ({}, {})".format(typename(y), typename(x)))

    xval = x.value()
    yval = y.value()
    if xval < 0 or yval < 0:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("lcm: X and Y cannot be negative")
    if xval == 0 or yval == 0:
        param_stack.push(Rpn_Integer(0))
    else:
        r = (xval * yval) / gcd_helper(xval, yval)
        param_stack.push(Rpn_Integer(r))


@defword(name='leave', doc="""\
Exit a DO or BEGIN loop immediately.""")
def w_leave():
    raise Rpn_E_Leave


@defword(name='lg', args=1, print_x=True, doc="""\
Logarithm [base 2]  ( x -- lg )
X cannot be zero.
Use "ln" for the natural logarithm, and "log" for the common logarithm.""")
def w_lg():
    x = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
       and x.zerop():
        param_stack.push(x)
        raise Rpn_E_Value_Error("lg: X cannot be zero")

    if    type(x) is Rpn_Integer  and x.value() > 0 \
       or type(x) is Rpn_Float    and x.value() > 0.0 \
       or type(x) is Rpn_Rational and x.value() > 0:
        r = math.log2(float(x.value()))
        if type(x) is Rpn_Integer and r.is_integer():
            result = Rpn_Integer(r)
        else:
            result = Rpn_Float(r)
    elif    type(x) is Rpn_Complex \
         or type(x) is Rpn_Integer  and x.value() < 0 \
         or type(x) is Rpn_Float    and x.value() < 0.0 \
         or type(x) is Rpn_Rational and x.value() < 0:
        result = Rpn_Complex.from_complex(cmath.log(complex(x.value()), 2))
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("lg: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='ln', args=1, print_x=True, doc="""\
Natural logarithm [base e]  ( x -- ln )
X cannot be zero.
Use "log" for the common (base 10) logarithm.""")
def w_ln():
    x = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
       and x.zerop():
        param_stack.push(x)
        raise Rpn_E_Value_Error("ln: X cannot be zero")

    if    type(x) is Rpn_Integer  and x.value() > 0 \
       or type(x) is Rpn_Float    and x.value() > 0.0 \
       or type(x) is Rpn_Rational and x.value() > 0:
        result = Rpn_Float(math.log(float(x.value())))
    elif    type(x) is Rpn_Complex \
         or type(x) is Rpn_Integer  and x.value() < 0 \
         or type(x) is Rpn_Float    and x.value() < 0.0 \
         or type(x) is Rpn_Rational and x.value() < 0:
        result = Rpn_Complex.from_complex(cmath.log(complex(x.value())))
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("ln: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='lnp1', args=1, print_x=True, doc="""\
Calculate ln(1+X) accurately  ( x -- ln(1+x) )""")
def w_ln_1_plus_x():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        if float(x.value()) == -1.0:
            param_stack.push(x)
            raise Rpn_E_Value_Error("lnp1: X cannot be -1")
        result = Rpn_Float(math.log1p(x.value()))
    elif type(x) is Rpn_Complex:
        if x.value() == complex(-1,0):
            param_stack.push(x)
            raise Rpn_E_Value_Error("lnp1: X cannot be (-1,0)")
        result = Rpn_Complex.from_complex(cmath.log(x.value() + complex(1,0)))
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("lnp1: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='load', str_args=1, print_x=False, doc="""\
Load file specified on string stack  [ file -- ]""")
def w_load():
    filename = string_stack.pop().value()
    if not os.path.isfile(filename):
        lnwriteln("load: Invalid file '{}'".format(filename))
    else:
        load_file(filename)


@defword(name='log', args=1, print_x=True, doc="""\
Common logarithm [base 10]  ( x -- log )
X cannot be zero.
Use "ln" for the natural (base e) logarithm.""")
def w_log():
    x = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex] \
       and x.zerop():
        param_stack.push(x)
        raise Rpn_E_Value_Error("log: X cannot be zero")

    if    type(x) is Rpn_Integer  and x.value() > 0 \
       or type(x) is Rpn_Float    and x.value() > 0.0 \
       or type(x) is Rpn_Rational and x.value() > 0:
        r = math.log10(float(x.value()))
        if type(x) is Rpn_Integer and r.is_integer():
            result = Rpn_Integer(r)
        else:
            result = Rpn_Float(r)
    elif    type(x) is Rpn_Complex \
         or type(x) is Rpn_Integer  and x.value() < 0 \
         or type(x) is Rpn_Float    and x.value() < 0.0 \
         or type(x) is Rpn_Rational and x.value() < 0:
        result = Rpn_Complex.from_complex(cmath.log10(complex(x.value())))
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("log: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='loop', doc="""\
Execute a definite loop.
<limit> <initial> DO ... LOOP

The iteration counter is available via I.  LEAVE will exit the loop early.

Example: 10 0 do I . loop
prints 0 1 2 3 4 5 6 7 8 9

qv DO, I, LEAVE, +LOOP""")
def w_loop():
    pass                        # Grammar rules handle this word


@defword(name='max', args=2, print_x=True, doc="""\
Smaller of X or Y  ( y x -- max )""")
def w_max():
    x = param_stack.pop()
    y = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       and type(y) in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        yval = float(y.value())
        xval = float(x.value())
        param_stack.push(x if xval > yval else y)
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("max: Type error ({}, {})".format(typename(y), typename(x)))


@defword(name='mean', print_x=True, doc="""\
Print the arithmetic mean of the statistics data""")
def w_mean():
    global stat_list
    if len(stat_list) == 0:
        raise Rpn_E_Runtime_Error("mean: No statistics data")
    try:
        m = statistics.mean(stat_list)
    except statistics.StatisticsError as e:
        raise Rpn_E_Runtime_Error("mean: {}".format(str(e)))
    result = Rpn_Float(m)
    result.set_label("mean")
    param_stack.push(result)


@defword(name='median', print_x=True, doc="""\
Print the median of the statistics data""")
def w_median():
    global stat_list
    if len(stat_list) == 0:
        raise Rpn_E_Runtime_Error("median: No statistics data")
    try:
        m = statistics.median(stat_list)
    except statistics.StatisticsError as e:
        raise Rpn_E_Runtime_Error("median: {}".format(str(e)))
    result = Rpn_Float(m)
    result.set_label("median")
    param_stack.push(result)


@defword(name='min', args=2, print_x=True, doc="""\
Smaller of X or Y  ( y x -- min )""")
def w_min():
    x = param_stack.pop()
    y = param_stack.pop()
    if     type(x) in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       and type(y) in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        yval = float(y.value())
        xval = float(x.value())
        param_stack.push(x if xval < yval else y)
    else:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("min: Type error ({}, {})".format(typename(y), typename(x)))


@defword(name='N', print_x=True, doc="""\
Calculate Number of payments (N)

DEFINITION:
    log((FV*i)/(PV*i))
N = ------------------
        log(1 + i)""")
def w_N():
    global tvm_N, tvm_INT, tvm_PV, tvm_PMT, tvm_FV, tvm_CF, tvm_PF

    if any_undefined_p([tvm_INT, tvm_PV, tvm_PMT, tvm_FV]):
        raise Rpn_E_Runtime_Error("N: Need INT, PV, PMT, and FV")

    FV = tvm_FV.obj().value()
    PV = tvm_PV.obj().value()
    C  = tvm_C()
    i  = tvm_i()

    # n = ln[(C-FV)/(C+PV)] / ln(1+i)
    n = math.log((C - FV) / (C + PV)) / math.log1p(i)
    dbg("tvm", 1, "n={}".format(n))

    result = Rpn_Float(n)
    result.set_label("N")
    tvm_N.set_obj(result)
    param_stack.push(result)


@defword(name='not', args=1, print_x=True, doc="""\
Logical not  ( flag -- !flag )

Invert a flag - return TRUE (1) if x is zero, otherwise FALSE (0).
NOT is intended for boolean manipulations and is only defined on truth
integers (0,1).  0= is meant to compare a number to zero, and works for
all number types.

NOTE: This is not a bitwise not - use BITNOT for that.""")
def w_not():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("not: Type error ({})".format(typename(x)))
    if x.value() not in [0, 1]:
        param_stack.push(x)
        raise Rpn_E_Value_Error("not: X must be TRUE (1) or FALSE (0), not {}".format(x.value()))

    param_stack.push(Rpn_Integer(bool_to_int(x.zerop())))


@defword(name='of', doc="""\
Execute a sequence of words based on stack value.  Once a match is
executed, no other clauses are considered.  OTHERWISE is optional.
<n> and OF labels must be integers.

<n> CASE
  <x> OF ... ENDOF
  <y> OF ... ENDOF
  <z> OF ... ENDOF
  [ OTHERWISE ... ]
ENDCASE

qv CASE, ENDCASE, ENDOF, OTHERWISE""")
def w_of():
    pass                        # Grammar rules handle this word


@defword(name='or', args=2, print_x=True, doc="""\
Logical OR  ( flag flag -- flag )
NOTE: This is not a bitwise OR - use BITOR for that.""")
def w_or():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer or type(y) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("or: Type error ({}, {})".format(typename(y), typename(y)))

    if x.value() not in [0, 1]:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("or: X must be TRUE (1) or FALSE (0), not {}".format(x.value()))
    if y.value() not in [0, 1]:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("or: Y must be TRUE (1) or FALSE (0), not {}".format(y.value()))

    param_stack.push(Rpn_Integer(x.value() or y.value()))


@defword(name='otherwise', doc="""\
Execute a sequence of words based on stack value.  Once a match is
executed, no other clauses are considered.  OTHERWISE is optional.
<n> and OF labels must be integers.

<n> CASE
  <x> OF ... ENDOF
  <y> OF ... ENDOF
  <z> OF ... ENDOF
  [ OTHERWISE ... ]
ENDCASE

qv CASE, ENDCASE, ENDOF, OF""")
def w_otherwise():
    pass                        # Grammar rules handle this word


@defword(name='over', args=2, doc="""\
Duplicate second stack element  ( y x -- y x y )
Equivalent to 1 PICK""")
def w_over():
    x = param_stack.pop()
    y = param_stack.pop()
    param_stack.push(y)
    param_stack.push(x)
    param_stack.push(y)


@defword(name='p->r', print_x=True, doc="""\
Convert polar coordinates to rectangular.
The parameter(s) can be either two reals, or one complex.

Real:      ( theta r   -- y x   )
Complex:   ( (r,theta) -- (x,y) )

DEFINITION:
x = r * cos(theta)
y = r * sin(theta)""")
def w_p_to_r():
    if param_stack.empty():
        raise Rpn_E_Runtime_Error("p->r: Insufficient parameters (1 or 2 required)")
    x = param_stack.pop()
    if type(x) is Rpn_Complex:
        r      = x.real()
        theta  = convert_mode_to_radians(x.imag())
        result = Rpn_Complex.from_complex(cmath.rect(r, theta))
        param_stack.push(result)
    elif type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        if param_stack.empty():
            param_stack.push(x)
            raise Rpn_E_Runtime_Error("p->r: Insufficient parameters (2 required)")
        y = param_stack.pop()
        if type(y) not in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
            param_stack.push(y)
            param_stack.push(x)
            raise Rpn_E_Type_Error("p->r: Type error({}, {})".format(typename(y), typename(x)))

        r     = float(x.value())
        theta = convert_mode_to_radians(float(y.value()))
        xval  = r * math.cos(theta)
        yval  = r * math.sin(theta)
        param_stack.push(Rpn_Float(yval))
        param_stack.push(Rpn_Float(xval))
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("p->r: Type error({})".format(typename(x)))


@defword(name='perm', args=2, print_x=True, doc="""\
Permutations  ( n r -- nPr )
Choose from N objects R at a time, with regard to ordering.

DEFINITION:
        n!
nPr = ------
      (n-r)!""")
def w_perm():
    x = param_stack.pop()
    y = param_stack.pop()
    if type(y) is not Rpn_Integer or type(x) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("perm: Type error ({}, {})".format(typename(y), typename(x)))

    # Python 3.8 has math.perm()
    n = y.value()
    r = x.value()
    if r > n or r < 0:
        result = Rpn_Integer(0)
    else:
        t = 1
        while r > 0:
            r -= 1
            t *= n
            n -= 1
        result = Rpn_Integer(t)

    param_stack.push(result)


@defword(name='PI', print_x=False, doc="""\
Constant: Pi  ( -- 3.14159... )

DEFINITION:
PI == TAU/2

Consider using TAU instead of PI to simplify your equations.""")
def w_PI():
    result = Rpn_Float(PI)
    result.set_label("PI")
    param_stack.push(result)


@defword(name='pick', args=1, doc="""\
Pick an element from the stack  ( x -- )
0 PICK ==> DUP, 1 PICK ==> OVER""")
def w_pick():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("pick: Type error ({})".format(typename(x)))

    if x.value() < 0 or x.value() >= param_stack.size():
        param_stack.push(x)
        raise Rpn_E_Value_Error("pick: Index out of range (0..{} expected)".format(param_stack.size()-2))

    result = param_stack.pick(x.value())
    param_stack.push(result)


@defword(name='plot', args=2, str_args=1, print_x=False, doc="""\
Simple ASCII function plot ( xlow xhigh -- ) [ FN -- ]
FN is the (string) name of a function which must implement ( x -- y ).
Y-axis is autoscaled.

EXAMPLE:
rad  80 !COLS  24 !ROWS
TAU chs TAU "sin" plot  =>

      1.000 :------------------------------------*---------------------:
            :     ****                   |     ** *                    :
            :    *    *                  |    *    *                   :
            :   *      *                 |          *                  :
            :                            |   *       *                 :
            :  *        *                |  *                          :
            : *                          |            *                :
            :            *               | *                           :
            :*                           |             *               :
            :             *              |*                            :
            *                            |              *              :
            :==============*=============+=============================*
            :                            *               *             :
            :               *            |                            *:
            :                           *|                *            :
            :                *           |                           * :
            :                          * |                 *        *  :
            :                 *       *  |                             :
            :                  *         |                  *      *   :
            :                   *    *   |                   *    *    :
     =1.000 :--------------------****-------------------------****-----:
             -6.283                                                   6.283""")
def w_plot():
    x = param_stack.pop()
    y = param_stack.pop()
    if    type(x) not in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       or type(y) not in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("plot: Type error ({}, {})".format(typename(y), typename(x)))
    func_to_plot = string_stack.pop().value()
    # XXX - look up func_to_plot, error if not defined
    x_high = float(x.value())
    x_low  = float(y.value())

    # XXX There are probably error conditions/exceptions I need to catch
    def func(x):
        param_stack.push(Rpn_Float(x))
        eval_string(func_to_plot)
        return param_stack.pop().value()

    plot_helper(func, x_low, x_high)


@defword(name='PMT', print_x=True, doc="""\
Calculate PayMenT amount (PMT)

DEFINITION:
       (         PV + FV     )    -ip
PMT = (  PV + --------------  ) * ---
       (       (1+ip)^N - 1  )     k

k = 1 if END, 1+ip if BEGIN""")
def w_PMT():
    global tvm_N, tvm_INT, tvm_PV, tvm_PMT, tvm_FV, tvm_CF, tvm_PF

    if any_undefined_p([tvm_N, tvm_INT, tvm_PV, tvm_FV]):
        raise Rpn_E_Runtime_Error("PMT: Need N, INT, PV, and FV")

    PV = tvm_PV.obj().value()
    FV = tvm_FV.obj().value()
    A  = tvm_A()
    B  = tvm_B()

    # PMT = -[FV + PV(A+1)] / (A*B)
    pmt = -1.0 * ((FV + PV*(A+1.0)) / (A * B))
    dbg("tvm", 1, "pmt={}".format(pmt))

    result = Rpn_Float(pmt)
    result.set_label("PMT")
    tvm_PMT.set_obj(result)
    param_stack.push(result)


@defword(name='popdisp', print_x=False, doc="""\
Pop current display configuration.""")
def w_popdisp():
    try:
        disp_stack.pop()
    except Rpn_E_Stack_Underflow:
        raise Rpn_E_Runtime_Error("popdisp: No stashed display configurations")


@defword(name='pushdisp', print_x=False, doc="""\
Stash current display configuration.""")
def w_pushdisp():
    d = Rpn_Display_Config()
    cur_style = disp_stack.top().style()
    d.set_style(cur_style)
    if cur_style in ["fix", "sci"]:
        cur_prec = disp_stack.top().prec()
        d.set_prec(cur_prec)
    disp_stack.push(d)


@defword(name='PV', print_x=True, doc="""\
Calculate Present Value (PV)

DEFINITION:
      ( PMT * k      )       1         PMT * k
PV = (  ------- - FV  ) * --------  -  -------
      (   ip         )    (1+ip)^N       ip

k = 1 if END, 1+ip if BEGIN""")
def w_PV():
    global tvm_N, tvm_INT, tvm_PV, tvm_PMT, tvm_FV, tvm_CF, tvm_PF

    if any_undefined_p([tvm_N, tvm_INT, tvm_PMT, tvm_FV]):
        raise Rpn_E_Runtime_Error("PV: Need N, INT, PMT, and FV")

    FV = tvm_FV.obj().value()
    A  = tvm_A()
    C  = tvm_C()
    # PV = -[FV + (A*C)] / (A+1)
    pv = -1.0 * ((FV + (A * C)) / (A + 1.0))
    dbg("tvm", 1, "pv={}".format(pv))

    result = Rpn_Float(pv)
    result.set_label("PV")
    tvm_PV.set_obj(result)
    param_stack.push(result)


if have_scipy:
    @defword(name='quad', args=2, str_args=1, print_x=True, doc=r"""\
Numerical integration  ( lower upper -- err.est integral )
Name of function must be on string stack.

Implemented via scipy.integrate.quad()

EXAMPLE: Integrate a bessel function jv(2.5, x) along the interval [0,4.5]:

: J2.5  2.5 swap Jv ;
0 4.5 "J2.5" quad .s  =>
1: 7.866317216380692e-09  \ error
0: 1.1178179380783249  \ quad""")
    def w_quad():
        x = param_stack.pop()
        y = param_stack.pop()
        if    type(x) not in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
           or type(y) not in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
            param_stack.push(y)
            param_stack.push(x)
            raise Rpn_E_Type_Error("quad: Type error ({}, {})".format(typename(y), typename(x)))
        lower = float(y.value())
        upper = float(x.value())
        func_to_integrate = string_stack.pop().value()
        # XXX - look up func_to_integrate, error if not defined

        # XXX There are probably error conditions/exceptions I need to catch
        def func(x):
            param_stack.push(Rpn_Float(x))
            eval_string(func_to_integrate)
            return param_stack.pop().value()

        (res, err) = scipy.integrate.quad(func, lower, upper)
        err_obj = Rpn_Float(err)
        err_obj.set_label("error")
        param_stack.push(err_obj)
        res_obj = Rpn_Float(res)
        res_obj.set_label("quad")
        param_stack.push(res_obj)


@defword(name='r->d', args=1, print_x=True, doc="""\
Convert radians to degrees ( rad -- deg )""")
def w_r_to_d():
    x = param_stack.pop()
    if type(x) not in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        param_stack.push(x)
        raise Rpn_E_Type_Error("r->d: Type error ({})".format(typename(x)))
    result = Rpn_Float(convert_radians_to_mode(float(x.value()), "d"))
    result.set_label("Deg")
    param_stack.push(result)


@defword(name='r->p', print_x=True, doc="""\
Convert rectangular coordinates to polar.
The parameter(s) can be either two reals, or one complex.

Real:      ( y x   -- theta r   )
Complex:   ( (x,y) -- (r,theta) )

DEFINITION:
r     = hypot(x, y) == sqrt(x^2 + y^2)
theta = atan(y / x) == atan2(y, x)""")
def w_r_to_p():
    if param_stack.empty():
        raise Rpn_E_Runtime_Error("r->p: Insufficient parameters (1 or 2 required)")
    x = param_stack.pop()
    if type(x) is Rpn_Complex:
        (r, theta) = cmath.polar(x.value())
        result = Rpn_Complex(r, convert_radians_to_mode(theta))
        param_stack.push(result)
    elif type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        if param_stack.empty():
            param_stack.push(x)
            raise Rpn_E_Runtime_Error("r->p: Insufficient parameters (2 required)")
        y = param_stack.pop()
        if type(y) not in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
            param_stack.push(y)
            param_stack.push(x)
            raise Rpn_E_Type_Error("r->p: Type error({}, {})".format(typename(y), typename(x)))

        theta = math.atan2(y.value(), x.value())
        theta_obj = Rpn_Float(convert_radians_to_mode(theta))
        theta_obj.set_label("theta_" + angle_mode_label())

        r = math.hypot(y.value(), x.value())
        r_obj = Rpn_Float(r)
        r_obj.set_label("r")

        param_stack.push(theta_obj)
        param_stack.push(r_obj)
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("r->p: Type error({})".format(typename(x)))


@defword(name='r.s', print_x=False, doc="""\
Display return stack""")
def w_r_dot_s():
    for (i, item) in return_stack.items_bottom_to_top():
        # Prefix with "r" to prevent confusion with .s
        lnwriteln("r{}: {}".format(i, item))


@defword(name='r>', doc="""\
Pop return stack onto parameter stack  ( -- x )""")
def w_r_from():
    if return_stack.empty():
        raise Rpn_E_Runtime_Error("r>: Empty return stack")
    param_stack.push(return_stack.pop())


@defword(name='r@', doc="""\
Copy top of return stack  ( -- x )""")
def w_r_fetch():
    if return_stack.empty():
        raise Rpn_E_Runtime_Error("r@: Empty return stack")
    param_stack.push(return_stack.top())


@defword(name='rad', doc="""\
Set angular mode to radians""")
def w_rad():
    global angle_mode
    angle_mode = "r"
    set_flag(FLAG_RAD)
    clear_flag(FLAG_GRAD)


@defword(name='rand', print_x=True, doc="""\
Random number  ( -- r )
r is a float in range: 0 <= r < 1

qv RANDINT""")
def w_rand():
    param_stack.push(Rpn_Float(random.random()))


@defword(name='randint', args=1, print_x=True, doc="""\
Random integer between 1 and n  ( n -- r )
r is an integer in range: 1 <= r <= n

EXAMPLE:
: threeD6  3 0 do 6 randint loop + + ;

qv RAND""")
def w_randint():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("randint: Type error ({})".format(typename(x)))

    if x.value() < 1:
        param_stack.push(x)
        raise Rpn_E_Value_Error("randint: n must be positive")

    r = random.randint(1, x.value())
    param_stack.push(Rpn_Integer(r))


@defword(name='rcl', args=1, doc="""\
Recall value of register X  ( reg -- val )""")
def w_rcl():
    global register
    (reg_size, _) = lookup_variable("SIZE")

    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("rcl: Type error ({})".format(typename(x)))
    reg = x.value()
    if reg < 0 or reg >= reg_size.obj().value():
        param_stack.push(x)
        raise Rpn_E_Value_Error("rcl: Register '{}' out of range (0..{} expected)".format(reg, reg_size.obj().value() - 1))
    param_stack.push(register[reg])


@defword(name='rct->sph', args=3, doc="""\
Convert rectangular coordinates to spherical  ( z y x -- phi theta r )

DEFINITION:
phi   = atan(y/x)      == atan2(y, x)
theta = acos(z / r)
r     = hypot(x, y, z) == sqrt(x^2 + y^2 + z^2)""")
def w_rct_to_sph():
    x = param_stack.pop()
    y = param_stack.pop()
    z = param_stack.pop()
    if    type(x) not in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       or type(y) not in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       or type(z) not in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        param_stack.push(z)
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("rct->sph: Type error ({}, {}, {})".format(typename(z), typename(y), typename(x)))
    if x.zerop() and y.zerop() and z.zerop():
        param_stack.push(z)
        param_stack.push(y)
        param_stack.push(x)
        return

    xval = float(x.value())
    yval = float(y.value())
    zval = float(z.value())

    r     = math.sqrt(xval**2 + yval**2 + zval**2)
    r_obj = Rpn_Float(r)
    r_obj.set_label("r")

    theta     = math.acos(zval / r)
    theta_obj = Rpn_Float(convert_radians_to_mode(theta))
    theta_obj.set_label("theta_" + angle_mode_label())

    phi     = math.atan2(yval, xval)
    phi_obj = Rpn_Float(convert_radians_to_mode(phi))
    phi_obj.set_label("phi_" + angle_mode_label())

    param_stack.push(phi_obj)
    param_stack.push(theta_obj)
    param_stack.push(r_obj)


@defword(name='rdepth', print_x=True, doc="""\
Current number of elements on return stack  ( -- n )""")
def w_rdepth():
    param_stack.push(Rpn_Integer(return_stack.size()))


@defword(name='rdrop', doc="""\
Drop the top item from the return stack.""")
def w_rdrop():
    if return_stack.empty():
        raise Rpn_E_Runtime_Error("rdrop: Empty return stack")
    return_stack.pop()


@defword(name='recurse', doc="""\
Recurse into current word.  Only valid in a colon definition.""")
def w_recurse():
    pass                        # Grammar rules handle this word


@defword(name='repeat', doc="""\
Execute an indefinite loop while a condition is satisfied.
BEGIN ... <flag> WHILE ... REPEAT

LEAVE will exit the loop early.  Note that the effect of the test in
BEGIN...WHILE is opposite that in BEGIN...UNTIL.  The loop repeats
while something is true, rather than until it becomes true.

qv BEGIN, AGAIN, LEAVE, UNTIL, WHILE""")
def w_repeat():
    pass                        # Grammar rules handle this word


@defword(name='rms', args=1, print_x=True, doc="""\
Root Mean Square  ( v -- rms )

DEFINITION:
            2    2    2          2
           x1 + x2 + x3 + ... + xn
rms = sqrt(-----------------------)
                      n""")
def w_rms():
    x = param_stack.pop()
    if type(x) is not Rpn_Vector:
        param_stack.push(x)
        raise Rpn_E_Type_Error("rms: Type error ({})".format(typename(x)))

    n = x.size()
    if n == 0:
        param_stack.push(x)
        raise Rpn_E_Value_Error("rms: X cannot be an empty vector")
    sumsq = 0.0
    for val in x.value():
        sumsq += val ** 2
    sumsq /= n
    rval = to_python_class(sumsq)
    t = type(rval)
    if t is float:
        result = Rpn_Float(math.sqrt(rval))
    elif t is complex:
        result = Rpn_Complex.from_complex(cmath.sqrt(rval))
    else:
        raise Rpn_E_Fatal("{}: Cannot handle type {}".format(whoami(), t))

    result.set_label("rms")
    param_stack.push(result)


@defword(name='rnd', args=2, print_x=True, doc="""\
Round N to PLACES number of decimal places  ( n places -- rounded )

NOTE: This is implemented using Python's round() function.  The behavior
of rnd can be surprising: for example, "2.675 2 rnd" gives 2.67 instead
of the expected 2.68.  This is not a bug: it's a result of the fact that
most decimal fractions can't be represented exactly as a float.""")
def w_rnd():
    x = param_stack.pop()
    y = param_stack.pop()
    if    type(x) is not Rpn_Integer \
       or type(y) not in [Rpn_Integer, Rpn_Rational, Rpn_Float, Rpn_Complex]:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("rnd: Type error ({}, {})".format(typename(y), typename(x)))
    places = x.value()
    if places < 0:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("rnd: Round places may not be negative")

    if type(y) in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        r = round(float(y.value()), places)
        result = Rpn_Integer(r) if places == 0 else Rpn_Float(r)
    else:
        new_real = round(float(y.real()), places)
        new_imag = round(float(y.imag()), places)
        result = Rpn_Complex(new_real, new_imag)
    param_stack.push(result)


@defword(name='roll', args=1, doc="""\
Roll stack elements  ( x -- )
1 ROLL ==> SWAP, 2 ROLL ==> ROT""")
def w_roll():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("roll: Type error ({})".format(typename(x)))

    if x.value() < 0 or x.value() >= param_stack.size():
        param_stack.push(x)
        raise Rpn_E_Value_Error("roll: Index out of range (0..{} expected)".format(param_stack.size()-2))

    param_stack.roll(x.value())


@defword(name='rot', args=3, doc="""\
Rotate third stack element to the top, rolling others up  ( z y x -- y x z )
Equivalent to 2 ROLL""")
def w_rot():
    x = param_stack.pop()
    y = param_stack.pop()
    z = param_stack.pop()
    param_stack.push(y)
    param_stack.push(x)
    param_stack.push(z)


@defword(name='S+', args=1, print_x=False, doc="""\
Add an element to the statistics list""")
def w_s_plus():
    x = param_stack.pop()
    if type(x) not in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        param_stack.push(x)
        raise Rpn_E_Type_Error("S+: Type error ({})".format(typename(x)))

    global stat_list
    val = float(x.value())
    stat_list.append(val)


@defword(name='sci', args=1, print_x=False, doc="""\
Set scientific display  ( n -- )

N specifies the number of digits after the decimal point.""")
def w_sci():
    global PRECISION_MAX
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("sci: Type error ({})".format(typename(x)))

    if x.value() < 0 or x.value() >= PRECISION_MAX:
        param_stack.push(x)
        raise Rpn_E_Value_Error("fix: Precision '{}' out of range (0..{} expected)".format(x.value(), PRECISION_MAX - 1))

    disp_stack.top().set_style("sci")
    disp_stack.top().set_prec(x.value())
    clear_flag(FLAG_DISP_FIX)
    clear_flag(FLAG_DISP_ENG)


@defword(name='scopes', print_x=False, doc="""\
Print information on all available scopes.""")
def w_scopes():
    for (i, item) in scope_stack.items_bottom_to_top():
        lnwriteln("{}: {}".format(i, item))


@defword(name='setdebug', args=1, str_args=1, print_x=False, doc="""\
Set debug level  ( lev -- )  [ "facility" -- ]""")
def w_setdebug():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("setdebug: Type error ({})".format(typename(x)))
    level = x.value()
    if level < 0 or level > 9:
        param_stack.push(x)
        raise Rpn_E_Value_Error("setdebug: Level {} out of range (0..9 expected)".format(level))
    resource = string_stack.pop()
    if not resource.value() in debug_levels:
        param_stack.push(x)
        string_stack.push(resource)
        raise Rpn_E_Value_Error("{}: Resource '{}' is not valid".format(whoami(), resource.value()))
    set_debug_level(resource.value(), level)


@defword(name='sf', args=1, doc="""\
Set flag  ( f -- )""")
def w_sf():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("sf: Type error ({})".format(typename(x)))
    flag = x.value()
    if flag < 0 or flag >= FLAG_MAX:
        param_stack.push(x)
        raise Rpn_E_Value_Error("sf: Flag {} out of range (0..{} expected)".format(flag, FLAG_MAX - 1))
    if flag >= FLAG_FENCE:
        param_stack.push(x)
        raise Rpn_E_Value_Error("sf: Flag {} cannot be modified".format(flag))
    set_flag(flag)


@defword(name='shdebug', print_x=False, doc="""\
Show all debug levels""")
def w_showdebug():
    global scr_cols
    lnwriteln("Debugging is {}".format("ENABLED" if flag_set_p(FLAG_DEBUG_ENABLED) else "disabled"))

    dbgs = dict()
    for (resource, level) in debug_levels.items():
        dbgs[resource] = "{}={}".format(resource, level)
    sorted_dbgs = []
    for key in sorted(dbgs, key=str.casefold):
        sorted_dbgs.append(dbgs[key])
    list_in_columns(sorted_dbgs, scr_cols.obj().value() - 1)


@defword(name='shfin', print_x=False, doc="""\
Show financial variables""")
def w_shfin():
    global tvm_N, tvm_INT, tvm_PV, tvm_PMT, tvm_FV, tvm_CF, tvm_PF

    lnwrite()
    writeln("N:   {}".format(fmt(tvm_N  .obj().value()) if tvm_N  .defined() else "[Not set]"))
    writeln("INT: {}".format(fmt(tvm_INT.obj().value()) if tvm_INT.defined() else "[Not set]"))
    writeln("PV:  {}".format(fmt(tvm_PV. obj().value()) if tvm_PV .defined() else "[Not set]"))
    writeln("PMT: {}".format(fmt(tvm_PMT.obj().value()) if tvm_PMT.defined() else "[Not set]"))
    writeln("FV:  {}".format(fmt(tvm_FV .obj().value()) if tvm_FV .defined() else "[Not set]"))
    writeln("--------------")
    writeln("CF:  {}".format(fmt(tvm_CF .obj().value()) if tvm_CF .defined() else "[Not set]"))
    writeln("PF:  {}".format(fmt(tvm_PF .obj().value()) if tvm_PF .defined() else "[Not set]"))

    writeln("{} compounding (flag {} is {})".format("CONTINUOUS" if flag_set_p(FLAG_TVM_CONTINUOUS) else "DISCRETE",
                                                    FLAG_TVM_CONTINUOUS,
                                                    "set" if flag_set_p(FLAG_TVM_CONTINUOUS) else "clear"))
    writeln("{} mode (flag {} is {})".format("BEGIN" if flag_set_p(FLAG_TVM_BEGIN_MODE) else "END",
                                             FLAG_TVM_BEGIN_MODE,
                                             "set" if flag_set_p(FLAG_TVM_BEGIN_MODE) else "clear"))
    if dbg("tvm"):
        writeln("----------")
        writeln("i: {}".format(tvm_i() if tvm_i() is not None else "[undef]"))
        writeln("A: {}".format(tvm_A() if tvm_A() is not None else "[undef]"))
        writeln("B: {}".format(tvm_B() if tvm_B() is not None else "[undef]"))
        writeln("C: {}".format(tvm_C() if tvm_C() is not None else "[undef]"))
        writeln("X: {} ({} mode)".format(tvm_X() if tvm_X() is not None else "[undef]",
                                         "BEGIN" if flag_set_p(FLAG_TVM_BEGIN_MODE) else "END"))


@defword(name='shflag', print_x=False, doc="""\
Show status of all flags ( -- )""")
def w_shflag():
    global scr_cols
    flags = []
    for f in range(FLAG_MAX):
        flags.append("%02d:%s" % (f, "YES" if flag_set_p(f) else "no "))

    list_in_columns(flags, scr_cols.obj().value() - 1)


@defword(name='show', doc="""\
Show the definition of the following word.""")
def w_show():
    pass                        # Grammar rules handle this word


@defword(name='shstat', print_x=False, doc="""\
Print the statistics list""")
def w_shstat():
    global stat_list
    if len(stat_list) == 0:
        writeln("No statistics data")
    else:
        writeln(stat_list)


@defword(name='shreg', print_x=False, doc="""\
Show status of all registers ( -- )""")
def w_shreg():
    global scr_cols, register
    (reg_size, _) = lookup_variable("SIZE")
    regs = []
    for r in range(reg_size.obj().value()):
        regs.append("R%02d=%s" % (r, fmt(register[r])))

    list_in_columns(regs, scr_cols.obj().value() - 1)


@defword(name='sign', args=1, print_x=True, doc="""\
Signum  ( n -- sign )
Returns -1, 0, or 1.""")
def w_sign():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        if x.value() < 0:
            r = -1
        elif x.value() > 0:
            r = +1
        else:
            r = 0
        result = Rpn_Integer(r)
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("sign: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='sin', args=1, print_x=True, doc="""\
Sine  ( angle -- sine )""")
def w_sin():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(math.sin(convert_mode_to_radians(float(x.value()))))
    elif type(x) is Rpn_Complex:
        result = Rpn_Complex.from_complex(cmath.sin(x.value()))
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("sin: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='sinc', args=1, print_x=True, doc="""\
Sine cardinal (sampling function)  ( x -- sinc )

DEFINITION:
           sin x
sinc(x) = -------
             x

sinc(0) == 1""")
def w_sinc():
    x = param_stack.pop()
    if type(x) not in [Rpn_Integer, Rpn_Float, Rpn_Rational, Rpn_Complex]:
        param_stack.push(x)
        raise Rpn_E_Type_Error("sinc: Type error ({})".format(typename(x)))
    if type(x) is Rpn_Complex:
        if x.zerop():
            r = complex(1.0, 0.0)
        else:
            r = cmath.sin(x.value()) / x.value()
        result = Rpn_Complex.from_complex(r)
    else:
        if x.zerop():
            r = 1.0
        else:
            r = math.sin(convert_mode_to_radians(float(x.value()))) / x.value()
        result = Rpn_Float(r)

    result.set_label("sinc")
    param_stack.push(result)


@defword(name='sinh', args=1, print_x=True, doc="""\
Hyperbolic sine  ( angle -- sine_h )

DEFINITION:
          e^x - e^(-x)
sinh(x) = ------------
               2""")
def w_sinh():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(math.sinh(float(x.value())))
    elif type(x) is Rpn_Complex:
        result = Rpn_Complex.from_complex(cmath.sinh(x.value()))
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("sinh: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='sleep', args=1, doc="""\
Sleep for N seconds  ( n -- )
N may be fractional.""")
def w_sleep():
    x = param_stack.pop()
    if type(x) not in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        param_stack.push(x)
        raise Rpn_E_Type_Error("sleep: Type error ({})".format(typename(x)))
    sleep_time = float(x.value())
    time.sleep(sleep_time)


@defword(name='sph->rct', args=3, doc="""\
Convert spherical coordinates to rectangular  ( phi theta r -- z y x )

DEFINITION:
x = r * sin(theta) * cos(phi)
y = r * sin(theta) * sin(phi)
z = r * cos(theta)""")
def w_sph_to_rct():
    x = param_stack.pop()
    y = param_stack.pop()
    z = param_stack.pop()
    if    type(x) not in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       or type(y) not in [Rpn_Integer, Rpn_Rational, Rpn_Float] \
       or type(z) not in [Rpn_Integer, Rpn_Rational, Rpn_Float]:
        param_stack.push(z)
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("sph->rct: Type error ({}, {}, {})".format(typename(z), typename(y), typename(x)))
    if x.zerop() and y.zerop() and z.zerop():
        param_stack.push(z)
        param_stack.push(y)
        param_stack.push(x)
        return

    r     = float(x.value())
    theta = convert_mode_to_radians(float(y.value()))
    phi   = convert_mode_to_radians(float(z.value()))

    x_coord = r * math.sin(theta) * math.cos(phi)
    y_coord = r * math.sin(theta) * math.sin(phi)
    z_coord = r * math.cos(theta)

    param_stack.push(Rpn_Float(z_coord))
    param_stack.push(Rpn_Float(y_coord))
    param_stack.push(Rpn_Float(x_coord))


@defword(name='sq', args=1, print_x=True, doc="""\
Square  ( x -- x^2 )""")
def w_sq():
    x = param_stack.pop()
    if type(x) is Rpn_Integer:
        result = Rpn_Integer(x.value() ** 2)
    elif type(x) is Rpn_Rational:
        result = Rpn_Rational(x.numerator() ** 2, x.denominator() ** 2)
    elif type(x) is Rpn_Float:
        result = Rpn_Float(x.value() ** 2)
    elif type(x) is Rpn_Complex:
        r = complex(x.value() ** 2)
        result = Rpn_Complex.from_complex(r)
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("sq: Type error ({})".format(typename(x)))

    param_stack.push(result)


@defword(name='sqrt', args=1, print_x=True, doc="""\
Square root  ( x -- sqrt(x) )
Negative X returns a complex number""")
def w_sqrt():
    x = param_stack.pop()
    if type(x) is Rpn_Integer and x.zerop():
        result = Rpn_Integer(0)
    elif type(x) in [Rpn_Float, Rpn_Rational] and x.zerop():
        result = Rpn_Float(0.0)
    elif type(x) is Rpn_Complex and x.zerop():
        result = Rpn_Complex()
    elif    type(x) is Rpn_Integer  and x.value() > 0 \
         or type(x) is Rpn_Float    and x.value() > 0.0 \
         or type(x) is Rpn_Rational and x.value() > 0:
        r = math.sqrt(float(x.value()))
        if type(x) is Rpn_Integer and r.is_integer():
            result = Rpn_Integer(r)
        else:
            result = Rpn_Float(r)
    elif    type(x) is Rpn_Complex \
         or type(x) is Rpn_Integer  and x.value() < 0 \
         or type(x) is Rpn_Float    and x.value() < 0.0 \
         or type(x) is Rpn_Rational and x.value() < 0:
        result = Rpn_Complex.from_complex(cmath.sqrt(complex(x.value())))
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("sqrt: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='std', print_x=False, doc="""\
std  ( -- )

Set display mode to standard.""")
def w_std():
    disp_stack.top().set_style("std")
    set_flag(FLAG_DISP_FIX)
    set_flag(FLAG_DISP_ENG)
    for bit in range(4):
        clear_flag(39 - bit)


@defword(name='stdev', print_x=True, doc="""\
Print the sample standard deviation of the statistics data""")
def w_stdev():
    global stat_list
    if len(stat_list) < 2:
        raise Rpn_E_Runtime_Error("stdev: Insufficient statistics data (2 required)")
    try:
        s = statistics.stdev(stat_list)
    except statistics.StatisticsError as e:
        raise Rpn_E_Runtime_Error("stdev: {}".format(str(e)))
    result = Rpn_Float(s)
    result.set_label("stdev")
    param_stack.push(result)


@defword(name='sto', args=2, doc="""\
Store value Y into register X  ( y reg -- )""")
def w_sto():
    global register
    (reg_size, _) = lookup_variable("SIZE")

    x = param_stack.pop()
    y = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Type_Error("sto: Type error ({}, {})".format(typename(y), typename(x)))
    reg = x.value()
    if reg < 0 or reg >= reg_size.obj().value():
        param_stack.push(y)
        param_stack.push(x)
        raise Rpn_E_Value_Error("sto: Register '{}' out of range (0..{} expected)".format(reg, reg_size.obj().value() - 1))
    if type(y) in [Rpn_Float, Rpn_Complex]:
        register[reg] = y
    else:
        register[reg] = Rpn_Float(y.value())


@defword(name='swap', args=2, doc="""\
Exchange top two stack elements  ( y x -- x y )
Equivalent to 1 ROLL""")
def w_swap():
    x = param_stack.pop()
    y = param_stack.pop()
    param_stack.push(x)
    param_stack.push(y)


@defword(name='tan', args=1, print_x=True, doc="""\
Tangent  ( angle -- tangent )

NOTE:
Angle must not be 90 degrees (TAU/4 radians)""")
def w_tan():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        try:
            r = math.tan(convert_mode_to_radians(x.value()))
        except ValueError:
            param_stack.push(x)
            raise Rpn_E_Value_Error("tan: Argument {} out of range".format(x.value()))
        result = Rpn_Float(r)
    elif type(x) is Rpn_Complex:
        try:
            r = cmath.tan(x.value())
        except ValueError:
            param_stack.push(x)
            raise Rpn_E_Value_Error("tan: Argument {} out of range".format(x.value()))
        result = Rpn_Complex.from_complex(r)
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("tan: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='tanh', args=1, print_x=True, doc="""\
Hyperbolic tangent  ( angle -- tangent_h )

DEFINITION:
tanh(x) = sinh(x) / cosh(x)""")
def w_tanh():
    x = param_stack.pop()
    if type(x) in [Rpn_Integer, Rpn_Float, Rpn_Rational]:
        result = Rpn_Float(math.tanh(x.value()))
    elif type(x) is Rpn_Complex:
        result = Rpn_Complex.from_complex(cmath.tanh(x.value()))
    else:
        param_stack.push(x)
        raise Rpn_E_Type_Error("tanh: Type error ({})".format(typename(x)))
    param_stack.push(result)


@defword(name='TAU', print_x=False, doc="""\
Constant: Tau ( -- 6.28318... )

DEFINITION:
Number of radians in a circle.""")
def w_TAU():
    result = Rpn_Float(TAU)
    result.set_label("TAU")
    param_stack.push(result)


@defword(name='tf', args=1, doc="""\
Toggle flag  ( f -- )""")
def w_tf():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("tf: Type error ({})".format(typename(x)))
    flag = x.value()
    if flag < 0 or flag >= FLAG_MAX:
        param_stack.push(x)
        raise Rpn_E_Value_Error("tf: Flag {} out of range (0..{} expected)".format(flag, FLAG_MAX - 1))
    if flag >= FLAG_FENCE:
        param_stack.push(x)
        raise Rpn_E_Value_Error("tf: Flag {} cannot be modified".format(flag))
    toggle_flag(flag)


@defword(name='then', args=1, doc="""\
Execute a conditional test.
<flag> IF ... [ ELSE ... ] THEN

qv ELSE, IF""")
def w_then():
    pass                        # Grammar rules handle this word


@defword(name='throw', args=1, print_x=False, doc="""\
Throw an exception  ( n -- )

N must be positive.

qv CATCH""")
def w_throw():
    x = param_stack.pop()
    if type(x) is not Rpn_Integer:
        param_stack.push(x)
        raise Rpn_E_Type_Error("throw: Type error ({})".format(typename(x)))
    if x.value() <= 0:
        param_stack.push(x)
        raise Rpn_E_Runtime_Error("throw: X must be positive")
    dbg("catch", 1, "{}: Throwing {}".format(whoami(), x.value()))
    raise Rpn_E_Throw(x.value())


@defword(name='time', print_x=True, doc="""\
Current time  ( -- HH.MMSS )""")
def w_time():
    t = datetime.datetime.now().strftime("%H.%M%S")
    result = Rpn_Float(t)
    result.set_label("HH.MMSS (Current)")
    param_stack.push(result)


@defword(name='time!', print_x=True, doc="""\
High precision clock time  ( -- HH.MMSSssss )""")
def w_time_bang():
    t = datetime.datetime.now().strftime("%H.%M%S%f")
    result = Rpn_Float(t)
    result.set_label("HH.MMSSssss (Current)")
    param_stack.push(result)


@defword(name='timeinfo', args=1, hidden=True, print_x=False, doc="""\
Show time_info() for Float  ( x -- )""")
def w_timeinfo():
    x = param_stack.pop()
    if type(x) is not Rpn_Float:
        param_stack.push(x)
        raise Rpn_E_Type_Error("timeinfo: Type error ({})".format(typename(x)))
    writeln("timeinfo: {}".format(x.time_info()))


@defword(name='trace', doc="""\
Toggle tracing state""")
def w_trace():
    if dbg("trace"):
        set_debug_level("trace", 0)
        lnwriteln("trace: Tracing is now disabled")
    else:
        set_flag(FLAG_DEBUG_ENABLED)
        set_debug_level("trace", 1)
        lnwriteln("trace: Tracing is now ENABLED")


@defword(name='trn', args=1, doc="""\
Transpose a matrix  ( mat -- mat_T )""")
def w_trn():
    x = param_stack.pop()
    if type(x) is Rpn_Vector:
        # Transposing a vector is allowed but has no effect.
        # It does NOT "convert a 1-D array into a 2D column vector".
        param_stack.push(x)
        return
    if type(x) is not Rpn_Matrix:
        param_stack.push(x)
        raise Rpn_E_Type_Error("trn: Type error ({})".format(typename(x)))
    t = Rpn_Matrix.from_numpy(np.matrix.transpose(x.value()))
    param_stack.push(t)


@defword(name='undef', doc="""\
Undefine a variable, removing it from the current scope.
UNDEF <var>""")
def w_undef():
    pass                        # Grammar rules handle this word


@defword(name='until', doc="""\
Execute an indefinite loop until a condition is satisfied.
BEGIN ... <flag> UNTIL

LEAVE will exit the loop early.  Note that the effect of the test in
BEGIN...WHILE is opposite that in BEGIN...UNTIL.  The loop repeats
while something is true, rather than until it becomes true.

qv AGAIN, BEGIN, LEAVE, REPEAT, WHILE""")
def w_until():
    pass                        # Grammar rules handle this word


if have_numpy:
    @defword(name='v>', args=1, doc="""\
Decompose a vector into stack elements""")
    def w_v_from():
        x = param_stack.pop()
        if type(x) is not Rpn_Vector:
            param_stack.push(x)
            raise Rpn_E_Type_Error("v>: Type error ({})".format(typename(x)))
        for elem in x.value():
            param_stack.push(to_rpn_class(elem))


@defword(name='var', print_x=True, doc="""\
Print the sample variance of the statistics data""")
def w_var():
    global stat_list
    if len(stat_list) < 2:
        raise Rpn_E_Runtime_Error("var: Insufficient statistics data (2 required)")
    try:
        v = statistics.variance(stat_list)
    except statistics.StatisticsError as e:
        raise Rpn_E_Runtime_Error("var: {}".format(str(e)))
    param_stack.push(Rpn_Float(v))


@defword(name='variable', doc="""\
Declare a variable.  Initial state is undefined.
VARIABLE <var>""")
def w_variable():
    pass                        # Grammar rules handle this word


@defword(name='vars', print_x=False, doc="""\
List variables and their values""")
def w_vars():
    global scr_cols
    for (_, scope) in scope_stack.items_top_to_bottom():
        if scope_stack.size() > 1:
            lnwriteln("Scope {}".format(scope.name()))
        my_vars = dict()
        for varname in scope.variables():
            var = scope.variable(varname)
            if var.hidden():
                continue
            my_vars[var.name()] = "{}:[undef]".format(var.name()) if not var.defined() else \
                                  "{}={}{}".format(var.name(),
                                                   var.obj().value(),
                                                   "(" + typename(var.obj()) + ")" if flag_set_p(FLAG_DEBUG_ENABLED) else "")
        sorted_vars = []
        for key in sorted(my_vars, key=str.casefold):
            sorted_vars.append(my_vars[key])
        list_in_columns(sorted_vars, scr_cols.obj().value() - 1)


@defword(name='vlist', print_x=False, doc="""\
Print the list of defined words.
Only words in the global scope are shown.

qv WORDS""")
def w_vlist():
    global scr_cols
    # This is nice, but it shows hidden words:
    # list_in_columns(sorted([ x for x in global_scope.words() ],
    #                        key=str.casefold), scr_cols.obj().value() - 1)
    words = dict()
    for wordname in global_scope.words():
        word = global_scope.word(wordname)
        if word.hidden():
            continue
        words[word.name()] = word.name()
    sorted_words = []
    for key in sorted(words, key=str.casefold):
        sorted_words.append(words[key])
    list_in_columns(sorted_words, scr_cols.obj().value() - 1)


@defword(name='while', doc="""\
Execute an indefinite loop while a condition is satisfied.
BEGIN ... <flag> WHILE ... REPEAT

LEAVE will exit the loop early.  Note that the effect of the test in
BEGIN...WHILE is opposite that in BEGIN...UNTIL.  The loop repeats
while something is true, rather than until it becomes true.

qv AGAIN, BEGIN, LEAVE, REPEAT, UNTIL""")
def w_while():
    pass                        # Grammar rules handle this word


@defword(name='words', print_x=False, doc="""\
Print the list of user-defined words.

qv VLIST""")
def w_words():
    global scr_cols
    list_in_columns(sorted([ x[0] for x in global_scope.unprotected_words() ],
                           key=str.casefold), scr_cols.obj().value() - 1)


@defword(name='zer', args=1, print_x=False, doc="""\
zero  ( v -- m )  Create a zero vector or matrix""")
def w_zer():
    x = param_stack.pop()
    if type(x) is not Rpn_Vector:
        param_stack.push(x)
        raise Rpn_E_Type_Error("zer: Type error ({})".format(typename(x)))
    xs = x.size()

    if xs == 1:
        size = int(x.value().item(0))
        if size <= 0:
            param_stack.push(x)
            raise Rpn_E_Value_Error("zer: Dimension must be positive")
        z = Rpn_Vector.from_numpy(np.zeros(size))
        param_stack.push(z)
    elif xs == 2:
        rows = int(x.value().item(0))
        cols = int(x.value().item(1))
        if rows <= 0 or cols <= 0:
            param_stack.push(x)
            raise Rpn_E_Value_Error("zer: Dimensions must be positive")
        z = Rpn_Matrix.from_numpy(np.zeros((rows, cols)))
        param_stack.push(z)
    else:
        param_stack.push(x)
        raise Rpn_E_Runtime_Error("zero: Dimension vector must have only 1 or 2 elements")



#############################################################################
#
#       T V M   U T I L I T Y   F U N C T I O N S
#
#       Note:   (1+i)^N  ==  exp(N * log1p(i))
#
#############################################################################
def solve_for_interest():
    eps = 1e-6
    i = {}
    i[0] = i_initial_guess()
    dbg("tvm", 3, "i[0] = {}".format(i[0]))

    def f(i):
        X = tvm_X()
        A = math.expm1(tvm_N.obj().value() * math.log1p(i))
        B = (1.0 + i*X) / i
        C = tvm_PMT.obj().value() * B
        PV = tvm_PV.obj().value()
        FV = tvm_FV.obj().value()
        # f(i) = A(PV+C) + PV + FV
        res = A*(PV+C) +  PV + FV
        return res

    def df(i):
        X = tvm_X()
        A = math.expm1(tvm_N.obj().value() * math.log1p(i))
        B = (1.0 + i*X) / i
        C = tvm_PMT.obj().value() * B
        D = (A+1) / (1+i)
        PV = tvm_PV.obj().value()
        # f'(i) = n*D*(PV+C) - (A*C)/i
        res = tvm_N.obj().value()*D*(PV+C) - ((A*C)/i)
        return res

    k = 0
    while True:
        i[k+1] = i[k] - (f(i[k]) / df(i[k]))
        diff = i[k+1] - i[k]
        dbg("tvm", 3, "i[{}] = {}; diff={}".format(k+1, i[k+1], diff))
        if abs(diff) < eps:
            return i[k+1]
        k += 1
        if k > 100:
            raise Rpn_E_Runtime_Error("INT: No solution")

def i_initial_guess():
    n   = tvm_N  .obj().value()
    PV  = tvm_PV .obj().value()
    PMT = tvm_PMT.obj().value()
    FV  = tvm_FV .obj().value()

    if PMT * FV < 0:
        # FV case
        denom = 3 * ((n-1)**2 * PMT + PV - FV)
        if PV == 0:
            i_0 = abs((FV + n*PMT) / denom)
        else:
            i_0 = abs((FV - n*PMT) / denom)
    else:
        # PV case
        if PV*PMT < 0:
            i_0 = abs((n*PMT + PV + FV) / (n*PV))
        else:
            # Invalid conditions for sophisticated initial guess;
            # fall back to simpler guess
            pv_fv = abs(PV) + abs(FV)
            i_0 = abs(PMT / pv_fv) + abs(pv_fv / (n**3 * PMT))

    return i_0


def int_nom_to_eff(int_nom):
    global tvm_CF, tvm_PF

    CF = tvm_CF.obj().value()
    PF = tvm_PF.obj().value()

    if flag_set_p(FLAG_TVM_CONTINUOUS):
        # int_eff = e^(i/PF) - 1
        int_eff = math.expm1(int_nom / PF)
    else:
        # int_eff = (1+i/CF)^(CF/PF) - 1
        int_eff = math.expm1((CF/PF) * math.log1p(int_nom/CF))

    dbg("tvm", 3, "int_nom_to_eff ({}): NOM={} -> EFF={}".format(
        "Continuous" if flag_set_p(FLAG_TVM_CONTINUOUS) else "Discrete",
        int_nom, int_eff))
    return int_eff


def int_eff_to_nom(int_eff):
    global tvm_CF, tvm_PF

    CF = tvm_CF.obj().value()
    PF = tvm_PF.obj().value()

    if flag_set_p(FLAG_TVM_CONTINUOUS):
        # int_nom = LN[ (1+int_eff)^PF ]
        int_nom = PF * math.log1p(int_eff)
    else:
        # int_nom = CF * [ (1+int_eff)^(PF/CF) - 1]
        int_nom = CF * (math.expm1((PF/CF) * math.log1p(int_eff)))

    dbg("tvm", 3, "int_eff_to_nom ({}): EFF={} -> NOM={}".format(
        "Continuous" if flag_set_p(FLAG_TVM_CONTINUOUS) else "Discrete",
        int_eff, int_nom))
    return int_nom


def tvm_i():
    if not tvm_INT.defined():
        return None
    i_e = int_nom_to_eff(tvm_INT.obj().value())
    dbg("tvm", 3, "{}: i_e={}".format(whoami(), i_e))
    return i_e / 100.0

def tvm_X():
    # X = Begin/End flag
    return flag_int_value(FLAG_TVM_BEGIN_MODE) # 0 or 1

def tvm_A():
    # A = (1+i)^n - 1
    if not tvm_N.defined():
        return None
    n = tvm_N.obj().value()
    i = tvm_i()
    if i is None:
        return None
    A = math.expm1(n * math.log1p(i))
    dbg("tvm", 3, "{}: A={}".format(whoami(), A))
    return A

def tvm_B():
    # B = (1+iX)/i
    i = tvm_i()
    if i is None:
        return None
    X = tvm_X()
    B = (1.0 + i*X) / i
    dbg("tvm", 3, "{}: B={}".format(whoami(), B))
    return B

def tvm_C():
    # C = PMT * B
    if not tvm_PMT.defined():
        return None
    PMT = tvm_PMT.obj().value()
    B = tvm_B()
    if B is None:
        return None
    C = PMT * B
    dbg("tvm", 3, "{}: C={}".format(whoami(), C))
    return C


def any_undefined_p(var_list):
    for var in var_list:
        if not var.defined():
            return True
    return False




#############################################################################
#
#       U T I L I T Y   F U N C T I O N S
#
#############################################################################
def bool_to_int(condition):
    return 1 if condition is True else 0


def execute(executable):
    try:
        executable.__call__()
    except KeyboardInterrupt:
        lnwriteln("[Interrupt]")
    except RecursionError:
        lnwriteln("{}: Excessive recursion".format(executable))
    except Rpn_E_Exit as e:
        pass
    except Rpn_E_Runtime_Error as e:
        lnwriteln(str(e))
    except Rpn_E_Type_Error as e:
        #traceback.print_stack(file=sys.stderr)
        lnwriteln(str(e))
    except Rpn_E_Value_Error as e:
        #traceback.print_stack(file=sys.stderr)
        lnwriteln(str(e))


def memoize(f):
    memoized = {}
    def helper(x):
        if x not in memoized:
            memoized[x] = f(x)
        return memoized[x]
    return helper


def comb_helper(n, r):
    if r > n or r < 0:
        return 0
    if n - r < r:
        r = n - r

    result = 1
    j = 1
    while j <= r:
        result *= n
        n -= 1
        result /= j
        j += 1
    return result


def plot_helper(func, x_low, x_high):
    global scr_rows, scr_cols
    cols = scr_cols.obj().value()
    rows = scr_rows.obj().value()

    ISCR   = cols - 20
    JSCR   = rows -  3
    BLANK  = ' '
    VERT   = ':'
    VZERO  = '|'
    HORIZ  = '-'
    HZERO  = '='
    ORIGIN = '+'
    FF     = '*'
    scr = [[BLANK for i in range(1,JSCR+2)] for j in range(1,ISCR+2)]

    # Build frame
    for j in range(1, JSCR+1):
        scr[1][j] = VERT
        scr[ISCR][j] = VERT
    for i in range(2, ISCR):
        scr[i][1] = HORIZ
        scr[i][JSCR] = HORIZ
        for j in range(2, JSCR):
            scr[i][j] = BLANK

    if x_low > x_high:
        x_low, x_high = x_high, x_low
    x = x_low
    dx = (x_high - x_low) / (ISCR - 1)
    dxi = (ISCR - 1) / (x_high - x_low)
    iz = 1 - int(x_low * dxi)

    y = [0.0] * (ISCR+1)
    ysml, ybig = 0.0, 0.0
    for i in range(1, ISCR+1):
        y[i] = func(x)
        ysml = min(ysml, y[i])
        ybig = max(ybig, y[i])
        x += dx

    if ybig == ysml:
        ybig = ysml + 1.0
    dyj = (JSCR - 1) / (ybig - ysml)
    jz = 1 - int(ysml * dyj)

    # Build axes
    for i in range(2, ISCR):
        for j in range(2, JSCR):
            if i == iz:
                scr[i][j] = VZERO
            if j == jz:
                scr[i][j] = HZERO
            if i == iz and j == jz:
                scr[i][j] = ORIGIN

    # Populate data points
    for i in range(1, ISCR+1):
        j = 1 + int((y[i] - ysml) * dyj)
        scr[i][j] = FF

    # Display plot
    write(" {:10.3f} ".format(ybig))
    for i in range(1, ISCR+1):
        write(scr[i][JSCR])
    writeln()
    for j in range(JSCR-1, 1, -1):
        write(" " * 12)
        for i in range(1, ISCR+1):
            write(scr[i][j])
        writeln()
    write(" {:10.3f} ".format(ysml))
    for i in range(1, ISCR+1):
        write(scr[i][1])
    lnwriteln("         {:10.3f} {} {:10.3f}".format(x_low, " "*(cols-36), x_high))


def angle_mode_label():
    global angle_mode
    if angle_mode == "r":
        return "Rad"
    if angle_mode == "d":
        return "Deg"
    if angle_mode == "g":
        return "Grad"
    raise Rpn_E_Fatal("Bad angle_mode '{}'".format(angle_mode))


def convert_mode_to_radians(x, force_mode=None):
    global angle_mode
    mode = force_mode if force_mode is not None else angle_mode
    if mode == "r":
        return x
    if mode == "d":
        return x / DEG_PER_RAD
    if mode == "g":
        return x / GRAD_PER_RAD
    raise Rpn_E_Fatal("{}: Bad angle_mode '{}'".format(whoami(), mode))


def convert_radians_to_mode(r, force_mode=None):
    global angle_mode
    mode = force_mode if force_mode is not None else angle_mode
    if mode == "r":
        return r
    if mode == "d":
        return r * DEG_PER_RAD
    if mode == "g":
        return r * GRAD_PER_RAD
    raise Rpn_E_Fatal("{}: Bad angle_mode '{}'".format(whoami(), mode))


def define_secondary_words():
    eval_string(r"""
: TRUE          doc:"TRUE  ( -- 1 )
Constant: Logical true"
  1 ;

: FALSE         doc:"FALSE  ( -- 0 )
Constant: Logical false"
  0 ;

: i             doc:"i  ( -- i )  Imaginary unit (0,1)

DEFINITION:
i = sqrt(-1)

Do not confuse this with the I command,
which returns the index of a DO loop."
  (0,1) ;

: PHI           doc:"PHI  ( -- 1.618... )   Golden ratio

DEFINITION:
PHI = (1 + sqrt(5)) / 2"
  5 sqrt 1 + 2 / ;

: BL            doc:"BL  ( -- 32 )   ASCII code for a space character"
  32 ;

: ?cr           doc:"?cr  Print a newline only if necessary to return to left margin"
  @#OUT 0 > if
    cr
  then ;

: prompt        doc:"prompt  ( -- n ) [ text -- ]  Prompt for numeric input"
  $depth 0 = if
    ."prompt: Insufficient string parameters (1 required)" cr
  else
    $. #in
  then ;

: space         doc:"space   Display one space character"
  BL emit ;

: spaces        doc:"spaces  ( n -- )   Display N space characters"
  | in:N |
  @N 0 do space loop ;


\ Stack manipulation
: -rot          doc:"-rot  ( z y x -- x z y )  Rotate back
Rotate top stack element back to third spot, pulling others down.
Equivalent to ROT ROT"
  depth 3 < if
    ."-rot: Insufficient parameters (3 required)" cr
  else
    rot rot
  then ;

: nip           doc:"nip  ( y x -- x )
Drop second stack element
Equivalent to SWAP DROP.  J.V. Noble calls this PLUCK."
  depth 2 < if
    ."nip: Insufficient parameters (2 required)" cr
  else
    swap drop
  then ;

: tuck          doc:"tuck  ( y x -- x y x )
Duplicate top stack element into third position
Equivalent to SWAP OVER.  J.V. Noble calls this UNDER."
  depth 2 < if
    ."tuck: Insufficient parameters (2 required)" cr
  else
    swap over
  then ;

: sum           doc:"sum  ( ... -- sum )  Sum all numbers on the stack"
  depth 0= if
      0
  else
      depth 1 > if
          depth 1 - 0 do + loop
      then
  then
;


: debug         doc:"debug  ( -- )  Toggle debugging state"
  20 dup tf  fs? if
    ."Debugging is now ENABLED"
  else
    ."Debugging is now disabled"
  cr then ;

: deg?          doc:"deg?  ( -- flag )  Test if angular mode is degrees"
  42 fc?  43 fc?  and ;

: rad?          doc:"rad?  ( -- flag )  Test if angular mode is radians"
  42 fc?  43 fs?  and ;

: grad?         doc:"grad?  ( -- flag )  Test if angular mode is gradians"
  42 fs?  43 fc?  and ;

: mod           doc:"mod  ( y x -- remainder )  Remainder"
  | in:y in:x |
  @y @x /mod  drop ;


\ Conversion functions
: mm->in doc:"mm->in  ( mm -- inch )  Convert millimeters to inches"
  25.4 / ;

: m->ft  doc:"m->ft  ( m -- ft )  Convert meters to feet"
  1000 * mm->in   12 / ;

: km->mi doc:"km->mi  ( km -- mile )  Convert kilometers to miles"
  1000 *  m->ft 5280 / ;

: in->mm doc:"in->mm  ( inch -- mm )  Convert inches to millimeters"
  25.4 * ;

: ft->m doc:"ft->m  ( ft -- m )  Convert feet to meters"
  12   * in->mm 1000 / ;

: mi->km doc:"mi->km  ( mile -- km )  Convert miles to kilometers"
  5280   * ft->m  1000 / ;

: f->c doc:"f->c  ( f -- c )  Convert degrees fahrenheit to degrees celcius"
  32 - 5 * 9 / ;

: c->f doc:"c->f  ( c -- f )  Convert degrees celcius to degrees fahrenheit"
  9 * 5 / 32 + ;

: g->oz doc:"g->oz  ( g -- oz )  Convert grams to ounces"
  28.349523 / ;

: gal->l  doc:"gal->l  ( gal -- liter )  Convert gallons to liters"
  3.7854118 * ;

: l->gal  doc:"l->gal  ( liter -- gal )  Convert liters to gallons"
  3.7854118 / ;

: kg->lb doc:"kg->lb  ( kg -- lb )  Convert kilograms to pounds"
  0.45359237 / ;

\ : cm3->in3 doc:"cm3->in3  ( cm^3 -- in^3 )  Convert cubic centimeters to cubic inches"
\   16.3871     / ;

: oz->g    doc:"oz->g  ( oz -- g )  Convert ounces to grams"
  28.349523 * ;

: lb->kg   doc:"lb->kg  ( lb -- kg )  Convert pounds to kilograms"
  0.45359237 * ;

\ : in3->cm3  doc:"in3->cm3  ( in^3 -- cm^3 )  Convert cubic inches to cubic centimeters"
\   16.3871     * ;

""")


def define_tertiary_words():
    eval_string("""
""")


def defvar(name, value, **kwargs):
    global_scope.add_varname(name)
    var = Rpn_Variable(name, value, **kwargs)
    dbg(whoami(), 1, "{}: Creating variable {} at address {} in {}".format(whoami(), name, hex(id(var)), repr(global_scope)))
    global_scope.set_variable(name, var)
    return var


def eval_string(s):
    dbg("eval_string", 1, "eval_string('{}')".format(s))
    scope_stack_size = scope_stack.size()
    try:
        result = parser.parse(s) # , debug=dbg("eval_string"))
    except Rpn_E_Parse_Error as e:
        if str(e) != 'EOF':
            lnwriteln("Parse error: {}".format(str(e)))
    except Rpn_E_Abort:
        param_stack.clear()
        string_stack.clear()
        return_stack.clear()
    else:
        if result is not None:
            dbg("eval_string", 1, "result={}".format(result))
    finally:
        if scope_stack.size() > scope_stack_size:
            dbg("eval_string", 1, "Gotta pop {} scopes from the stack".format(scope_stack.size() - scope_stack_size))
        while scope_stack.size() > scope_stack_size:
            pop_scope("Parse failure")


@memoize
def fib_helper(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    return fib_helper(n-1) + fib_helper(n-2)


def gcd_helper(x, y):
    while x != 0:
        y, x = x, y % x
    return y


@memoize
def fact_helper(x):
    result = 1
    while x > 1:
        result *= x
        x -= 1
    return result


def clear_flag(flag):
    global flags_vec
    if flag < 0 or flag >= FLAG_MAX:
        raise Rpn_E_Fatal("{}: Flag {} out of range".format(whoami(), flag))
    flags_vec &= ~(1<<flag)

def set_flag(flag):
    global flags_vec
    if flag < 0 or flag >= FLAG_MAX:
        raise Rpn_E_Fatal("{}: Flag {} out of range".format(whoami(), flag))
    flags_vec |= (1<<flag)

def toggle_flag(flag):
    global flags_vec
    if flag < 0 or flag >= FLAG_MAX:
        raise Rpn_E_Fatal("{}: Flag {} out of range".format(whoami(), flag))
    if flag_set_p(flag):
        clear_flag(flag)
    else:
        set_flag(flag)

def flag_int_value(flag):
    global flags_vec
    if flag < 0 or flag >= FLAG_MAX:
        raise Rpn_E_Fatal("{}: Flag {} out of range".format(whoami(), flag))
    return bool_to_int(flag_set_p(flag))

def flag_set_p(flag):
    global flags_vec
    if flag < 0 or flag >= FLAG_MAX:
        raise Rpn_E_Fatal("{}: Flag {} out of range".format(whoami(), flag))
    return bool(flags_vec & 1<<flag != 0)


# I should really just use __format__() correctly
def fmt(x, show_label=True):
    return disp_stack.top().fmt(x, show_label)


def generate_token_list():
    '''Returns a tuple (flag, list)
flag is True if initial parse error, False if no error'''

    initial_parse_error = False
    parse_stack.clear()
    tok_list = []
    depth = {
        'BRACKET' : 0,
        'PAREN'   : 0
    }

    while True:
        # Get next token
        tok = next(Rpn_Token_Mgr.next_token())
        dbg("token", 1, "token({},{})".format(tok.type, repr(tok.value)))

        # These need a second token or they will be very angry
        if tok.type in ['AT_SIGN', 'CATCH', 'CONSTANT', 'EXCLAM', 'FORGET',
                        'HELP', 'SHOW', 'UNDEF', 'VARIABLE' ]:
            parse_stack.push(tok.type)
            try:
                tok2 = next(Rpn_Token_Mgr.next_token())
                dbg("token", 1, "token({},{})".format(tok2.type, repr(tok2.value)))
            except StopIteration:
                initial_parse_error = True
                dbg("token", 1, "{}: No more tokens, exiting".format(tok.type))
                break
            finally:
                tok_list.append(tok)
                parse_stack.pop()
            tok_list.append(tok2)

        elif tok.type in ['OPEN_BRACKET', 'CLOSE_BRACKET',
                          'OPEN_PAREN',   'CLOSE_PAREN']:
            tok_list.append(tok)
            # borp == "bracket or paren"
            (open_close, borp) = tok.type.split("_")
            #print("borp={}".format(borp))
            if borp == 'PAREN':
                c = '('
            elif borp == 'BRACKET':
                c = '['

            if open_close == 'OPEN':
                if borp == 'PAREN' and depth[borp] > 0:
                    lnwriteln("{}: Embedded {} not allowed".format(tok.type, c))
                    initial_parse_error = True
                else:
                    parse_stack.push(c)
                    depth[borp] += 1

            if open_close == 'CLOSE':
                if parse_stack.empty() or \
                        borp == 'BRACKET' and parse_stack.top() != c or \
                        borp == 'PAREN'   and parse_stack.top() != '(,':
                    lnwriteln("{}: {} lost".format(tok.type, c))
                    initial_parse_error = True
                else:
                    parse_stack.pop()
                    depth[borp] -= 1

        elif tok.type == 'COMMA':
            if parse_stack.empty() or parse_stack.top() != '(':
                lnwriteln("{}: no matching (".format(tok.type))
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()
                parse_stack.push('(,')

        elif tok.type in ['BEGIN', 'CASE', 'COLON', 'DO', 'IF']:
            tok_list.append(tok)
            parse_stack.push(tok.type)

        elif tok.type in ['AGAIN', 'UNTIL']:
            if parse_stack.empty() or parse_stack.top() != 'BEGIN':
                lnwriteln("{}: no matching BEGIN".format(tok.type))
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()

        elif tok.type == 'ELSE':
            if parse_stack.empty() or parse_stack.top() != 'IF':
                lnwriteln("ELSE: no matching IF")
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()
                parse_stack.push(tok.type)

        elif tok.type == 'ENDCASE':
            if parse_stack.empty() or parse_stack.top() not in ['CASE', 'OTHERWISE']:
                lnwriteln("ENDCASE: no matching CASE")
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()

        elif tok.type == 'ENDOF':
            if parse_stack.empty() or parse_stack.top() != 'OF':
                lnwriteln("ENDOF: no matching OF")
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()
                parse_stack.push('CASE')

        elif tok.type == 'ERROR':
            lnwriteln("ERROR {}".format(tok))
            initial_parse_error = True

        elif tok.type in ['LOOP', 'PLUS_LOOP']:
            if parse_stack.empty() or parse_stack.top() != 'DO':
                lnwriteln("{}: no matching DO".format(tok.type))
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()

        elif tok.type in ['OF', 'OTHERWISE']:
            if parse_stack.empty() or parse_stack.top() != 'CASE':
                lnwriteln("{}: no matching CASE".format(tok.type))
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()
                parse_stack.push(tok.type)

        elif tok.type == 'REPEAT':
            if parse_stack.empty() or parse_stack.top() != 'WHILE':
                lnwriteln("REPEAT: no matching WHILE")
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()

        elif tok.type == 'SEMICOLON':
            if parse_stack.empty() or parse_stack.top() != 'COLON':
                lnwriteln("SEMICOLON: no matching COLON")
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()

        elif tok.type == 'THEN':
            if parse_stack.empty() or parse_stack.top() not in ['IF', 'ELSE']:
                lnwriteln("THEN: no matching IF")
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()

        elif tok.type == 'WHILE':
            if parse_stack.empty() or parse_stack.top() != 'BEGIN':
                lnwriteln("WHILE: no matching BEGIN")
                initial_parse_error = True
            else:
                tok_list.append(tok)
                parse_stack.pop()
                parse_stack.push(tok.type)

        else:
        # 'ABORT_QUOTE',
        # 'DOC_STR',
        # 'DOT_QUOTE',
        # 'IDENTIFIER',
        # 'VBAR',
        # 'WS',
            tok_list.append(tok)

        # Here's what breaks the while True loop, sauf StopIteration
        if parse_stack.empty() and depth['PAREN'] == 0 and depth['BRACKET'] == 0:
            break

    return (initial_parse_error, tok_list)


# Helper routines for KEY
class _Getch_Windows:
    def __init__(self):
        import msvcrt

    def __call__(self):
        import msvcrt
        return msvcrt.getch()

class _Getch_Unix:
    def __init__(self):
        # import termios now or else you'll get the Unix version on the Mac
        import termios

    def __call__(self):
        import termios
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch

class _Getch:
    """Gets a single character from standard input.  Does not echo to the screen."""

    def __init__(self):
        try:
            self.impl = _Getch_Windows()
        except ImportError:
            self.impl = _Getch_Unix()


    def __call__(self):
        return self.impl()


# Jeffrey Magedanz - https://stackoverflow.com/posts/42602689/revisions
def list_in_columns(items, width=79, indent=0, spacing=3):
    """\
Return string listing items along columns.

items : sequence
    List of items to display that must be directly convertible into
    unicode strings.
width : int
    Maximum number of characters per line, including indentation.
indent : int
    Number of spaces in left margin.
spacing : int
    Number of spaces between columns."""

    if not items:
        return u''
    # Ensure all items are strings
### items = [unicode(item) for item in items]
    # Estimate number of columns based on shortest and longest items
    minlen = min(len(item) for item in items)
    maxlen = max(len(item) for item in items)
    # Assume one column with longest width, remaining with shortest.
    # Use negative numbers for ceiling division.
    ncols = 1 - (-(width - indent - maxlen) // (spacing + min(1, minlen)))
    ncols = max(1, min(len(items), ncols))

    # Reduce number of columns until items fit (or only one column)
    while ncols >= 1:
        # Determine number of rows by ceiling division
        nrows = -(-len(items) // ncols)
        # Readjust to avoid empty last column
        ncols = -(-len(items) // nrows)
        # Split items into columns, and test width
        columns = [items[i*nrows:(i+1)*nrows] for i in range(ncols)]
        totalwidth = indent - spacing + sum(
            spacing + max(len(item) for item in column)
            for column in columns)
        # Stop if columns fit. Otherwise, reduce number of columns and
        # try again.
        if totalwidth <= width:
            break
        ncols -= 1

    # Pad all items to column width
    for i, column in enumerate(columns):
        colwidth = max(len(item) for item in column)
        columns[i] = [
            item + ' ' * (colwidth - len(item))
            for item in column
            ]

    # Transpose into rows, and return joined rows
    rows = list(itertools.zip_longest(*columns, fillvalue=''))
    out = '\n'.join(' ' * indent + (u' ' * spacing).join(row).rstrip()
                    for row in rows)
    writeln(out)


def load_file(filename):
    try:
        with open(filename, "r") as file:
            contents = file.read()
    except PermissionError:
        raise Rpn_E_Runtime_Error("load: Cannot read file '{}'".format(filename))
    else:
        eval_string(contents)


def lookup_varname(varname):
    for (_, scope) in scope_stack.items_top_to_bottom():
        dbg(whoami(), 1, "{}: Looking for varname {} in {}...".format(whoami(), varname, repr(scope)))
        dbg(whoami(), 3, "{} has varnames: {}".format(scope, scope.all_varnames()))
        if varname in scope.all_varnames():
            dbg(whoami(), 1, "{}: Found varname {} in {}".format(whoami(), varname, repr(scope)))
            return (varname, scope)
    dbg(whoami(), 1, "{}: Varname {} not found".format(whoami(), varname))
    return (None, None)


def lookup_variable(name, how_many=1):
    for (_, scope) in scope_stack.items_top_to_bottom():
        dbg(whoami(), 1, "{}: Looking for variable {} in {}...".format(whoami(), name, repr(scope)))
        dbg(whoami(), 3, "{} has variables: {}".format(scope, scope.variables()))
        var = scope.variable(name)
        if var is None:
            continue
        how_many -= 1
        if how_many > 0:
            continue
        dbg(whoami(), 1, "{}: Found variable {} in {}: {}".format(whoami(), name, repr(scope), repr(var)))
        return (var, scope)
    dbg(whoami(), 1, "{}: Variable {} not found".format(whoami(), name))
    #traceback.print_stack(file=sys.stderr)
    return (None, None)


def lookup_word(name):
    for (_, scope) in scope_stack.items_top_to_bottom():
        #lnwriteln("{}: Looking for word {} in {}...".format(whoami(), name, scope))
        #lnwriteln("{} has words: {}".format(scope, scope.words))
        word = scope.word(name)
        if word is not None:
            #lnwriteln("{}: Found word {} in {}: {}".format(whoami(), name, scope, word))
            return (word, scope)
    #lnwriteln("{}: Word {} not found".format(whoami(), name))
    return (None, None)


def normalize_hms(hh, mm, ss):
    while ss < 0:
        mm -=  1
        ss += 60
    while ss >= 60:
        mm +=  1
        ss -= 60
    while mm < 0:
        hh -=  1
        mm += 60
    while mm >= 60:
        hh +=  1
        mm -= 60
    return (hh, mm, ss)


def to_python_class(n):
    t = type(n)
    if t is np.int64:
        return int(n)
    if t is np.float64:
        return float(n)
    if t is np.complex128:
        return complex(n)
    raise Rpn_E_Fatal("{}: Cannot handle type {}".format(whoami(), t))


def to_rpn_class(n):
    t = type(n)
    if t is np.int64:
        return Rpn_Integer(n)
    if t is float:
        return Rpn_Float(n)
    if t is np.float64:
        return Rpn_Float(n)
    if t is Fraction:
        return Rpn_Rational.from_Fraction(n)
    if t is complex:
        return Rpn_Complex.from_complex(n)
    raise Rpn_E_Fatal("{}: Cannot handle type {}".format(whoami(), t))


def parse_args():
    try:
        opts, argv = getopt.getopt(sys.argv[1:], "df:il:")
    except getopt.GetoptError as e:
        print(str(e))           # OK
        usage()

    for opt, arg in opts:
        if opt == "-d":
            set_flag(FLAG_DEBUG_ENABLED)
        elif opt == "-f":
            try:
                load_file(arg)
            except FileNotFoundError:
                lnwriteln("-f: File '{}' does not exist".format(arg))
                sys.exit(1)
            except Rpn_E_Runtime_Error as e:
                lnwriteln(str(e))
                sys.exit(1)
            else:
                sys.exit(0)
        elif opt == "-i":
            global force_interactive
            force_interactive = True
        elif opt == "-l":
            try:
                load_file(arg)
            except FileNotFoundError:
                lnwriteln("-l: File '{}' does not exist".format(arg))
            except Rpn_E_Runtime_Error as e:
                lnwriteln(str(e))
        else:
            print("Unhandled option {}".format(opt)) # OK
            sys.exit(1)

    return argv


def prompt_string():
    global angle_mode
    s = "[{}{}] ".format(angle_mode, param_stack.size())

    if not parse_stack.empty():
        qq = " ".join([ p[1] for p in parse_stack.items_bottom_to_top() ])
        s += qq + " ... "
    return s


def pop_scope(why):
    try:
        scope = scope_stack.pop()
    except Rpn_E_Stack_Underflow:
        traceback.print_stack(file=sys.stderr)
        raise Rpn_E_Fatal("Attempting to pop Global scope!")

    dbg("scope", 2, "Pop  {} due to {}".format(repr(scope), why))
    #dbg("scope", 1, "Pop  {}".format(repr(scope)))
    if scope == global_scope:
        traceback.print_stack(file=sys.stderr)
        raise Rpn_E_Fatal("Attempting to pop Global scope!")

def push_scope(scope, why):
    dbg("scope", 2, "Push {} due to {}".format(repr(scope), why))
    scope_stack.push(scope)


def sigquit_handler(_signum, _frame):
    lnwriteln("[Quit]")
    raise Rpn_E_End_Program()


# Simple SIGWINCH handler can become overwhelmed and crash if window
# changes come too fast.  Consider using shutil.get_terminal_size()
def sigwinch_handler(_signum, _frame):
    global scr_cols, scr_rows
    tty_rows = 0
    tty_columns = 0
    if sys.stdin.isatty():
        stty_size = subprocess.check_output(['stty', 'size']).decode().split()
        if len(stty_size) == 2:
            tty_rows, tty_columns = stty_size

    #lnwriteln("{} x {}".format(tty_rows, tty_columns))
    if int(tty_columns) == 0:
        env_cols = os.getenv("COLUMNS")
        tty_columns = int(env_cols) if env_cols is not None else 80
    if int(tty_rows) == 0:
        env_rows = os.getenv("ROWS")
        tty_rows = int(env_rows) if env_rows is not None else 24
    scr_rows   .set_obj(Rpn_Integer(tty_rows))
    scr_cols.set_obj(Rpn_Integer(tty_columns))


def write(s=""):
    if len(s) == 0:
        return
    global sharpout
    outval = sharpout.obj().value()
    newline = s.find("\n")
    while newline != -1:
        substring = s[:newline]
        print(substring)       # OK
        outval = 0
        s = s[newline+1:]
        newline = s.find("\n")
    outval += len(s)
    print(s, end='', flush=True) # OK
    sharpout.set_obj(Rpn_Integer(outval))

def writeln(s=""):
    global sharpout
    print(s, flush=True)       # OK
    sharpout.set_obj(Rpn_Integer(0))

def lnwrite(s=""):
    global sharpout
    if sharpout.obj().value() != 0:
        writeln()
    write(s)

def lnwriteln(s=""):
    global sharpout
    if sharpout.obj().value() != 0:
        writeln()
    writeln(s)



#############################################################################
#
#       M A I N   L O O P   &   P R I M A R Y   F U N C T I O N S
#
#############################################################################
def usage():
    print("""\
Usage: rpn [-d] [-f FILE] [-i] [-l FILE] cmds...

-d        Enable debugging
-f FILE   Load FILE and exit
-i        Force interactive mode
-l FILE   Load FILE""")
    sys.exit(64)


def initialize():
    global RPN_VERSION, default_protected

    sys.setrecursionlimit(2000) # default is 1000
    random.seed()
    disp_stack.push(Rpn_Display_Config())
    push_scope(global_scope, "Global scope")
    define_variables()
    w_std()
    w_clreg()
    w_clflag()
    w_clfin()
    define_secondary_words()

    # Switch to user mode; words & variables are no longer protected
    default_protected = False
    define_tertiary_words()

    # Set up signal handling
    signal.signal(signal.SIGQUIT, sigquit_handler)
    signal.signal(signal.SIGWINCH, sigwinch_handler)
    sigwinch_handler(0, 0)     # Read & define ROWS and COLS via stty(1)

    # Attempt to load the user's init file
    init_file = os.path.expanduser("~/.rpnrc")
    if os.path.isfile(init_file):
        (rpnrc, _) = lookup_variable('RPNRC')
        rpnrc.set_obj(Rpn_String(init_file))
        load_file(init_file)

    # Parse command line
    argv = parse_args()

    if len(argv) > 0:
        global go_interactive
        if not force_interactive:
            go_interactive = False
        s = " ".join([ arg for arg in argv ])
        eval_string(s)


# def example_pre_hook_func(ident, cur_obj, new_obj):
#     print("example_pre_hook_func:")
#     print("ident  ={}".format(ident))
#     print("cur_obj={}".format(repr(cur_obj)))
#     print("new_obj={}".format(repr(new_obj)))
#     # Check against None first due to undef case
#     if new_obj is not None and new_obj.value() < 0:
#         raise Rpn_E_Runtime_Error("{} cannot be negative".format(ident))
#
# def example_post_hook_func(ident, old_obj, cur_obj):
#     print("example_post_hook_func:")
#     print("ident  ={}".format(ident))
#     print("old_obj={}".format(repr(old_obj)))
#     print("cur_obj={}".format(repr(cur_obj)))

def require_int(identifier, _cur, new):
    if type(new) is not Rpn_Integer:
        raise Rpn_E_Runtime_Error("!{}: Type error ({})".format(identifier, typename(new)))

def require_int_or_float(identifier, _cur, new):
    if type(new) not in [Rpn_Integer, Rpn_Float]:
        raise Rpn_E_Runtime_Error("!{}: Type error ({})".format(identifier, typename(new)))

def require_positive(identifier, _cur, new):
    if new.value() <= 0:
        raise Rpn_E_Runtime_Error("!{}: Must be positive".format(identifier))

def require_non_negative(identifier, _cur, new):
    if new.value() < 0:
        raise Rpn_E_Runtime_Error("!{}: Must be non-negative".format(identifier))

def validate_size_arg(identifier, _cur, new):
    if type(new) is not Rpn_Integer:
        raise Rpn_E_Runtime_Error("!{}: Type error ({})".format(identifier, typename(new)))
    new_size = new.value()
    if new_size < REG_SIZE_MIN or new_size > REG_SIZE_MAX:
        raise Rpn_E_Runtime_Error("!{}: Size {} out of range ({}..{} expected)".format(identifier, new_size, REG_SIZE_MIN, REG_SIZE_MAX))

def clear_newly_unveiled_registers(_identifier, old, cur):
    old_size = old.value()
    cur_size = cur.value()
    # If we're increasing the number of registers, zero out the newly
    # available ones.  It is not really necessary to do this when
    # decreasing, because those registers will no longer be accessible.
    if cur_size > old_size:
        for r in range(cur_size - old_size):
            register[old_size + r] = Rpn_Float(0.0)

def define_variables():
    global sharpout, scr_cols, scr_rows
    global tvm_N, tvm_INT, tvm_PV, tvm_PMT, tvm_FV, tvm_CF, tvm_PF

    # Variables defined here are all protected=True by default
    sharpout = defvar('#OUT',  Rpn_Integer(0), readonly=True, noshadow=True)
    tvm_CF   = defvar('CF',    Rpn_Integer(1), noshadow=True, pre_hooks=[require_int, require_positive],
                      doc="TVM: Compounding Frequency")
    scr_cols = defvar('COLS',  Rpn_Integer(0), pre_hooks=[require_int, require_positive])
    tvm_FV   = defvar('FV',    None, noshadow=True, pre_hooks=[require_int_or_float],
                      doc="TVM: Future Value")
    tvm_INT  = defvar('INT',   None, noshadow=True, pre_hooks=[require_int_or_float, require_non_negative],
                      doc="TVM: Interest rate")
    tvm_N    = defvar('N',     None, noshadow=True, pre_hooks=[require_int_or_float, require_positive],
                      doc="TVM: Number of payments")
    _        = defvar('NUMPY', Rpn_Integer(bool_to_int(have_numpy)), readonly=True, noshadow=True)
    tvm_PF   = defvar('PF',    Rpn_Integer(1), noshadow=True, pre_hooks=[require_int, require_positive],
                      doc="TVM: Payment Frequency")
    tvm_PMT  = defvar('PMT',   None, noshadow=True, pre_hooks=[require_int_or_float],
                      doc="TVM: Payment amount")
    tvm_PV   = defvar('PV',    None, noshadow=True, pre_hooks=[require_int_or_float],
                      doc="TVM: Present Value")
    scr_rows = defvar('ROWS',  Rpn_Integer(0), pre_hooks=[require_int, require_positive])
    _        = defvar('RPNRC', Rpn_String(""), readonly=True, hidden=True)
    _        = defvar('SCIPY', Rpn_Integer(bool_to_int(have_scipy)), readonly=True, noshadow=True)
    _        = defvar('SIZE',  Rpn_Integer(20), noshadow=True, pre_hooks=[validate_size_arg], post_hooks=[clear_newly_unveiled_registers])
    _        = defvar('VER',   Rpn_Float(RPN_VERSION), readonly=True, noshadow=True)


def main():
    try:
        initialize()
        if go_interactive:
            main_loop()
    except Rpn_E_End_Program:
        pass
    except Rpn_E_Fatal as e:
        if len(str(e)) > 0:
            lnwriteln("Fatal error: {}".format(e))
        sys.exit(1)
    except Rpn_E_Throw as e:
        print("Uncaught exception: throw {}".format(e)) # OK
        sys.exit(1)

    end_program()


def main_loop():
    global show_x
    show_x = False    # Reset, because some argv may have set it to True

    # Non-existence of ~/.rpnrc is indicator of novice mode
    (rpnrc, _) = lookup_variable("RPNRC")
    init_file = rpnrc.obj().value()
    if len(init_file) == 0:
        lnwriteln("RPN version {}".format(RPN_VERSION))
        lnwriteln("Type ? for information, HELP <word> for help on a specific word")
        lnwriteln("Type bye to exit")

    if not param_stack.empty():
        if param_stack.size() == 1:
            w_dup()
            w_dot()
            w_cr()
        else:
            w_dot_s()

    while True:
        try:
            (error, tok_list) = generate_token_list()
        except StopIteration:
            return
        except Rpn_E_Top_Level:
            continue
        if error is True:
            lnwriteln("{}: generate_token_list() error".format(whoami()))
        s = " ".join([ t.value for t in tok_list ])
        dbg("parse", 1, "s='{}'".format(s))
        eval_string(s)


def end_program():
    global sharpout
    if sharpout.obj().value() != 0:
        writeln()

    if not string_stack.empty():
        if string_stack.size() == 1:
            w_dollar_dot()
            w_cr()
        else:
            lnwriteln("Strings:")
            w_dollar_dot_s()

    if not param_stack.empty():
        if param_stack.size() == 1:
            w_dot()
            w_cr()
        else:
            lnwriteln("Stack:")
            w_dot_s()




#############################################################################
#
#       M A I N
#
#############################################################################
disp_stack   = Rpn_Stack(1)
param_stack  = Rpn_Stack()
parse_stack  = Rpn_Stack()
return_stack = Rpn_Stack()
scope_stack  = Rpn_Stack(1)
string_stack = Rpn_Stack()

lexer = lex.lex(optimize=True)
parser = yacc.yacc(start='evaluate') # , errorlog=yacc.NullLogger())

if __name__ == "__main__":
    main()

sys.exit(0)
